{
  "functions": [
    {
      "name": "test_client_fixture",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 14,
      "docstring": "Create a test client for the test user.",
      "parameters": [
        "db_session",
        "test_user"
      ],
      "return_type": "Client",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_client_fixture(\n    db_session: AsyncSession,\n    test_user: User,\n) -> Client:\n    \"\"\"Create a test client for the test user.\"\"\"\n    client = Client(\n        user_id=test_user.id,\n        name=\"Test Client\",\n        email=\"testclient@example.com\",\n        company=\"Test Company\",\n    )\n    db_session.add(client)\n    await db_session.commit()\n    await db_session.refresh(client)\n    return client"
    },
    {
      "name": "other_user_client",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 32,
      "docstring": "Create a client belonging to another user.",
      "parameters": [
        "db_session",
        "other_user"
      ],
      "return_type": "Client",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def other_user_client(\n    db_session: AsyncSession,\n    other_user: User,\n) -> Client:\n    \"\"\"Create a client belonging to another user.\"\"\"\n    client = Client(\n        user_id=other_user.id,\n        name=\"Other User Client\",\n        email=\"otherclient@example.com\",\n        company=\"Other Company\",\n    )\n    db_session.add(client)\n    await db_session.commit()\n    await db_session.refresh(client)\n    return client"
    },
    {
      "name": "test_project",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 50,
      "docstring": "Create a test project.",
      "parameters": [
        "db_session",
        "test_user",
        "test_client_fixture"
      ],
      "return_type": "Project",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_project(\n    db_session: AsyncSession,\n    test_user: User,\n    test_client_fixture: Client,\n) -> Project:\n    \"\"\"Create a test project.\"\"\"\n    project = Project(\n        user_id=test_user.id,\n        client_id=test_client_fixture.id,\n        name=\"Test Project\",\n        description=\"A test project\",\n        status=ProjectStatus.ACTIVE,\n        budget=10000.00,\n        hourly_rate=150.00,\n        estimated_hours=100.0,\n    )\n    db_session.add(project)\n    await db_session.commit()\n    await db_session.refresh(project)\n    return project"
    },
    {
      "name": "test_create_project_success",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 75,
      "docstring": "Test creating a project with valid client_id.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_client_fixture"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_create_project_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test creating a project with valid client_id.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": str(test_client_fixture.id),\n                \"name\": \"New Project\",\n                \"description\": \"Project description\",\n                \"status\": \"active\",\n                \"budget\": \"5000.00\",\n                \"hourly_rate\": \"100.00\",\n                \"estimated_hours\": \"50.0\",\n            },\n        )\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"New Project\"\n        assert data[\"description\"] == \"Project description\"\n        assert data[\"client_id\"] == str(test_client_fixture.id)\n        assert data[\"client_name\"] == test_client_fixture.name\n        assert data[\"status\"] == \"active\"\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data"
    },
    {
      "name": "test_create_project_invalid_client",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 107,
      "docstring": "Test creating project with non-existent client_id returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_create_project_invalid_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test creating project with non-existent client_id returns 404.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": \"00000000-0000-0000-0000-000000000000\",\n                \"name\": \"New Project\",\n            },\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "test_create_project_other_users_client",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 125,
      "docstring": "Test creating project with another user's client returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_create_project_other_users_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_client: Client,\n    ):\n        \"\"\"Test creating project with another user's client returns 404.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": str(other_user_client.id),\n                \"name\": \"New Project\",\n            },\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "test_list_projects_empty",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 148,
      "docstring": "Test listing projects when user has none.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_list_projects_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test listing projects when user has none.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"projects\"] == []\n        assert data[\"total\"] == 0"
    },
    {
      "name": "test_list_projects_filter_by_status",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 164,
      "docstring": "Test filtering projects by status.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "test_user",
        "test_client_fixture"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_list_projects_filter_by_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        db_session: AsyncSession,\n        test_user: User,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test filtering projects by status.\"\"\"\n        # Create ACTIVE project\n        active_project = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Active Project\",\n            status=ProjectStatus.ACTIVE,\n        )\n        # Create COMPLETED project\n        completed_project = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Completed Project\",\n            status=ProjectStatus.COMPLETED,\n        )\n        db_session.add_all([active_project, completed_project])\n        await db_session.commit()\n        \n        # Filter by ACTIVE status\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            params={\"status\": \"active\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"total\"] == 1\n        assert len(data[\"projects\"]) == 1\n        assert data[\"projects\"][0][\"name\"] == \"Active Project\"\n        assert data[\"projects\"][0][\"status\"] == \"active\""
    },
    {
      "name": "test_list_projects_filter_by_client",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 204,
      "docstring": "Test filtering projects by client_id.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "test_user",
        "test_client_fixture"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_list_projects_filter_by_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        db_session: AsyncSession,\n        test_user: User,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test filtering projects by client_id.\"\"\"\n        # Create another client\n        other_client = Client(\n            user_id=test_user.id,\n            name=\"Other Client\",\n            email=\"other@example.com\",\n        )\n        db_session.add(other_client)\n        await db_session.commit()\n        await db_session.refresh(other_client)\n        \n        # Create project for test_client\n        project1 = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Project for Test Client\",\n            status=ProjectStatus.ACTIVE,\n        )\n        # Create project for other_client\n        project2 = Project(\n            user_id=test_user.id,\n            client_id=other_client.id,\n            name=\"Project for Other Client\",\n            status=ProjectStatus.ACTIVE,\n        )\n        db_session.add_all([project1, project2])\n        await db_session.commit()\n        \n        # Filter by test_client_fixture\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            params={\"client_id\": str(test_client_fixture.id)},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"total\"] == 1\n        assert len(data[\"projects\"]) == 1\n        assert data[\"projects\"][0][\"name\"] == \"Project for Test Client\"\n        assert data[\"projects\"][0][\"client_id\"] == str(test_client_fixture.id)"
    },
    {
      "name": "test_get_project_with_stats",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 258,
      "docstring": "Test getting a project with stats.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_client_fixture"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_project_with_stats(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test getting a project with stats.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == str(test_project.id)\n        assert data[\"name\"] == \"Test Project\"\n        assert data[\"client_name\"] == test_client_fixture.name\n        # Stats should be 0 initially\n        assert data[\"scope_item_count\"] == 0\n        assert data[\"completed_scope_count\"] == 0\n        assert data[\"out_of_scope_request_count\"] == 0"
    },
    {
      "name": "test_get_project_not_found",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 281,
      "docstring": "Test getting non-existent project returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test getting non-existent project returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Project not found\""
    },
    {
      "name": "test_get_project_invalid_uuid",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 295,
      "docstring": "Test getting project with invalid UUID returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_project_invalid_uuid(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test getting project with invalid UUID returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/invalid-uuid\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Project not found\""
    },
    {
      "name": "test_get_project_detail",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 313,
      "docstring": "Test getting project detail with scope items and requests.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_project_detail(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test getting project detail with scope items and requests.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/detail\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == str(test_project.id)\n        assert \"scope_items\" in data\n        assert \"recent_requests\" in data\n        assert data[\"scope_items\"] == []\n        assert data[\"recent_requests\"] == []"
    },
    {
      "name": "test_update_project_status",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 337,
      "docstring": "Test updating project status from ACTIVE to COMPLETED.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_update_project_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test updating project status from ACTIVE to COMPLETED.\"\"\"\n        assert test_project.status == ProjectStatus.ACTIVE\n        \n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n            json={\"status\": \"completed\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"completed\""
    },
    {
      "name": "test_update_project_partial",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 356,
      "docstring": "Test partial update only changes specified fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_update_project_partial(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test partial update only changes specified fields.\"\"\"\n        original_description = test_project.description\n        \n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n            json={\"name\": \"Updated Name\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n        assert data[\"description\"] == original_description"
    },
    {
      "name": "test_update_project_not_found",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 376,
      "docstring": "Test updating non-existent project returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_update_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test updating non-existent project returns 404.\"\"\"\n        response = await client.patch(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n            json={\"name\": \"New Name\"},\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "test_delete_project_success",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 394,
      "docstring": "Test deleting a project returns 204.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_delete_project_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test deleting a project returns 204.\"\"\"\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 204\n        \n        # Verify project is deleted\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == 404"
    },
    {
      "name": "test_delete_project_not_found",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 415,
      "docstring": "Test deleting non-existent project returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_delete_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test deleting non-existent project returns 404.\"\"\"\n        response = await client.delete(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "get_current_user",
      "file_path": "app/api/deps.py",
      "line_number": 23,
      "docstring": "Get the current authenticated user from the JWT token.",
      "parameters": [
        "credentials",
        "db"
      ],
      "return_type": "User",
      "decorators": [],
      "is_async": true,
      "source": "async def get_current_user(\n    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],\n    db: Annotated[AsyncSession, Depends(get_db)],\n) -> User:\n    \"\"\"Get the current authenticated user from the JWT token.\"\"\"\n    \n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    token = credentials.credentials\n    payload = decode_access_token(token)\n    \n    if payload is None:\n        raise credentials_exception\n    \n    user_id: str | None = payload.get(\"sub\")\n    if user_id is None:\n        raise credentials_exception\n    \n    try:\n        user_uuid = uuid.UUID(user_id)\n    except ValueError:\n        raise credentials_exception\n    \n    result = await db.execute(\n        select(User).where(User.id == user_uuid)\n    )\n    user = result.scalar_one_or_none()\n    \n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User account is deactivated\",\n        )\n    \n    return user"
    },
    {
      "name": "get_subscription",
      "file_path": "app/api/deps.py",
      "line_number": 75,
      "docstring": "Get or create user's subscription.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "Subscription",
      "decorators": [],
      "is_async": true,
      "source": "async def get_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> Subscription:\n    \"\"\"Get or create user's subscription.\"\"\"\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    return subscription"
    },
    {
      "name": "check_project_limit",
      "file_path": "app/api/deps.py",
      "line_number": 98,
      "docstring": "Check if user can create a new project. Raises 403 if limit exceeded.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [],
      "is_async": true,
      "source": "async def check_project_limit(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Check if user can create a new project. Raises 403 if limit exceeded.\"\"\"\n    # Get subscription\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    # Count projects\n    count_result = await db.execute(\n        select(func.count(Project.id)).where(Project.user_id == current_user.id)\n    )\n    current_count = count_result.scalar() or 0\n\n    if current_count >= subscription.max_projects:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail={\n                \"error\": \"plan_limit_exceeded\",\n                \"limit_type\": \"projects\",\n                \"current\": current_count,\n                \"max\": subscription.max_projects,\n                \"message\": f\"You've reached the limit of {subscription.max_projects} projects on the Free plan. Upgrade to Pro for unlimited projects.\",\n                \"upgrade_url\": \"/settings/billing\",\n            }\n        )"
    },
    {
      "name": "check_client_limit",
      "file_path": "app/api/deps.py",
      "line_number": 139,
      "docstring": "Check if user can create a new client. Raises 403 if limit exceeded.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [],
      "is_async": true,
      "source": "async def check_client_limit(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Check if user can create a new client. Raises 403 if limit exceeded.\"\"\"\n    # Get subscription\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    # Count clients\n    count_result = await db.execute(\n        select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    )\n    current_count = count_result.scalar() or 0\n\n    if current_count >= subscription.max_clients:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail={\n                \"error\": \"plan_limit_exceeded\",\n                \"limit_type\": \"clients\",\n                \"current\": current_count,\n                \"max\": subscription.max_clients,\n                \"message\": f\"You've reached the limit of {subscription.max_clients} clients on the Free plan. Upgrade to Pro for unlimited clients.\",\n                \"upgrade_url\": \"/settings/billing\",\n            }\n        )"
    },
    {
      "name": "validate_estimated_hours",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 17,
      "docstring": "Validate and round estimated hours to 1 decimal place.",
      "parameters": [
        "cls",
        "v"
      ],
      "return_type": null,
      "decorators": [
        "classmethod"
      ],
      "is_async": false,
      "source": "    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "validate_estimated_hours",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 32,
      "docstring": "Validate and round estimated hours to 1 decimal place.",
      "parameters": [
        "cls",
        "v"
      ],
      "return_type": null,
      "decorators": [
        "classmethod"
      ],
      "is_async": false,
      "source": "    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "validate_estimated_hours",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 48,
      "docstring": "Validate and round estimated hours to 1 decimal place.",
      "parameters": [
        "cls",
        "v"
      ],
      "return_type": null,
      "decorators": [
        "classmethod"
      ],
      "is_async": false,
      "source": "    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "create_customer",
      "file_path": "app/services/stripe_service.py",
      "line_number": 28,
      "docstring": "Create a Stripe customer for a user.",
      "parameters": [
        "user"
      ],
      "return_type": "str",
      "decorators": [
        "staticmethod"
      ],
      "is_async": false,
      "source": "    def create_customer(user: User) -> str:\n        \"\"\"Create a Stripe customer for a user.\"\"\"\n        customer = stripe.Customer.create(\n            email=user.email,\n            name=user.full_name,\n            metadata={\n                \"user_id\": str(user.id),\n            }\n        )\n        return customer.id"
    },
    {
      "name": "create_checkout_session",
      "file_path": "app/services/stripe_service.py",
      "line_number": 40,
      "docstring": "Create a Stripe Checkout session for Pro subscription.",
      "parameters": [
        "db",
        "user",
        "success_url",
        "cancel_url"
      ],
      "return_type": "str",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def create_checkout_session(\n        db: AsyncSession,\n        user: User,\n        success_url: str,\n        cancel_url: str,\n    ) -> str:\n        \"\"\"Create a Stripe Checkout session for Pro subscription.\"\"\"\n        # Get or create subscription record\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription:\n            subscription = Subscription(user_id=user.id)\n            db.add(subscription)\n            await db.commit()\n            await db.refresh(subscription)\n\n        # Get or create Stripe customer\n        if not subscription.stripe_customer_id:\n            customer_id = StripeService.create_customer(user)\n            subscription.stripe_customer_id = customer_id\n            await db.commit()\n        else:\n            customer_id = subscription.stripe_customer_id\n\n        # Create checkout session\n        checkout_session = stripe.checkout.Session.create(\n            customer=customer_id,\n            payment_method_types=[\"card\"],\n            line_items=[\n                {\n                    \"price\": StripeService.PRO_MONTHLY_PRICE_ID,\n                    \"quantity\": 1,\n                }\n            ],\n            mode=\"subscription\",\n            success_url=success_url,\n            cancel_url=cancel_url,\n            metadata={\n                \"user_id\": str(user.id),\n            },\n            subscription_data={\n                \"metadata\": {\n                    \"user_id\": str(user.id),\n                }\n            },\n            allow_promotion_codes=True,\n        )\n\n        return checkout_session.url"
    },
    {
      "name": "create_portal_session",
      "file_path": "app/services/stripe_service.py",
      "line_number": 94,
      "docstring": "Create a Stripe Customer Portal session for managing subscription.",
      "parameters": [
        "db",
        "user",
        "return_url"
      ],
      "return_type": "str",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def create_portal_session(\n        db: AsyncSession,\n        user: User,\n        return_url: str,\n    ) -> str:\n        \"\"\"Create a Stripe Customer Portal session for managing subscription.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_customer_id:\n            raise ValueError(\"No subscription found for user\")\n\n        portal_session = stripe.billing_portal.Session.create(\n            customer=subscription.stripe_customer_id,\n            return_url=return_url,\n        )\n\n        return portal_session.url"
    },
    {
      "name": "handle_checkout_completed",
      "file_path": "app/services/stripe_service.py",
      "line_number": 116,
      "docstring": "Handle successful checkout session completion.",
      "parameters": [
        "db",
        "session"
      ],
      "return_type": "None",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def handle_checkout_completed(db: AsyncSession, session: dict) -> None:\n        \"\"\"Handle successful checkout session completion.\"\"\"\n        customer_id = session.get(\"customer\")\n        subscription_id = session.get(\"subscription\")\n        user_id = session.get(\"metadata\", {}).get(\"user_id\")\n\n        if not user_id:\n            result = await db.execute(\n                select(Subscription).where(Subscription.stripe_customer_id == customer_id)\n            )\n            subscription = result.scalar_one_or_none()\n        else:\n            result = await db.execute(\n                select(Subscription).where(Subscription.user_id == user_id)\n            )\n            subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.stripe_subscription_id = subscription_id\n            subscription.stripe_customer_id = customer_id\n            subscription.plan = PlanType.PRO\n            subscription.status = SubscriptionStatus.ACTIVE\n            await db.commit()"
    },
    {
      "name": "handle_subscription_updated",
      "file_path": "app/services/stripe_service.py",
      "line_number": 141,
      "docstring": "Handle subscription update from Stripe webhook.",
      "parameters": [
        "db",
        "stripe_subscription"
      ],
      "return_type": "None",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def handle_subscription_updated(db: AsyncSession, stripe_subscription: dict) -> None:\n        \"\"\"Handle subscription update from Stripe webhook.\"\"\"\n        subscription_id = stripe_subscription.get(\"id\")\n        customer_id = stripe_subscription.get(\"customer\")\n        status = stripe_subscription.get(\"status\")\n        \n        result = await db.execute(\n            select(Subscription).where(\n                (Subscription.stripe_subscription_id == subscription_id) |\n                (Subscription.stripe_customer_id == customer_id)\n            )\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription:\n            return\n\n        subscription.stripe_subscription_id = subscription_id\n        subscription.status = SubscriptionStatus(status) if status in [s.value for s in SubscriptionStatus] else SubscriptionStatus.ACTIVE\n        \n        current_period_start = stripe_subscription.get(\"current_period_start\")\n        current_period_end = stripe_subscription.get(\"current_period_end\")\n        \n        if current_period_start:\n            subscription.current_period_start = datetime.fromtimestamp(current_period_start)\n        if current_period_end:\n            subscription.current_period_end = datetime.fromtimestamp(current_period_end)\n\n        subscription.cancel_at_period_end = stripe_subscription.get(\"cancel_at_period_end\", False)\n\n        if status in [\"active\", \"trialing\"]:\n            subscription.plan = PlanType.PRO\n        elif status in [\"canceled\", \"unpaid\"]:\n            subscription.plan = PlanType.FREE\n\n        await db.commit()"
    },
    {
      "name": "handle_subscription_deleted",
      "file_path": "app/services/stripe_service.py",
      "line_number": 179,
      "docstring": "Handle subscription cancellation/deletion.",
      "parameters": [
        "db",
        "stripe_subscription"
      ],
      "return_type": "None",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def handle_subscription_deleted(db: AsyncSession, stripe_subscription: dict) -> None:\n        \"\"\"Handle subscription cancellation/deletion.\"\"\"\n        subscription_id = stripe_subscription.get(\"id\")\n        \n        result = await db.execute(\n            select(Subscription).where(Subscription.stripe_subscription_id == subscription_id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.plan = PlanType.FREE\n            subscription.status = SubscriptionStatus.CANCELED\n            subscription.stripe_subscription_id = None\n            await db.commit()"
    },
    {
      "name": "handle_invoice_payment_failed",
      "file_path": "app/services/stripe_service.py",
      "line_number": 195,
      "docstring": "Handle failed invoice payment.",
      "parameters": [
        "db",
        "invoice"
      ],
      "return_type": "None",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def handle_invoice_payment_failed(db: AsyncSession, invoice: dict) -> None:\n        \"\"\"Handle failed invoice payment.\"\"\"\n        customer_id = invoice.get(\"customer\")\n        \n        result = await db.execute(\n            select(Subscription).where(Subscription.stripe_customer_id == customer_id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.status = SubscriptionStatus.PAST_DUE\n            await db.commit()"
    },
    {
      "name": "cancel_subscription",
      "file_path": "app/services/stripe_service.py",
      "line_number": 209,
      "docstring": "Cancel a user's subscription at period end.",
      "parameters": [
        "db",
        "user"
      ],
      "return_type": "bool",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def cancel_subscription(db: AsyncSession, user: User) -> bool:\n        \"\"\"Cancel a user's subscription at period end.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_subscription_id:\n            return False\n\n        stripe.Subscription.modify(\n            subscription.stripe_subscription_id,\n            cancel_at_period_end=True\n        )\n\n        subscription.cancel_at_period_end = True\n        await db.commit()\n\n        return True"
    },
    {
      "name": "reactivate_subscription",
      "file_path": "app/services/stripe_service.py",
      "line_number": 230,
      "docstring": "Reactivate a canceled subscription before period ends.",
      "parameters": [
        "db",
        "user"
      ],
      "return_type": "bool",
      "decorators": [
        "staticmethod"
      ],
      "is_async": true,
      "source": "    async def reactivate_subscription(db: AsyncSession, user: User) -> bool:\n        \"\"\"Reactivate a canceled subscription before period ends.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_subscription_id:\n            return False\n\n        stripe.Subscription.modify(\n            subscription.stripe_subscription_id,\n            cancel_at_period_end=False\n        )\n\n        subscription.cancel_at_period_end = False\n        await db.commit()\n\n        return True"
    },
    {
      "name": "get_webhook_secret",
      "file_path": "app/services/stripe_service.py",
      "line_number": 251,
      "docstring": "Get the webhook secret for verifying Stripe webhooks.",
      "parameters": [],
      "return_type": "str",
      "decorators": [
        "staticmethod"
      ],
      "is_async": false,
      "source": "    def get_webhook_secret() -> str:\n        \"\"\"Get the webhook secret for verifying Stripe webhooks.\"\"\"\n        return os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")"
    },
    {
      "name": "get_dashboard_summary",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 36,
      "docstring": "Get aggregated summary stats for the user.",
      "parameters": [
        "db",
        "user_id"
      ],
      "return_type": "DashboardSummary",
      "decorators": [],
      "is_async": true,
      "source": "async def get_dashboard_summary(\n    db: AsyncSession,\n    user_id: UUID,\n) -> DashboardSummary:\n    \"\"\"Get aggregated summary stats for the user.\"\"\"\n    \n    # Total and active projects\n    projects_query = select(\n        func.count(Project.id).label(\"total\"),\n        func.sum(\n            case((Project.status == ProjectStatus.ACTIVE, 1), else_=0)\n        ).label(\"active\"),\n    ).where(Project.user_id == user_id)\n    \n    projects_result = await db.execute(projects_query)\n    projects_row = projects_result.one()\n    \n    # Total clients\n    clients_query = select(func.count(Client.id)).where(Client.user_id == user_id)\n    clients_result = await db.execute(clients_query)\n    total_clients = clients_result.scalar() or 0\n    \n    # Get user's project IDs for request/proposal queries\n    project_ids_query = select(Project.id).where(Project.user_id == user_id)\n    project_ids_result = await db.execute(project_ids_query)\n    project_ids = [row[0] for row in project_ids_result.fetchall()]\n    \n    # Request stats\n    total_requests = 0\n    out_of_scope_requests = 0\n    pending_requests = 0\n    \n    if project_ids:\n        requests_query = select(\n            func.count(ClientRequest.id).label(\"total\"),\n            func.sum(\n                case(\n                    (ClientRequest.classification == ScopeClassification.OUT_OF_SCOPE, 1),\n                    else_=0\n                )\n            ).label(\"out_of_scope\"),\n            func.sum(\n                case((ClientRequest.status == RequestStatus.NEW, 1), else_=0)\n            ).label(\"pending\"),\n        ).where(ClientRequest.project_id.in_(project_ids))\n        \n        requests_result = await db.execute(requests_query)\n        requests_row = requests_result.one()\n        total_requests = requests_row.total or 0\n        out_of_scope_requests = int(requests_row.out_of_scope or 0)\n        pending_requests = int(requests_row.pending or 0)\n    \n    # Proposal stats\n    total_proposals = 0\n    pending_proposals = 0\n    accepted_proposals = 0\n    total_revenue_protected = Decimal(\"0.00\")\n    \n    if project_ids:\n        proposals_query = select(\n            func.count(Proposal.id).label(\"total\"),\n            func.sum(\n                case(\n                    (Proposal.status.in_([ProposalStatus.DRAFT, ProposalStatus.SENT]), 1),\n                    else_=0\n                )\n            ).label(\"pending\"),\n            func.sum(\n                case((Proposal.status == ProposalStatus.ACCEPTED, 1), else_=0)\n            ).label(\"accepted\"),\n            func.coalesce(\n                func.sum(\n                    case(\n                        (Proposal.status == ProposalStatus.ACCEPTED, Proposal.amount),\n                        else_=Decimal(\"0.00\")\n                    )\n                ),\n                Decimal(\"0.00\")\n            ).label(\"revenue\"),\n        ).where(Proposal.project_id.in_(project_ids))\n        \n        proposals_result = await db.execute(proposals_query)\n        proposals_row = proposals_result.one()\n        total_proposals = proposals_row.total or 0\n        pending_proposals = int(proposals_row.pending or 0)\n        accepted_proposals = int(proposals_row.accepted or 0)\n        total_revenue_protected = proposals_row.revenue or Decimal(\"0.00\")\n    \n    return DashboardSummary(\n        total_projects=projects_row.total or 0,\n        active_projects=int(projects_row.active or 0),\n        total_clients=total_clients,\n        total_requests=total_requests,\n        out_of_scope_requests=out_of_scope_requests,\n        pending_requests=pending_requests,\n        total_proposals=total_proposals,\n        pending_proposals=pending_proposals,\n        accepted_proposals=accepted_proposals,\n        total_revenue_protected=total_revenue_protected,\n    )"
    },
    {
      "name": "get_alerts",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 138,
      "docstring": "Generate alerts for the user based on project data.",
      "parameters": [
        "db",
        "user_id"
      ],
      "return_type": "list[Alert]",
      "decorators": [],
      "is_async": true,
      "source": "async def get_alerts(\n    db: AsyncSession,\n    user_id: UUID,\n) -> list[Alert]:\n    \"\"\"Generate alerts for the user based on project data.\"\"\"\n    alerts: list[Alert] = []\n    now = datetime.now(timezone.utc)\n    seven_days_ago = now - timedelta(days=7)\n    forty_eight_hours_ago = now - timedelta(hours=48)\n    fourteen_days_ago = now - timedelta(days=14)\n    \n    # Get user's projects with names\n    projects_query = select(Project).where(Project.user_id == user_id)\n    projects_result = await db.execute(projects_query)\n    projects = {p.id: p for p in projects_result.scalars().all()}\n    \n    if not projects:\n        return alerts\n    \n    project_ids = list(projects.keys())\n    \n    # Alert 1: Scope creep - Projects with >3 OUT_OF_SCOPE requests in last 7 days\n    scope_creep_query = (\n        select(\n            ClientRequest.project_id,\n            func.count(ClientRequest.id).label(\"count\"),\n        )\n        .where(\n            and_(\n                ClientRequest.project_id.in_(project_ids),\n                ClientRequest.classification == ScopeClassification.OUT_OF_SCOPE,\n                ClientRequest.created_at >= seven_days_ago,\n            )\n        )\n        .group_by(ClientRequest.project_id)\n        .having(func.count(ClientRequest.id) > 3)\n    )\n    \n    scope_creep_result = await db.execute(scope_creep_query)\n    for row in scope_creep_result.fetchall():\n        project = projects.get(row.project_id)\n        if project:\n            alerts.append(\n                Alert(\n                    type=\"scope_creep\",\n                    severity=\"high\",\n                    message=f\"Project has {row.count} out-of-scope requests in the last 7 days\",\n                    project_id=project.id,\n                    project_name=project.name,\n                    related_id=None,\n                    created_at=now,\n                )\n            )\n    \n    # Alert 2: Pending requests - NEW status older than 48 hours\n    pending_query = select(ClientRequest).where(\n        and_(\n            ClientRequest.project_id.in_(project_ids),\n            ClientRequest.status == RequestStatus.NEW,\n            ClientRequest.created_at < forty_eight_hours_ago,\n        )\n    )\n    \n    pending_result = await db.execute(pending_query)\n    for request in pending_result.scalars().all():\n        project = projects.get(request.project_id)\n        if project:\n            # Handle timezone-aware comparison\n            request_created = request.created_at\n            if request_created.tzinfo is None:\n                request_created = request_created.replace(tzinfo=timezone.utc)\n            age_hours = int((now - request_created).total_seconds() / 3600)\n            alerts.append(\n                Alert(\n                    type=\"pending_request\",\n                    severity=\"medium\",\n                    message=f\"Request pending analysis for {age_hours} hours\",\n                    project_id=project.id,\n                    project_name=project.name,\n                    related_id=request.id,\n                    created_at=request.created_at,\n                )\n            )\n    \n    # Alert 3: Proposal expiring - SENT proposals older than 14 days\n    expiring_query = select(Proposal).where(\n        and_(\n            Proposal.project_id.in_(project_ids),\n            Proposal.status == ProposalStatus.SENT,\n            Proposal.created_at < fourteen_days_ago,\n        )\n    )\n    \n    expiring_result = await db.execute(expiring_query)\n    for proposal in expiring_result.scalars().all():\n        project = projects.get(proposal.project_id)\n        if project:\n            # Handle timezone-aware comparison\n            proposal_created = proposal.created_at\n            if proposal_created.tzinfo is None:\n                proposal_created = proposal_created.replace(tzinfo=timezone.utc)\n            age_days = (now - proposal_created).days\n            alerts.append(\n                Alert(\n                    type=\"proposal_expiring\",\n                    severity=\"medium\",\n                    message=f\"Proposal sent {age_days} days ago with no response\",\n                    project_id=project.id,\n                    project_name=project.name,\n                    related_id=proposal.id,\n                    created_at=proposal.created_at,\n                )\n            )\n    \n    # Sort alerts by severity (high first) then by created_at (newest first)\n    severity_order = {\"high\": 0, \"medium\": 1, \"low\": 2}\n    alerts.sort(key=lambda a: (severity_order[a.severity], -a.created_at.timestamp()))\n    \n    return alerts"
    },
    {
      "name": "get_recent_activity",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 259,
      "docstring": "Get recent activity across all projects.",
      "parameters": [
        "db",
        "user_id",
        "limit"
      ],
      "return_type": "list[RecentActivity]",
      "decorators": [],
      "is_async": true,
      "source": "async def get_recent_activity(\n    db: AsyncSession,\n    user_id: UUID,\n    limit: int = 20,\n) -> list[RecentActivity]:\n    \"\"\"Get recent activity across all projects.\"\"\"\n    activities: list[RecentActivity] = []\n    \n    # Get user's projects\n    projects_query = select(Project).where(Project.user_id == user_id)\n    projects_result = await db.execute(projects_query)\n    projects = {p.id: p for p in projects_result.scalars().all()}\n    \n    if not projects:\n        return activities\n    \n    project_ids = list(projects.keys())\n    \n    # Get recent requests (both created and analyzed)\n    requests_query = (\n        select(ClientRequest)\n        .where(ClientRequest.project_id.in_(project_ids))\n        .order_by(ClientRequest.updated_at.desc())\n        .limit(limit)\n    )\n    \n    requests_result = await db.execute(requests_query)\n    for request in requests_result.scalars().all():\n        project = projects.get(request.project_id)\n        if project:\n            # Request created activity\n            title_display = f\"{request.title[:50]}...\" if len(request.title) > 50 else request.title\n            activities.append(\n                RecentActivity(\n                    type=\"request_created\",\n                    message=f\"New request: {title_display}\",\n                    project_id=project.id,\n                    project_name=project.name,\n                    timestamp=request.created_at,\n                )\n            )\n            \n            # If analyzed, add that activity too\n            if request.status == RequestStatus.ANALYZED and request.updated_at != request.created_at:\n                classification = request.classification.value if request.classification else \"unknown\"\n                activities.append(\n                    RecentActivity(\n                        type=\"request_analyzed\",\n                        message=f\"Request analyzed as {classification}\",\n                        project_id=project.id,\n                        project_name=project.name,\n                        timestamp=request.updated_at,\n                    )\n                )\n    \n    # Get recent proposals\n    proposals_query = (\n        select(Proposal)\n        .where(Proposal.project_id.in_(project_ids))\n        .order_by(Proposal.updated_at.desc())\n        .limit(limit)\n    )\n    \n    proposals_result = await db.execute(proposals_query)\n    for proposal in proposals_result.scalars().all():\n        project = projects.get(proposal.project_id)\n        if project:\n            if proposal.status == ProposalStatus.SENT:\n                activities.append(\n                    RecentActivity(\n                        type=\"proposal_sent\",\n                        message=f\"Proposal sent: ${proposal.amount}\",\n                        project_id=project.id,\n                        project_name=project.name,\n                        timestamp=proposal.updated_at,\n                    )\n                )\n            elif proposal.status == ProposalStatus.ACCEPTED:\n                activities.append(\n                    RecentActivity(\n                        type=\"proposal_accepted\",\n                        message=f\"Proposal accepted: ${proposal.amount}\",\n                        project_id=project.id,\n                        project_name=project.name,\n                        timestamp=proposal.updated_at,\n                    )\n                )\n    \n    # Get completed scope items\n    scope_items_query = (\n        select(ScopeItem)\n        .where(\n            and_(\n                ScopeItem.project_id.in_(project_ids),\n                ScopeItem.is_completed == True,  # noqa: E712\n            )\n        )\n        .order_by(ScopeItem.updated_at.desc())\n        .limit(limit)\n    )\n    \n    scope_items_result = await db.execute(scope_items_query)\n    for item in scope_items_result.scalars().all():\n        project = projects.get(item.project_id)\n        if project:\n            title_display = f\"{item.title[:40]}...\" if len(item.title) > 40 else item.title\n            activities.append(\n                RecentActivity(\n                    type=\"scope_completed\",\n                    message=f\"Scope item completed: {title_display}\",\n                    project_id=project.id,\n                    project_name=project.name,\n                    timestamp=item.updated_at,\n                )\n            )\n    \n    # Sort by timestamp descending and limit\n    activities.sort(key=lambda a: a.timestamp, reverse=True)\n    return activities[:limit]"
    },
    {
      "name": "calculate_project_health",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 380,
      "docstring": "Calculate health metrics for a single project.",
      "parameters": [
        "db",
        "project"
      ],
      "return_type": "ProjectHealth",
      "decorators": [],
      "is_async": true,
      "source": "async def calculate_project_health(\n    db: AsyncSession,\n    project: Project,\n) -> ProjectHealth:\n    \"\"\"Calculate health metrics for a single project.\"\"\"\n    now = datetime.now(timezone.utc)\n    twenty_four_hours_ago = now - timedelta(hours=24)\n    \n    # Scope item stats - using is_completed boolean\n    scope_query = select(\n        func.count(ScopeItem.id).label(\"total\"),\n        func.sum(\n            case((ScopeItem.is_completed == True, 1), else_=0)  # noqa: E712\n        ).label(\"completed\"),\n    ).where(ScopeItem.project_id == project.id)\n    \n    scope_result = await db.execute(scope_query)\n    scope_row = scope_result.one()\n    scope_total = scope_row.total or 0\n    scope_completed = int(scope_row.completed or 0)\n    scope_completion_pct = (scope_completed / scope_total * 100) if scope_total > 0 else 0.0\n    \n    # Request stats - using 'classification' field (not scope_classification)\n    requests_query = select(\n        func.count(ClientRequest.id).label(\"total\"),\n        func.sum(\n            case(\n                (ClientRequest.classification == ScopeClassification.IN_SCOPE, 1),\n                else_=0\n            )\n        ).label(\"in_scope\"),\n        func.sum(\n            case(\n                (ClientRequest.classification == ScopeClassification.OUT_OF_SCOPE, 1),\n                else_=0\n            )\n        ).label(\"out_of_scope\"),\n        func.sum(\n            case((ClientRequest.status == RequestStatus.NEW, 1), else_=0)\n        ).label(\"pending\"),\n        func.sum(\n            case(\n                (\n                    and_(\n                        ClientRequest.status == RequestStatus.NEW,\n                        ClientRequest.created_at < twenty_four_hours_ago,\n                    ),\n                    1\n                ),\n                else_=0\n            )\n        ).label(\"pending_old\"),\n    ).where(ClientRequest.project_id == project.id)\n    \n    requests_result = await db.execute(requests_query)\n    requests_row = requests_result.one()\n    total_requests = requests_row.total or 0\n    in_scope = int(requests_row.in_scope or 0)\n    out_of_scope = int(requests_row.out_of_scope or 0)\n    pending = int(requests_row.pending or 0)\n    pending_old = int(requests_row.pending_old or 0)\n    scope_creep_ratio = (out_of_scope / total_requests) if total_requests > 0 else 0.0\n    \n    # Proposal stats\n    proposals_query = select(\n        func.sum(\n            case((Proposal.status == ProposalStatus.SENT, 1), else_=0)\n        ).label(\"sent\"),\n        func.sum(\n            case((Proposal.status == ProposalStatus.ACCEPTED, 1), else_=0)\n        ).label(\"accepted\"),\n        func.coalesce(\n            func.sum(\n                case(\n                    (Proposal.status == ProposalStatus.ACCEPTED, Proposal.amount),\n                    else_=Decimal(\"0.00\")\n                )\n            ),\n            Decimal(\"0.00\")\n        ).label(\"revenue\"),\n    ).where(Proposal.project_id == project.id)\n    \n    proposals_result = await db.execute(proposals_query)\n    proposals_row = proposals_result.one()\n    proposals_sent = int(proposals_row.sent or 0)\n    proposals_accepted = int(proposals_row.accepted or 0)\n    revenue_protected = proposals_row.revenue or Decimal(\"0.00\")\n    \n    # Calculate health score\n    health_score = 100\n    \n    # Subtract 10 for each unaddressed OUT_OF_SCOPE request\n    unaddressed_out_of_scope_query = select(func.count(ClientRequest.id)).where(\n        and_(\n            ClientRequest.project_id == project.id,\n            ClientRequest.classification == ScopeClassification.OUT_OF_SCOPE,\n            ClientRequest.status.in_([RequestStatus.NEW, RequestStatus.ANALYZED]),\n        )\n    )\n    unaddressed_result = await db.execute(unaddressed_out_of_scope_query)\n    unaddressed_count = unaddressed_result.scalar() or 0\n    health_score -= unaddressed_count * 10\n    \n    # Subtract 5 for each pending request >24h old\n    health_score -= pending_old * 5\n    \n    # Add 5 for each accepted proposal\n    health_score += proposals_accepted * 5\n    \n    # Clamp to 0-100\n    health_score = max(0, min(100, health_score))\n    \n    # Get budget from project if it exists\n    budget = getattr(project, 'budget', None)\n    \n    return ProjectHealth(\n        project_id=project.id,\n        project_name=project.name,\n        status=project.status.value,\n        scope_completion_percentage=round(scope_completion_pct, 1),\n        scope_items_total=scope_total,\n        scope_items_completed=scope_completed,\n        total_requests=total_requests,\n        in_scope_requests=in_scope,\n        out_of_scope_requests=out_of_scope,\n        pending_analysis=pending,\n        scope_creep_ratio=round(scope_creep_ratio, 2),\n        budget=budget,\n        proposals_sent=proposals_sent,\n        proposals_accepted=proposals_accepted,\n        revenue_protected=revenue_protected,\n        health_score=health_score,\n    )"
    },
    {
      "name": "get_dashboard",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 516,
      "docstring": "Get full dashboard data including summary, alerts, activity, and project health.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "DashboardResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_dashboard(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> DashboardResponse:\n    \"\"\"Get full dashboard data including summary, alerts, activity, and project health.\"\"\"\n    \n    # Get summary stats\n    summary = await get_dashboard_summary(db, current_user.id)\n    \n    # Get alerts\n    alerts = await get_alerts(db, current_user.id)\n    \n    # Get recent activity\n    recent_activity = await get_recent_activity(db, current_user.id, limit=20)\n    \n    # Get health for top 5 active projects\n    projects_query = (\n        select(Project)\n        .where(\n            and_(\n                Project.user_id == current_user.id,\n                Project.status == ProjectStatus.ACTIVE,\n            )\n        )\n        .order_by(Project.updated_at.desc())\n        .limit(5)\n    )\n    \n    projects_result = await db.execute(projects_query)\n    projects = projects_result.scalars().all()\n    \n    project_health = []\n    for project in projects:\n        health = await calculate_project_health(db, project)\n        project_health.append(health)\n    \n    return DashboardResponse(\n        summary=summary,\n        alerts=alerts,\n        recent_activity=recent_activity,\n        project_health=project_health,\n    )"
    },
    {
      "name": "get_summary",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 561,
      "docstring": "Get just the summary stats.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "DashboardSummary",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_summary(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> DashboardSummary:\n    \"\"\"Get just the summary stats.\"\"\"\n    return await get_dashboard_summary(db, current_user.id)"
    },
    {
      "name": "get_alerts_endpoint",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 570,
      "docstring": "Get alerts only.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": "list[Alert]",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_alerts_endpoint(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[Alert]:\n    \"\"\"Get alerts only.\"\"\"\n    return await get_alerts(db, current_user.id)"
    },
    {
      "name": "get_activity",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 579,
      "docstring": "Get recent activity (last 20 items by default).",
      "parameters": [
        "db",
        "current_user",
        "limit"
      ],
      "return_type": "list[RecentActivity]",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_activity(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    limit: int = Query(default=20, le=50, ge=1),\n) -> list[RecentActivity]:\n    \"\"\"Get recent activity (last 20 items by default).\"\"\"\n    return await get_recent_activity(db, current_user.id, limit=limit)"
    },
    {
      "name": "get_project_health",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 589,
      "docstring": "Get health metrics for a specific project.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "ProjectHealth",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_project_health(\n    project_id: UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectHealth:\n    \"\"\"Get health metrics for a specific project.\"\"\"\n    \n    # Verify project exists and belongs to user\n    project_query = select(Project).where(\n        and_(\n            Project.id == project_id,\n            Project.user_id == current_user.id,\n        )\n    )\n    \n    result = await db.execute(project_query)\n    project = result.scalar_one_or_none()\n    \n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    return await calculate_project_health(db, project)"
    },
    {
      "name": "_build_user_prompt",
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 42,
      "docstring": "Build the user prompt for the AI model.",
      "parameters": [
        "request"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "def _build_user_prompt(request: AnalysisRequest) -> str:\n    \"\"\"Build the user prompt for the AI model.\"\"\"\n    scope_list = \"\\n\".join(\n        f\"{i}. {item.title}\" + (f\" - {item.description}\" if item.description else \"\")\n        for i, item in enumerate(request.scope_items)\n    )\n\n    if not scope_list:\n        scope_list = \"(No scope items defined)\"\n\n    prompt = f\"\"\"## Project Scope Items:\n{scope_list}\n\n## Client Request:\n{request.request_content}\n\"\"\"\n\n    if request.project_context:\n        prompt += f\"\\n## Project Context:\\n{request.project_context}\\n\"\n\n    prompt += \"\\nAnalyze this request and provide your assessment as JSON.\"\n    return prompt"
    },
    {
      "name": "_parse_ai_response",
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 66,
      "docstring": "Parse the AI response, handling markdown code blocks.",
      "parameters": [
        "response_text"
      ],
      "return_type": "dict[str, Any]",
      "decorators": [],
      "is_async": false,
      "source": "def _parse_ai_response(response_text: str) -> dict[str, Any]:\n    \"\"\"Parse the AI response, handling markdown code blocks.\"\"\"\n    text = response_text.strip()\n\n    if text.startswith(\"```\"):\n        lines = text.split(\"\\n\")\n        lines = lines[1:]\n        if lines and lines[-1].strip() == \"```\":\n            lines = lines[:-1]\n        text = \"\\n\".join(lines)\n\n    return json.loads(text)"
    },
    {
      "name": "analyze_with_ai",
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 80,
      "docstring": "Analyze scope using OpenAI GPT-4.\n\nFalls back to rules-based analysis on error.",
      "parameters": [
        "request",
        "api_key",
        "model",
        "timeout"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": true,
      "source": "async def analyze_with_ai(\n    request: AnalysisRequest,\n    api_key: str,\n    model: str = \"gpt-4\",\n    timeout: float = 30.0,\n) -> AnalysisResult:\n    \"\"\"\n    Analyze scope using OpenAI GPT-4.\n\n    Falls back to rules-based analysis on error.\n    \"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    payload = {\n        \"model\": model,\n        \"messages\": [\n            {\"role\": \"system\", \"content\": SYSTEM_PROMPT},\n            {\"role\": \"user\", \"content\": _build_user_prompt(request)},\n        ],\n        \"temperature\": 0.3,\n        \"max_tokens\": 1000,\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=timeout) as client:\n            response = await client.post(\n                OPENAI_API_URL,\n                headers=headers,\n                json=payload,\n            )\n            response.raise_for_status()\n\n        data = response.json()\n        content = data[\"choices\"][0][\"message\"][\"content\"]\n        parsed = _parse_ai_response(content)\n\n        return AnalysisResult(\n            classification=parsed[\"classification\"],\n            confidence=float(parsed[\"confidence\"]),\n            reasoning=parsed[\"reasoning\"],\n            matched_scope_item_index=parsed.get(\"matched_scope_item_index\"),\n            matched_scope_item_id=None,  # AI doesn't have access to IDs\n            suggested_action=parsed[\"suggested_action\"],\n            scope_creep_indicators=parsed.get(\"scope_creep_indicators\", []),\n        )\n\n    except httpx.HTTPStatusError as e:\n        logger.error(f\"OpenAI API error: {e.response.status_code}\")\n        return analyze_with_rules(request)\n\n    except httpx.RequestError as e:\n        logger.error(f\"Request error calling OpenAI: {e}\")\n        return analyze_with_rules(request)\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        logger.error(f\"Failed to parse AI response: {e}\")\n        return analyze_with_rules(request)\n\n    except Exception as e:\n        logger.error(f\"Unexpected error in AI analysis: {e}\")\n        return analyze_with_rules(request)"
    },
    {
      "name": "_client_to_response",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 23,
      "docstring": "Convert a Client model to ClientResponse schema.",
      "parameters": [
        "client",
        "project_count"
      ],
      "return_type": "ClientResponse",
      "decorators": [],
      "is_async": false,
      "source": "def _client_to_response(client: Client, project_count: int = 0) -> ClientResponse:\n    \"\"\"Convert a Client model to ClientResponse schema.\"\"\"\n    return ClientResponse(\n        id=str(client.id),\n        name=client.name,\n        email=client.email,\n        company=client.company,\n        notes=client.notes,\n        created_at=client.created_at,\n        updated_at=client.updated_at,\n        project_count=project_count,\n    )"
    },
    {
      "name": "list_clients",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 38,
      "docstring": "List all clients for the current user with project counts.\n\nSupports pagination with skip and limit parameters.",
      "parameters": [
        "db",
        "current_user",
        "skip",
        "limit"
      ],
      "return_type": "ClientList",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def list_clients(\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n    skip: int = Query(default=0, ge=0),\n    limit: int = Query(default=100, ge=1, le=100),\n) -> ClientList:\n    \"\"\"\n    List all clients for the current user with project counts.\n    \n    Supports pagination with skip and limit parameters.\n    \"\"\"\n    # Get clients with project counts using a subquery\n    project_count_subquery = (\n        select(Project.client_id, func.count(Project.id).label(\"project_count\"))\n        .where(Project.user_id == current_user.id)\n        .group_by(Project.client_id)\n        .subquery()\n    )\n    \n    # Query clients with left join to get project counts\n    query = (\n        select(Client, func.coalesce(project_count_subquery.c.project_count, 0).label(\"project_count\"))\n        .outerjoin(project_count_subquery, Client.id == project_count_subquery.c.client_id)\n        .where(Client.user_id == current_user.id)\n        .offset(skip)\n        .limit(limit)\n        .order_by(Client.created_at.desc())\n    )\n    \n    result = await db.execute(query)\n    rows = result.all()\n    \n    # Get total count\n    count_query = select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    clients = [\n        _client_to_response(row.Client, row.project_count)\n        for row in rows\n    ]\n    \n    return ClientList(clients=clients, total=total)"
    },
    {
      "name": "create_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 84,
      "docstring": "Create a new client for the current user.",
      "parameters": [
        "client_in",
        "db",
        "current_user"
      ],
      "return_type": "ClientResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_client(\n    client_in: ClientCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"Create a new client for the current user.\"\"\"\n    client = Client(\n        user_id=current_user.id,\n        name=client_in.name,\n        email=client_in.email,\n        company=client_in.company,\n        notes=client_in.notes,\n    )\n    db.add(client)\n    await db.commit()\n    await db.refresh(client)\n    \n    return _client_to_response(client, project_count=0)"
    },
    {
      "name": "get_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 105,
      "docstring": "Get a single client by ID.\n\nReturns 404 if client doesn't exist or belongs to another user.",
      "parameters": [
        "client_id",
        "db",
        "current_user"
      ],
      "return_type": "ClientResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_client(\n    client_id: str,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"\n    Get a single client by ID.\n    \n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Get client with project count\n    project_count_subquery = (\n        select(func.count(Project.id))\n        .where(Project.client_id == client_uuid)\n        .where(Project.user_id == current_user.id)\n        .scalar_subquery()\n    )\n    \n    query = (\n        select(Client, project_count_subquery.label(\"project_count\"))\n        .where(Client.id == client_uuid)\n        .where(Client.user_id == current_user.id)\n    )\n    \n    result = await db.execute(query)\n    row = result.first()\n    \n    if not row:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    return _client_to_response(row.Client, row.project_count or 0)"
    },
    {
      "name": "update_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 150,
      "docstring": "Update a client by ID.\n\nOnly updates fields that are explicitly provided.\nReturns 404 if client doesn't exist or belongs to another user.",
      "parameters": [
        "client_id",
        "client_in",
        "db",
        "current_user"
      ],
      "return_type": "ClientResponse",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_client(\n    client_id: str,\n    client_in: ClientUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"\n    Update a client by ID.\n    \n    Only updates fields that are explicitly provided.\n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Find the client\n    query = select(Client).where(\n        Client.id == client_uuid,\n        Client.user_id == current_user.id,\n    )\n    result = await db.execute(query)\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Update only provided fields\n    update_data = client_in.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(client, field, value)\n    \n    await db.commit()\n    await db.refresh(client)\n    \n    # Get project count\n    project_count_query = (\n        select(func.count(Project.id))\n        .where(Project.client_id == client_uuid)\n        .where(Project.user_id == current_user.id)\n    )\n    project_count_result = await db.execute(project_count_query)\n    project_count = project_count_result.scalar() or 0\n    \n    return _client_to_response(client, project_count)"
    },
    {
      "name": "delete_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 205,
      "docstring": "Delete a client by ID.\n\nReturns 404 if client doesn't exist or belongs to another user.",
      "parameters": [
        "client_id",
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [
        "router.delete"
      ],
      "is_async": true,
      "source": "async def delete_client(\n    client_id: str,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> None:\n    \"\"\"\n    Delete a client by ID.\n    \n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    query = select(Client).where(\n        Client.id == client_uuid,\n        Client.user_id == current_user.id,\n    )\n    result = await db.execute(query)\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    await db.delete(client)\n    await db.commit()"
    },
    {
      "name": "test_create_client_success",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 13,
      "docstring": "Test creating a client with all fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_success(self, client, auth_headers):\n        \"\"\"Test creating a client with all fields.\"\"\"\n        client_data = {\n            \"name\": \"New Client\",\n            \"email\": \"newclient@example.com\",\n            \"company\": \"New Company Inc.\",\n            \"notes\": \"Important client notes\",\n        }\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"name\"] == client_data[\"name\"]\n        assert data[\"email\"] == client_data[\"email\"]\n        assert data[\"company\"] == client_data[\"company\"]\n        assert data[\"notes\"] == client_data[\"notes\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n        assert data[\"project_count\"] == 0"
    },
    {
      "name": "test_create_client_minimal",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 40,
      "docstring": "Test creating a client with only required fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_minimal(self, client, auth_headers):\n        \"\"\"Test creating a client with only required fields.\"\"\"\n        client_data = {\"name\": \"Minimal Client\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"name\"] == client_data[\"name\"]\n        assert data[\"email\"] is None\n        assert data[\"company\"] is None\n        assert data[\"notes\"] is None\n        assert data[\"project_count\"] == 0"
    },
    {
      "name": "test_create_client_invalid_email",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 59,
      "docstring": "Test creating a client with invalid email format.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_invalid_email(self, client, auth_headers):\n        \"\"\"Test creating a client with invalid email format.\"\"\"\n        client_data = {\n            \"name\": \"Invalid Email Client\",\n            \"email\": \"not-an-email\",\n        }\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_create_client_empty_name",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 75,
      "docstring": "Test creating a client with empty name fails.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_empty_name(self, client, auth_headers):\n        \"\"\"Test creating a client with empty name fails.\"\"\"\n        client_data = {\"name\": \"\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_create_client_name_too_long",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 88,
      "docstring": "Test creating a client with name exceeding max length.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_name_too_long(self, client, auth_headers):\n        \"\"\"Test creating a client with name exceeding max length.\"\"\"\n        client_data = {\"name\": \"a\" * 256}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_create_client_unauthorized",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 101,
      "docstring": "Test creating a client without authentication.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_client_unauthorized(self, client):\n        \"\"\"Test creating a client without authentication.\"\"\"\n        client_data = {\"name\": \"Unauthorized Client\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n        )\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "test_list_clients_empty",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 117,
      "docstring": "Test listing clients when user has none.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_clients_empty(self, client, auth_headers):\n        \"\"\"Test listing clients when user has none.\"\"\"\n        response = await client.get(\n            \"/api/v1/clients\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"clients\"] == []\n        assert data[\"total\"] == 0"
    },
    {
      "name": "test_list_clients_with_data",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 130,
      "docstring": "Test listing clients when user has multiple clients.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_clients_with_data(self, client, auth_headers):\n        \"\"\"Test listing clients when user has multiple clients.\"\"\"\n        # Create 3 clients first\n        for i in range(3):\n            await client.post(\n                \"/api/v1/clients\",\n                json={\"name\": f\"Client {i + 1}\"},\n                headers=auth_headers,\n            )\n\n        response = await client.get(\n            \"/api/v1/clients\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 3\n        assert data[\"total\"] == 3\n        for c in data[\"clients\"]:\n            assert c[\"project_count\"] == 0"
    },
    {
      "name": "test_list_clients_pagination",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 153,
      "docstring": "Test listing clients with pagination parameters.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_clients_pagination(self, client, auth_headers):\n        \"\"\"Test listing clients with pagination parameters.\"\"\"\n        # Create 5 clients\n        for i in range(5):\n            await client.post(\n                \"/api/v1/clients\",\n                json={\"name\": f\"Client {i + 1}\"},\n                headers=auth_headers,\n            )\n\n        # Get first page\n        response = await client.get(\n            \"/api/v1/clients\",\n            params={\"skip\": 0, \"limit\": 2},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 2\n        assert data[\"total\"] == 5\n\n        # Get second page\n        response = await client.get(\n            \"/api/v1/clients\",\n            params={\"skip\": 2, \"limit\": 2},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 2\n        assert data[\"total\"] == 5"
    },
    {
      "name": "test_list_clients_unauthorized",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 188,
      "docstring": "Test listing clients without authentication.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_clients_unauthorized(self, client):\n        \"\"\"Test listing clients without authentication.\"\"\"\n        response = await client.get(\"/api/v1/clients\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "test_get_client_success",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 199,
      "docstring": "Test getting an existing client.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_client_success(self, client, auth_headers):\n        \"\"\"Test getting an existing client.\"\"\"\n        # Create a client first\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\n                \"name\": \"Test Client\",\n                \"email\": \"test@client.com\",\n                \"company\": \"Test Co\",\n                \"notes\": \"Some notes\",\n            },\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Get the client\n        response = await client.get(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == client_id\n        assert data[\"name\"] == \"Test Client\"\n        assert data[\"email\"] == \"test@client.com\"\n        assert data[\"company\"] == \"Test Co\"\n        assert data[\"notes\"] == \"Some notes\"\n        assert \"created_at\" in data\n        assert \"updated_at\" in data"
    },
    {
      "name": "test_get_client_not_found",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 231,
      "docstring": "Test getting a non-existent client.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_client_not_found(self, client, auth_headers):\n        \"\"\"Test getting a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.get(\n            f\"/api/v1/clients/{fake_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "test_get_client_unauthorized",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 244,
      "docstring": "Test getting a client without authentication.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_client_unauthorized(self, client):\n        \"\"\"Test getting a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.get(f\"/api/v1/clients/{fake_id}\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "test_update_client_partial",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 257,
      "docstring": "Test updating only the name field.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_client_partial(self, client, auth_headers):\n        \"\"\"Test updating only the name field.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\n                \"name\": \"Original Name\",\n                \"email\": \"original@example.com\",\n                \"company\": \"Original Company\",\n            },\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Update only the name\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json={\"name\": \"Updated Name\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n        # Other fields should remain unchanged\n        assert data[\"email\"] == \"original@example.com\"\n        assert data[\"company\"] == \"Original Company\""
    },
    {
      "name": "test_update_client_all_fields",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 286,
      "docstring": "Test updating all fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_client_all_fields(self, client, auth_headers):\n        \"\"\"Test updating all fields.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"Original\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Update all fields\n        update_data = {\n            \"name\": \"Updated Name\",\n            \"email\": \"updated@example.com\",\n            \"company\": \"Updated Company\",\n            \"notes\": \"Updated notes\",\n        }\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json=update_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"name\"] == update_data[\"name\"]\n        assert data[\"email\"] == update_data[\"email\"]\n        assert data[\"company\"] == update_data[\"company\"]\n        assert data[\"notes\"] == update_data[\"notes\"]"
    },
    {
      "name": "test_update_client_not_found",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 317,
      "docstring": "Test updating a non-existent client.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_client_not_found(self, client, auth_headers):\n        \"\"\"Test updating a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.patch(\n            f\"/api/v1/clients/{fake_id}\",\n            json={\"name\": \"Updated\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "test_update_client_invalid_email",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 331,
      "docstring": "Test updating client with invalid email.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_client_invalid_email(self, client, auth_headers):\n        \"\"\"Test updating client with invalid email.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"Test Client\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Try to update with invalid email\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json={\"email\": \"not-valid-email\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_update_client_unauthorized",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 351,
      "docstring": "Test updating a client without authentication.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_client_unauthorized(self, client):\n        \"\"\"Test updating a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.patch(\n            f\"/api/v1/clients/{fake_id}\",\n            json={\"name\": \"Updated\"},\n        )\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "test_delete_client_success",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 367,
      "docstring": "Test deleting an existing client.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_client_success(self, client, auth_headers):\n        \"\"\"Test deleting an existing client.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"To Be Deleted\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Delete the client\n        response = await client.delete(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # Verify client is gone\n        get_response = await client.get(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_delete_client_not_found",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 393,
      "docstring": "Test deleting a non-existent client.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_client_not_found(self, client, auth_headers):\n        \"\"\"Test deleting a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.delete(\n            f\"/api/v1/clients/{fake_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "test_delete_client_unauthorized",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 406,
      "docstring": "Test deleting a client without authentication.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_client_unauthorized(self, client):\n        \"\"\"Test deleting a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.delete(f\"/api/v1/clients/{fake_id}\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "get_db",
      "file_path": "app/db/session.py",
      "line_number": 41,
      "docstring": "Dependency that provides a database session.",
      "parameters": [],
      "return_type": "AsyncGenerator[AsyncSession, None]",
      "decorators": [],
      "is_async": true,
      "source": "async def get_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Dependency that provides a database session.\"\"\"\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()"
    },
    {
      "name": "init_db",
      "file_path": "app/db/session.py",
      "line_number": 54,
      "docstring": "Initialize database tables.",
      "parameters": [],
      "return_type": "None",
      "decorators": [],
      "is_async": true,
      "source": "async def init_db() -> None:\n    \"\"\"Initialize database tables.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)"
    },
    {
      "name": "close_db",
      "file_path": "app/db/session.py",
      "line_number": 60,
      "docstring": "Close database connections.",
      "parameters": [],
      "return_type": "None",
      "decorators": [],
      "is_async": true,
      "source": "async def close_db() -> None:\n    \"\"\"Close database connections.\"\"\"\n    await engine.dispose()"
    },
    {
      "name": "is_pro",
      "file_path": "app/models/subscription.py",
      "line_number": 92,
      "docstring": "Check if user has active Pro subscription.",
      "parameters": [
        "self"
      ],
      "return_type": "bool",
      "decorators": [
        "property"
      ],
      "is_async": false,
      "source": "    def is_pro(self) -> bool:\n        \"\"\"Check if user has active Pro subscription.\"\"\"\n        return (\n            self.plan == PlanType.PRO \n            and self.status in [SubscriptionStatus.ACTIVE, SubscriptionStatus.TRIALING]\n        )"
    },
    {
      "name": "is_active",
      "file_path": "app/models/subscription.py",
      "line_number": 100,
      "docstring": "Check if subscription is active (any plan).",
      "parameters": [
        "self"
      ],
      "return_type": "bool",
      "decorators": [
        "property"
      ],
      "is_async": false,
      "source": "    def is_active(self) -> bool:\n        \"\"\"Check if subscription is active (any plan).\"\"\"\n        return self.status in [SubscriptionStatus.ACTIVE, SubscriptionStatus.TRIALING]"
    },
    {
      "name": "max_projects",
      "file_path": "app/models/subscription.py",
      "line_number": 106,
      "docstring": "Maximum projects allowed for this plan.",
      "parameters": [
        "self"
      ],
      "return_type": "int",
      "decorators": [
        "property"
      ],
      "is_async": false,
      "source": "    def max_projects(self) -> int:\n        \"\"\"Maximum projects allowed for this plan.\"\"\"\n        return 999 if self.is_pro else 3"
    },
    {
      "name": "max_clients",
      "file_path": "app/models/subscription.py",
      "line_number": 111,
      "docstring": "Maximum clients allowed for this plan.",
      "parameters": [
        "self"
      ],
      "return_type": "int",
      "decorators": [
        "property"
      ],
      "is_async": false,
      "source": "    def max_clients(self) -> int:\n        \"\"\"Maximum clients allowed for this plan.\"\"\"\n        return 999 if self.is_pro else 2"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/subscription.py",
      "line_number": 115,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self):\n        return f\"<Subscription {self.user_id} - {self.plan.value}>\""
    },
    {
      "name": "hash_password",
      "file_path": "app/core/security.py",
      "line_number": 21,
      "docstring": "Hash a password using bcrypt. Truncates if longer than 72 bytes.",
      "parameters": [
        "password"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "def hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt. Truncates if longer than 72 bytes.\"\"\"\n    # Truncate to 72 bytes, then decode back to string\n    password_truncated = password.encode('utf-8')[:72].decode('utf-8', errors='ignore')\n    return pwd_context.hash(password_truncated)"
    },
    {
      "name": "verify_password",
      "file_path": "app/core/security.py",
      "line_number": 28,
      "docstring": "Verify a password against a hash. Truncates if longer than 72 bytes.",
      "parameters": [
        "plain_password",
        "hashed_password"
      ],
      "return_type": "bool",
      "decorators": [],
      "is_async": false,
      "source": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against a hash. Truncates if longer than 72 bytes.\"\"\"\n    plain_password_truncated = plain_password.encode('utf-8')[:72].decode('utf-8', errors='ignore')\n    return pwd_context.verify(plain_password_truncated, hashed_password)"
    },
    {
      "name": "create_access_token",
      "file_path": "app/core/security.py",
      "line_number": 34,
      "docstring": "Create a JWT access token.",
      "parameters": [
        "data",
        "expires_delta"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "def create_access_token(\n    data: dict[str, Any],\n    expires_delta: timedelta | None = None,\n) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    \n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(days=settings.access_token_expire_days)\n    \n    to_encode.update({\"exp\": expire})\n    \n    return jwt.encode(\n        to_encode,\n        settings.secret_key,\n        algorithm=settings.algorithm,\n    )"
    },
    {
      "name": "decode_access_token",
      "file_path": "app/core/security.py",
      "line_number": 55,
      "docstring": "Decode and validate a JWT access token. Returns None if invalid.",
      "parameters": [
        "token"
      ],
      "return_type": "dict[str, Any] | None",
      "decorators": [],
      "is_async": false,
      "source": "def decode_access_token(token: str) -> dict[str, Any] | None:\n    \"\"\"Decode and validate a JWT access token. Returns None if invalid.\"\"\"\n    try:\n        payload = jwt.decode(\n            token,\n            settings.secret_key,\n            algorithms=[settings.algorithm],\n        )\n        return payload\n    except JWTError:\n        return None"
    },
    {
      "name": "get_profile",
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 13,
      "docstring": "Get the current user's full profile.\n\nReturns all profile fields including created_at timestamp.\nRequires authentication.",
      "parameters": [
        "current_user"
      ],
      "return_type": "UserProfile",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_profile(\n    current_user: CurrentUser,\n) -> UserProfile:\n    \"\"\"\n    Get the current user's full profile.\n\n    Returns all profile fields including created_at timestamp.\n    Requires authentication.\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id),\n        email=current_user.email,\n        full_name=current_user.full_name,\n        business_name=current_user.business_name,\n        is_active=current_user.is_active,\n        created_at=current_user.created_at,\n    )"
    },
    {
      "name": "update_profile",
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 33,
      "docstring": "Update the current user's profile.\n\nOnly updates fields that are provided (not None).\nRequires authentication.",
      "parameters": [
        "user_update",
        "current_user",
        "db"
      ],
      "return_type": "UserProfile",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_profile(\n    user_update: UserUpdate,\n    current_user: CurrentUser,\n    db: AsyncSession = Depends(get_db),\n) -> UserProfile:\n    \"\"\"\n    Update the current user's profile.\n\n    Only updates fields that are provided (not None).\n    Requires authentication.\n    \"\"\"\n    update_data = user_update.model_dump(exclude_unset=True)\n\n    if not update_data:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"No fields to update\",\n        )\n\n    for field, value in update_data.items():\n        setattr(current_user, field, value)\n\n    db.add(current_user)\n    await db.commit()\n    await db.refresh(current_user)\n\n    return UserProfile(\n        id=str(current_user.id),\n        email=current_user.email,\n        full_name=current_user.full_name,\n        business_name=current_user.business_name,\n        is_active=current_user.is_active,\n        created_at=current_user.created_at,\n    )"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/proposal.py",
      "line_number": 79,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<Proposal {self.title}>\""
    },
    {
      "name": "__repr__",
      "file_path": "app/models/client_request.py",
      "line_number": 89,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<ClientRequest {self.title}>\""
    },
    {
      "name": "get_project_or_404",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 28,
      "docstring": "Get project by ID or raise 404.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "Project",
      "decorators": [],
      "is_async": true,
      "source": "async def get_project_or_404(\n    project_id: uuid.UUID,\n    db: AsyncSession,\n    current_user: User,\n) -> Project:\n    \"\"\"Get project by ID or raise 404.\"\"\"\n    result = await db.execute(\n        select(Project).where(\n            Project.id == project_id,\n            Project.user_id == current_user.id,\n        )\n    )\n    project = result.scalar_one_or_none()\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    return project"
    },
    {
      "name": "get_proposal_or_404",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 49,
      "docstring": "Get proposal by ID or raise 404.",
      "parameters": [
        "proposal_id",
        "project_id",
        "db"
      ],
      "return_type": "Proposal",
      "decorators": [],
      "is_async": true,
      "source": "async def get_proposal_or_404(\n    proposal_id: uuid.UUID,\n    project_id: uuid.UUID,\n    db: AsyncSession,\n) -> Proposal:\n    \"\"\"Get proposal by ID or raise 404.\"\"\"\n    result = await db.execute(\n        select(Proposal).where(\n            Proposal.id == proposal_id,\n            Proposal.project_id == project_id,\n        )\n    )\n    proposal = result.scalar_one_or_none()\n    if not proposal:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Proposal not found\",\n        )\n    return proposal"
    },
    {
      "name": "proposal_to_response",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 70,
      "docstring": "Convert Proposal model to ProposalResponse schema.",
      "parameters": [
        "proposal",
        "source_request_title"
      ],
      "return_type": "ProposalResponse",
      "decorators": [],
      "is_async": false,
      "source": "def proposal_to_response(proposal: Proposal, source_request_title: Optional[str] = None) -> ProposalResponse:\n    \"\"\"Convert Proposal model to ProposalResponse schema.\"\"\"\n    return ProposalResponse(\n        id=proposal.id,\n        project_id=proposal.project_id,\n        source_request_id=proposal.source_request_id,\n        title=proposal.title,\n        description=proposal.description,\n        status=proposal.status,\n        amount=proposal.amount,\n        estimated_hours=proposal.estimated_hours,\n        sent_at=proposal.sent_at,\n        responded_at=proposal.responded_at,\n        created_at=proposal.created_at,\n        updated_at=proposal.updated_at,\n        source_request_title=source_request_title,\n    )"
    },
    {
      "name": "list_proposals",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 90,
      "docstring": "List all proposals for a project.",
      "parameters": [
        "project_id",
        "status_filter",
        "skip",
        "limit",
        "db",
        "current_user"
      ],
      "return_type": "List[ProposalResponse]",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def list_proposals(\n    project_id: uuid.UUID,\n    status_filter: Optional[ProposalStatus] = Query(default=None, alias=\"status\"),\n    skip: int = Query(default=0, ge=0),\n    limit: int = Query(default=50, ge=1, le=100),\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> List[ProposalResponse]:\n    \"\"\"List all proposals for a project.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    query = select(Proposal).where(Proposal.project_id == project_id)\n    \n    if status_filter:\n        query = query.where(Proposal.status == status_filter)\n    \n    query = query.order_by(Proposal.created_at.desc()).offset(skip).limit(limit)\n    result = await db.execute(query)\n    proposals = result.scalars().all()\n    \n    # Fetch source request titles for linked proposals\n    responses = []\n    for proposal in proposals:\n        source_title = None\n        if proposal.source_request_id:\n            req_result = await db.execute(\n                select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n            )\n            source_title = req_result.scalar_one_or_none()\n        responses.append(proposal_to_response(proposal, source_title))\n    \n    return responses"
    },
    {
      "name": "create_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 125,
      "docstring": "Create a new proposal manually.",
      "parameters": [
        "project_id",
        "proposal_in",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_proposal(\n    project_id: uuid.UUID,\n    proposal_in: ProposalCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Create a new proposal manually.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    proposal = Proposal(\n        project_id=project_id,\n        source_request_id=None,\n        title=proposal_in.title,\n        description=proposal_in.description,\n        status=ProposalStatus.DRAFT,\n        amount=proposal_in.amount,\n        estimated_hours=proposal_in.estimated_hours,\n    )\n    \n    db.add(proposal)\n    await db.commit()\n    await db.refresh(proposal)\n    \n    return proposal_to_response(proposal)"
    },
    {
      "name": "create_proposal_from_request",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 156,
      "docstring": "Create a proposal from an existing client request.",
      "parameters": [
        "project_id",
        "request_id",
        "proposal_in",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_proposal_from_request(\n    project_id: uuid.UUID,\n    request_id: uuid.UUID,\n    proposal_in: ProposalFromRequest,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Create a proposal from an existing client request.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Verify request_id matches the one in body\n    if proposal_in.source_request_id != request_id:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Request ID in URL does not match source_request_id in body\",\n        )\n    \n    # Fetch the source request\n    result = await db.execute(\n        select(ClientRequest).where(\n            ClientRequest.id == request_id,\n            ClientRequest.project_id == project_id,\n        )\n    )\n    source_request = result.scalar_one_or_none()\n    if not source_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n    \n    # Auto-generate title and description\n    title = f\"Proposal: {source_request.title}\"\n    description = f\"This proposal addresses the following request:\\n\\n{source_request.content}\"\n    \n    # Add analysis info if available\n    if source_request.analysis_reasoning:\n        description += f\"\\n\\nAnalysis:\\n{source_request.analysis_reasoning}\"\n    \n    proposal = Proposal(\n        project_id=project_id,\n        source_request_id=request_id,\n        title=title,\n        description=description,\n        status=ProposalStatus.DRAFT,\n        amount=proposal_in.amount,\n        estimated_hours=proposal_in.estimated_hours,\n    )\n    \n    db.add(proposal)\n    \n    # Update the client request status to PROPOSAL_SENT\n    source_request.status = RequestStatus.PROPOSAL_SENT\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    return proposal_to_response(proposal, source_request.title)"
    },
    {
      "name": "get_proposal_stats",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 217,
      "docstring": "Get proposal statistics for a project.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "ProposalStats",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_proposal_stats(\n    project_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalStats:\n    \"\"\"Get proposal statistics for a project.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get counts by status\n    result = await db.execute(\n        select(\n            Proposal.status,\n            func.count(Proposal.id).label(\"count\"),\n        )\n        .where(Proposal.project_id == project_id)\n        .group_by(Proposal.status)\n    )\n    status_counts = {row.status: row.count for row in result}\n    \n    # Get total accepted amount\n    result = await db.execute(\n        select(func.coalesce(func.sum(Proposal.amount), Decimal(\"0\")))\n        .where(\n            Proposal.project_id == project_id,\n            Proposal.status == ProposalStatus.ACCEPTED,\n        )\n    )\n    total_accepted = result.scalar_one()\n    \n    return ProposalStats(\n        total_proposals=sum(status_counts.values()),\n        draft_count=status_counts.get(ProposalStatus.DRAFT, 0),\n        sent_count=status_counts.get(ProposalStatus.SENT, 0),\n        accepted_count=status_counts.get(ProposalStatus.ACCEPTED, 0),\n        declined_count=status_counts.get(ProposalStatus.DECLINED, 0),\n        expired_count=status_counts.get(ProposalStatus.EXPIRED, 0),\n        total_amount_accepted=total_accepted,\n    )"
    },
    {
      "name": "get_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 258,
      "docstring": "Get a specific proposal.",
      "parameters": [
        "project_id",
        "proposal_id",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Get a specific proposal.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "name": "update_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 279,
      "docstring": "Update a proposal.",
      "parameters": [
        "project_id",
        "proposal_id",
        "proposal_in",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    proposal_in: ProposalUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Update a proposal.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    update_data = proposal_in.model_dump(exclude_unset=True)\n    \n    # Track if status is being changed to ACCEPTED or DECLINED\n    new_status = update_data.get(\"status\")\n    if new_status in (ProposalStatus.ACCEPTED, ProposalStatus.DECLINED):\n        if proposal.responded_at is None:\n            proposal.responded_at = datetime.now(timezone.utc)\n    \n    for field, value in update_data.items():\n        setattr(proposal, field, value)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "name": "send_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 315,
      "docstring": "Mark a proposal as sent.",
      "parameters": [
        "project_id",
        "proposal_id",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def send_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as sent.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if already sent\n    if proposal.status != ProposalStatus.DRAFT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Proposal is already {proposal.status.value}, cannot send\",\n        )\n    \n    proposal.status = ProposalStatus.SENT\n    proposal.sent_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "name": "accept_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 349,
      "docstring": "Mark a proposal as accepted by the client.",
      "parameters": [
        "project_id",
        "proposal_id",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def accept_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as accepted by the client.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if proposal has been sent\n    if proposal.status != ProposalStatus.SENT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Cannot accept a proposal with status '{proposal.status.value}'. Proposal must be sent first.\",\n        )\n    \n    proposal.status = ProposalStatus.ACCEPTED\n    proposal.responded_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "name": "decline_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 383,
      "docstring": "Mark a proposal as declined by the client.",
      "parameters": [
        "project_id",
        "proposal_id",
        "db",
        "current_user"
      ],
      "return_type": "ProposalResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def decline_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as declined by the client.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if proposal has been sent\n    if proposal.status != ProposalStatus.SENT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Cannot decline a proposal with status '{proposal.status.value}'. Proposal must be sent first.\",\n        )\n    \n    proposal.status = ProposalStatus.DECLINED\n    proposal.responded_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "name": "delete_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 417,
      "docstring": "Delete a proposal. Only draft proposals can be deleted.",
      "parameters": [
        "project_id",
        "proposal_id",
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [
        "router.delete"
      ],
      "is_async": true,
      "source": "async def delete_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> None:\n    \"\"\"Delete a proposal. Only draft proposals can be deleted.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Only allow deletion of draft proposals\n    if proposal.status != ProposalStatus.DRAFT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Cannot delete a proposal that has been sent\",\n        )\n    \n    await db.delete(proposal)\n    await db.commit()"
    },
    {
      "name": "active_project",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 32,
      "docstring": "Create an active project for dashboard tests.",
      "parameters": [
        "db_session",
        "test_user",
        "test_client"
      ],
      "return_type": "Project",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def active_project(db_session: AsyncSession, test_user: User, test_client: Client) -> Project:\n    \"\"\"Create an active project for dashboard tests.\"\"\"\n    project = Project(\n        user_id=test_user.id,\n        client_id=test_client.id,\n        name=\"Active Dashboard Project\",\n        description=\"A project for dashboard testing\",\n        status=ProjectStatus.ACTIVE,\n    )\n    db_session.add(project)\n    await db_session.commit()\n    await db_session.refresh(project)\n    return project"
    },
    {
      "name": "completed_project",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 48,
      "docstring": "Create a completed project for dashboard tests.",
      "parameters": [
        "db_session",
        "test_user",
        "test_client"
      ],
      "return_type": "Project",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def completed_project(db_session: AsyncSession, test_user: User, test_client: Client) -> Project:\n    \"\"\"Create a completed project for dashboard tests.\"\"\"\n    project = Project(\n        user_id=test_user.id,\n        client_id=test_client.id,\n        name=\"Completed Dashboard Project\",\n        description=\"A completed project\",\n        status=ProjectStatus.COMPLETED,\n    )\n    db_session.add(project)\n    await db_session.commit()\n    await db_session.refresh(project)\n    return project"
    },
    {
      "name": "second_client",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 64,
      "docstring": "Create a second client for dashboard tests.",
      "parameters": [
        "db_session",
        "test_user"
      ],
      "return_type": "Client",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def second_client(db_session: AsyncSession, test_user: User) -> Client:\n    \"\"\"Create a second client for dashboard tests.\"\"\"\n    client_obj = Client(\n        user_id=test_user.id,\n        name=\"Second Test Client\",\n        email=\"second.client@example.com\",\n    )\n    db_session.add(client_obj)\n    await db_session.commit()\n    await db_session.refresh(client_obj)\n    return client_obj"
    },
    {
      "name": "create_client_request",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 77,
      "docstring": "Helper to create a client request with specific attributes.",
      "parameters": [
        "db_session",
        "project"
      ],
      "return_type": "ClientRequest",
      "decorators": [],
      "is_async": true,
      "source": "async def create_client_request(\n    db_session: AsyncSession,\n    project: Project,\n    *,\n    status: RequestStatus = RequestStatus.NEW,\n    classification: ScopeClassification = ScopeClassification.PENDING,\n    created_at: datetime | None = None,\n) -> ClientRequest:\n    \"\"\"Helper to create a client request with specific attributes.\"\"\"\n    request = ClientRequest(\n        project_id=project.id,\n        title=f\"Test Request {uuid4().hex[:8]}\",\n        content=\"Test request content\",\n        classification=classification,\n        status=status,\n    )\n    db_session.add(request)\n    await db_session.commit()\n    await db_session.refresh(request)\n    \n    # Update created_at if specified (after commit to override default)\n    if created_at:\n        request.created_at = created_at\n        await db_session.commit()\n        await db_session.refresh(request)\n    \n    return request"
    },
    {
      "name": "create_proposal",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 106,
      "docstring": "Helper to create a proposal with specific attributes.",
      "parameters": [
        "db_session",
        "project",
        "source_request"
      ],
      "return_type": "Proposal",
      "decorators": [],
      "is_async": true,
      "source": "async def create_proposal(\n    db_session: AsyncSession,\n    project: Project,\n    source_request: ClientRequest | None = None,\n    *,\n    status: ProposalStatus = ProposalStatus.DRAFT,\n    amount: Decimal = Decimal(\"500.00\"),\n    created_at: datetime | None = None,\n) -> Proposal:\n    \"\"\"Helper to create a proposal with specific attributes.\"\"\"\n    proposal = Proposal(\n        project_id=project.id,\n        source_request_id=source_request.id if source_request else None,\n        title=f\"Test Proposal {uuid4().hex[:8]}\",\n        description=\"Test proposal description\",\n        amount=amount,\n        status=status,\n    )\n    db_session.add(proposal)\n    await db_session.commit()\n    await db_session.refresh(proposal)\n    \n    # Update created_at if specified\n    if created_at:\n        proposal.created_at = created_at\n        await db_session.commit()\n        await db_session.refresh(proposal)\n    \n    return proposal"
    },
    {
      "name": "test_summary_empty",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 146,
      "docstring": "New user with no data should have all counts at 0.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_summary_empty(self, client: AsyncClient, auth_headers: dict[str, str]):\n        \"\"\"New user with no data should have all counts at 0.\"\"\"\n        response = await client.get(\"/api/v1/dashboard/summary\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"total_projects\"] == 0\n        assert data[\"active_projects\"] == 0\n        assert data[\"total_clients\"] == 0\n        assert data[\"total_requests\"] == 0\n        assert data[\"out_of_scope_requests\"] == 0\n        assert data[\"pending_requests\"] == 0\n        assert data[\"total_proposals\"] == 0\n        assert data[\"pending_proposals\"] == 0\n        assert data[\"accepted_proposals\"] == 0\n        assert Decimal(data[\"total_revenue_protected\"]) == Decimal(\"0.00\")"
    },
    {
      "name": "test_summary_with_data",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 169,
      "docstring": "User with projects, requests, proposals should have accurate counts.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project",
        "completed_project",
        "second_client"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_summary_with_data(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n        completed_project: Project,\n        second_client: Client,\n    ):\n        \"\"\"User with projects, requests, proposals should have accurate counts.\"\"\"\n        # Create requests\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n        )\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.OUT_OF_SCOPE,\n        )\n        await create_client_request(\n            db_session, completed_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        \n        # Create proposals\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"300.00\"),\n        )\n        await create_proposal(\n            db_session, completed_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"750.00\"),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/summary\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"total_projects\"] == 2\n        assert data[\"active_projects\"] == 1\n        assert data[\"total_clients\"] == 2  # test_client + second_client\n        assert data[\"total_requests\"] == 3\n        assert data[\"out_of_scope_requests\"] == 1\n        assert data[\"pending_requests\"] == 1\n        assert data[\"total_proposals\"] == 3\n        assert data[\"pending_proposals\"] == 1  # SENT only\n        assert data[\"accepted_proposals\"] == 2\n        assert Decimal(data[\"total_revenue_protected\"]) == Decimal(\"1250.00\")"
    },
    {
      "name": "test_alerts_scope_creep",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 234,
      "docstring": "Project with 4 OUT_OF_SCOPE requests in last week should trigger alert.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_alerts_scope_creep(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with 4 OUT_OF_SCOPE requests in last week should trigger alert.\"\"\"\n        # Create 4 out-of-scope requests in the last 7 days\n        for _ in range(4):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n                created_at=datetime.now(timezone.utc) - timedelta(days=2),\n            )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        scope_creep_alerts = [a for a in alerts if a[\"type\"] == \"scope_creep\"]\n        assert len(scope_creep_alerts) >= 1\n        assert scope_creep_alerts[0][\"severity\"] == \"high\"\n        assert \"out-of-scope\" in scope_creep_alerts[0][\"message\"].lower()"
    },
    {
      "name": "test_alerts_pending_request",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 262,
      "docstring": "Request with status=NEW, created 3 days ago should trigger alert.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_alerts_pending_request(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Request with status=NEW, created 3 days ago should trigger alert.\"\"\"\n        # Create a request that's 3 days old and still NEW\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n            created_at=datetime.now(timezone.utc) - timedelta(days=3),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        pending_alerts = [a for a in alerts if a[\"type\"] == \"pending_request\"]\n        assert len(pending_alerts) >= 1\n        assert pending_alerts[0][\"severity\"] == \"medium\"\n        assert \"pending\" in pending_alerts[0][\"message\"].lower()"
    },
    {
      "name": "test_alerts_proposal_expiring",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 289,
      "docstring": "SENT proposal older than 14 days should trigger alert.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_alerts_proposal_expiring(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"SENT proposal older than 14 days should trigger alert.\"\"\"\n        # Create a proposal that's 15 days old and still SENT\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(days=15),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        expiring_alerts = [a for a in alerts if a[\"type\"] == \"proposal_expiring\"]\n        assert len(expiring_alerts) >= 1\n        assert expiring_alerts[0][\"severity\"] == \"medium\""
    },
    {
      "name": "test_no_alerts_clean_project",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 315,
      "docstring": "Well-maintained project should have no alerts.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_no_alerts_clean_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Well-maintained project should have no alerts.\"\"\"\n        # Create recent, analyzed in-scope request\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=1),\n        )\n        \n        # Create recent accepted proposal\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(days=5),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        # Should have no alerts\n        assert len(alerts) == 0"
    },
    {
      "name": "test_recent_activity",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 352,
      "docstring": "Activities should be returned in reverse chronological order.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_recent_activity(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Activities should be returned in reverse chronological order.\"\"\"\n        # Create activities at different times\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=3),\n        )\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=1),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(minutes=30),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/activity\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        activities = response.json()\n        \n        assert len(activities) > 0\n        \n        # Verify reverse chronological order\n        timestamps = [\n            datetime.fromisoformat(a[\"timestamp\"].replace(\"Z\", \"+00:00\"))\n            for a in activities\n        ]\n        assert timestamps == sorted(timestamps, reverse=True)"
    },
    {
      "name": "test_project_health_score_perfect",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 397,
      "docstring": "Project with all IN_SCOPE requests, accepted proposals should have high score.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_project_health_score_perfect(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with all IN_SCOPE requests, accepted proposals should have high score.\"\"\"\n        # Create in-scope analyzed requests\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ADDRESSED,  # Addressed, not unaddressed\n                classification=ScopeClassification.IN_SCOPE,\n            )\n        \n        # Create accepted proposals (adds +5 each)\n        for _ in range(2):\n            await create_proposal(\n                db_session, active_project,\n                status=ProposalStatus.ACCEPTED,\n                amount=Decimal(\"500.00\"),\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        # Score should be high (100 base + 10 from 2 accepted proposals = 100 clamped)\n        assert health[\"health_score\"] >= 90\n        assert health[\"out_of_scope_requests\"] == 0\n        assert health[\"scope_creep_ratio\"] == 0.0"
    },
    {
      "name": "test_project_health_score_poor",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 435,
      "docstring": "Project with many OUT_OF_SCOPE requests, no proposals should have low score.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_project_health_score_poor(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with many OUT_OF_SCOPE requests, no proposals should have low score.\"\"\"\n        # Create out-of-scope requests (unaddressed = -10 each)\n        for _ in range(8):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n            )\n        \n        # Create old pending requests (-5 each)\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.NEW,\n                created_at=datetime.now(timezone.utc) - timedelta(days=2),\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        # Score should be low: 100 - (8 * 10) - (3 * 5) = 100 - 80 - 15 = 5, clamped to 0\n        assert health[\"health_score\"] <= 20\n        assert health[\"out_of_scope_requests\"] == 8"
    },
    {
      "name": "test_revenue_protected_calculation",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 472,
      "docstring": "Multiple accepted proposals should sum correctly.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_revenue_protected_calculation(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Multiple accepted proposals should sum correctly.\"\"\"\n        # Create multiple accepted proposals\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"750.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"1000.00\"),\n        )\n        # This one shouldn't count (not accepted)\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"300.00\"),\n        )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        assert Decimal(health[\"revenue_protected\"]) == Decimal(\"2250.00\")\n        assert health[\"proposals_accepted\"] == 3\n        assert health[\"proposals_sent\"] == 1"
    },
    {
      "name": "test_scope_creep_ratio",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 516,
      "docstring": "10 requests, 3 out of scope should give ratio of 0.3.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_scope_creep_ratio(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"10 requests, 3 out of scope should give ratio of 0.3.\"\"\"\n        # Create 7 in-scope requests\n        for _ in range(7):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.IN_SCOPE,\n            )\n        \n        # Create 3 out-of-scope requests\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        assert health[\"total_requests\"] == 10\n        assert health[\"in_scope_requests\"] == 7\n        assert health[\"out_of_scope_requests\"] == 3\n        assert health[\"scope_creep_ratio\"] == 0.3"
    },
    {
      "name": "test_project_not_found",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 558,
      "docstring": "Requesting health for non-existent project should return 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_project_not_found(\n        self, client: AsyncClient, auth_headers: dict[str, str]\n    ):\n        \"\"\"Requesting health for non-existent project should return 404.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{fake_id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "test_full_dashboard",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 575,
      "docstring": "Full dashboard should return all components.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "db_session",
        "active_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_full_dashboard(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Full dashboard should return all components.\"\"\"\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert \"summary\" in data\n        assert \"alerts\" in data\n        assert \"recent_activity\" in data\n        assert \"project_health\" in data\n        \n        # Verify summary has correct structure\n        assert \"total_projects\" in data[\"summary\"]\n        assert \"total_revenue_protected\" in data[\"summary\"]\n        \n        # Verify project_health is a list\n        assert isinstance(data[\"project_health\"], list)"
    },
    {
      "name": "test_cannot_access_other_user_project_health",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 615,
      "docstring": "User cannot access health of another user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_cannot_access_other_user_project_health(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"User cannot access health of another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{other_user_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "test_health_check",
      "file_path": "tests/unit/test_health.py",
      "line_number": 12,
      "docstring": "Test health check returns healthy status.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_health_check(self, client: AsyncClient):\n        \"\"\"Test health check returns healthy status.\"\"\"\n        response = await client.get(\"/api/v1/health\")\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"healthy\"\n        assert \"app\" in data\n        assert \"version\" in data"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/client.py",
      "line_number": 61,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<Client {self.name}>\""
    },
    {
      "name": "get_project_or_404",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 29,
      "docstring": "Get a project by ID or raise 404 if not found or not owned by user.",
      "parameters": [
        "project_id",
        "user",
        "db"
      ],
      "return_type": "Project",
      "decorators": [],
      "is_async": true,
      "source": "async def get_project_or_404(\n    project_id: str,\n    user: User,\n    db: AsyncSession,\n) -> Project:\n    \"\"\"Get a project by ID or raise 404 if not found or not owned by user.\"\"\"\n    try:\n        uuid_id = UUID(project_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    result = await db.execute(\n        select(Project)\n        .options(selectinload(Project.client))\n        .where(Project.id == uuid_id, Project.user_id == user.id)\n    )\n    project = result.scalar_one_or_none()\n    \n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    return project"
    },
    {
      "name": "get_project_stats",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 59,
      "docstring": "Calculate project statistics from scope items and client requests.",
      "parameters": [
        "project_id",
        "db"
      ],
      "return_type": "dict",
      "decorators": [],
      "is_async": true,
      "source": "async def get_project_stats(project_id: UUID, db: AsyncSession) -> dict:\n    \"\"\"Calculate project statistics from scope items and client requests.\"\"\"\n    # Count scope items\n    scope_count_result = await db.execute(\n        select(func.count()).select_from(ScopeItem).where(ScopeItem.project_id == project_id)\n    )\n    scope_item_count = scope_count_result.scalar() or 0\n    \n    # Count completed scope items\n    completed_count_result = await db.execute(\n        select(func.count())\n        .select_from(ScopeItem)\n        .where(ScopeItem.project_id == project_id, ScopeItem.is_completed == True)\n    )\n    completed_scope_count = completed_count_result.scalar() or 0\n    \n    # Count out-of-scope requests\n    out_of_scope_count = 0\n    try:\n        out_of_scope_result = await db.execute(\n            select(func.count())\n            .select_from(ClientRequest)\n            .where(\n                ClientRequest.project_id == project_id,\n                ClientRequest.classification == ScopeClassification.OUT_OF_SCOPE,\n            )\n        )\n        out_of_scope_count = out_of_scope_result.scalar() or 0\n    except Exception:\n        # ClientRequest table might not exist yet or have different structure\n        pass\n    \n    return {\n        \"scope_item_count\": scope_item_count,\n        \"completed_scope_count\": completed_scope_count,\n        \"out_of_scope_request_count\": out_of_scope_count,\n    }"
    },
    {
      "name": "project_to_response",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 98,
      "docstring": "Convert a Project model to ProjectResponse schema.",
      "parameters": [
        "project",
        "stats"
      ],
      "return_type": "ProjectResponse",
      "decorators": [],
      "is_async": false,
      "source": "def project_to_response(project: Project, stats: dict | None = None) -> ProjectResponse:\n    \"\"\"Convert a Project model to ProjectResponse schema.\"\"\"\n    stats = stats or {}\n    return ProjectResponse(\n        id=str(project.id),\n        client_id=str(project.client_id),\n        client_name=project.client.name if project.client else \"Unknown\",\n        name=project.name,\n        description=project.description,\n        status=project.status,\n        budget=project.budget,\n        hourly_rate=project.hourly_rate,\n        estimated_hours=project.estimated_hours,\n        created_at=project.created_at,\n        updated_at=project.updated_at,\n        scope_item_count=stats.get(\"scope_item_count\", 0),\n        completed_scope_count=stats.get(\"completed_scope_count\", 0),\n        out_of_scope_request_count=stats.get(\"out_of_scope_request_count\", 0),\n    )"
    },
    {
      "name": "list_projects",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 120,
      "docstring": "List all projects for the current user.\n\nSupports filtering by status and client_id.",
      "parameters": [
        "db",
        "current_user",
        "status_filter",
        "client_id",
        "skip",
        "limit"
      ],
      "return_type": "ProjectList",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def list_projects(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    status_filter: Annotated[ProjectStatus | None, Query(alias=\"status\")] = None,\n    client_id: Annotated[str | None, Query()] = None,\n    skip: Annotated[int, Query(ge=0)] = 0,\n    limit: Annotated[int, Query(ge=1, le=100)] = 20,\n) -> ProjectList:\n    \"\"\"\n    List all projects for the current user.\n    \n    Supports filtering by status and client_id.\n    \"\"\"\n    # Build base query\n    query = (\n        select(Project)\n        .options(selectinload(Project.client))\n        .where(Project.user_id == current_user.id)\n    )\n    \n    # Apply filters\n    if status_filter:\n        query = query.where(Project.status == status_filter)\n    \n    if client_id:\n        try:\n            client_uuid = UUID(client_id)\n            query = query.where(Project.client_id == client_uuid)\n        except ValueError:\n            # Invalid UUID, return empty results\n            return ProjectList(projects=[], total=0)\n    \n    # Get total count\n    count_query = select(func.count()).select_from(query.subquery())\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    # Apply pagination and ordering\n    query = query.order_by(Project.created_at.desc()).offset(skip).limit(limit)\n    \n    result = await db.execute(query)\n    projects = result.scalars().all()\n    \n    # Get stats for each project\n    projects_with_stats = []\n    for project in projects:\n        stats = await get_project_stats(project.id, db)\n        projects_with_stats.append(project_to_response(project, stats))\n    \n    return ProjectList(\n        projects=projects_with_stats,\n        total=total,\n    )"
    },
    {
      "name": "create_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 176,
      "docstring": "Create a new project.\n\nThe client_id must belong to the current user.",
      "parameters": [
        "project_in",
        "db",
        "current_user"
      ],
      "return_type": "ProjectResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_project(\n    project_in: ProjectCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"\n    Create a new project.\n    \n    The client_id must belong to the current user.\n    \"\"\"\n    # Verify client exists and belongs to user\n    try:\n        client_uuid = UUID(project_in.client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    result = await db.execute(\n        select(Client).where(\n            Client.id == client_uuid,\n            Client.user_id == current_user.id,\n        )\n    )\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Create project\n    project = Project(\n        user_id=current_user.id,\n        client_id=client_uuid,\n        name=project_in.name,\n        description=project_in.description,\n        status=project_in.status,\n        budget=project_in.budget,\n        hourly_rate=project_in.hourly_rate,\n        estimated_hours=project_in.estimated_hours,\n    )\n    \n    db.add(project)\n    await db.commit()\n    await db.refresh(project)\n    \n    # Load client relationship for response\n    project.client = client\n    \n    return project_to_response(project)"
    },
    {
      "name": "get_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 232,
      "docstring": "Get a specific project with stats.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "ProjectResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_project(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"Get a specific project with stats.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Calculate actual stats from database\n    stats = await get_project_stats(project.id, db)\n    \n    return project_to_response(project, stats)"
    },
    {
      "name": "get_project_detail",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 247,
      "docstring": "Get a project with scope items and recent requests.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "ProjectDetail",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_project_detail(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectDetail:\n    \"\"\"Get a project with scope items and recent requests.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Calculate actual stats from database\n    stats = await get_project_stats(project.id, db)\n    \n    response = project_to_response(project, stats)\n    \n    return ProjectDetail(\n        **response.model_dump(),\n        scope_items=[],\n        recent_requests=[],\n    )"
    },
    {
      "name": "update_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 268,
      "docstring": "Update a project.",
      "parameters": [
        "project_id",
        "project_in",
        "db",
        "current_user"
      ],
      "return_type": "ProjectResponse",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_project(\n    project_id: str,\n    project_in: ProjectUpdate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"Update a project.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Update only provided fields\n    update_data = project_in.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(project, field, value)\n    \n    await db.commit()\n    await db.refresh(project)\n    \n    # Get updated stats\n    stats = await get_project_stats(project.id, db)\n    \n    return project_to_response(project, stats)"
    },
    {
      "name": "delete_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 292,
      "docstring": "Delete a project.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [
        "router.delete"
      ],
      "is_async": true,
      "source": "async def delete_project(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Delete a project.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    await db.delete(project)\n    await db.commit()"
    },
    {
      "name": "test_create_scope_item_success",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 16,
      "docstring": "Test creating a scope item successfully.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test creating a scope item successfully.\"\"\"\n        scope_data = {\n            \"title\": \"Design homepage\",\n            \"description\": \"Create the homepage design mockup\",\n            \"estimated_hours\": \"5.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json=scope_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == scope_data[\"title\"]\n        assert data[\"description\"] == scope_data[\"description\"]\n        assert data[\"order\"] == 0  # First item should have order 0\n        assert data[\"is_completed\"] is False"
    },
    {
      "name": "test_create_scope_item_auto_order",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 43,
      "docstring": "Test that scope items auto-assign incrementing orders.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_auto_order(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that scope items auto-assign incrementing orders.\"\"\"\n        titles = [\"First task\", \"Second task\", \"Third task\"]\n        \n        for i, title in enumerate(titles):\n            response = await client.post(\n                f\"/api/v1/projects/{test_project.id}/scope\",\n                json={\"title\": title},\n                headers=auth_headers,\n            )\n            \n            assert response.status_code == status.HTTP_201_CREATED\n            data = response.json()\n            assert data[\"order\"] == i  # Orders should be 0, 1, 2"
    },
    {
      "name": "test_create_scope_item_minimal_data",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 64,
      "docstring": "Test creating a scope item with only required fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_minimal_data(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test creating a scope item with only required fields.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"Minimal task\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == \"Minimal task\"\n        assert data[\"description\"] is None\n        assert data[\"estimated_hours\"] is None"
    },
    {
      "name": "test_list_scope_items_ordered",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 88,
      "docstring": "Test that scope items are returned in order.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_ordered"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_scope_items_ordered(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_ordered: list[ScopeItem],\n    ):\n        \"\"\"Test that scope items are returned in order.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Verify items are in correct order\n        assert len(data) == 3\n        for i, item in enumerate(data):\n            assert item[\"order\"] == i"
    },
    {
      "name": "test_list_scope_items_empty",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 110,
      "docstring": "Test listing scope items for a project with no items.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_scope_items_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test listing scope items for a project with no items.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data == []"
    },
    {
      "name": "test_update_scope_item_completed",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 131,
      "docstring": "Test marking a scope item as completed.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_scope_item_completed(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test marking a scope item as completed.\"\"\"\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            json={\"is_completed\": True},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"is_completed\"] is True"
    },
    {
      "name": "test_update_scope_item_title",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 150,
      "docstring": "Test updating a scope item's title.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_scope_item_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test updating a scope item's title.\"\"\"\n        new_title = \"Updated task title\"\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            json={\"title\": new_title},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"title\"] == new_title"
    },
    {
      "name": "test_update_scope_item_not_found",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 170,
      "docstring": "Test updating a non-existent scope item.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_scope_item_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test updating a non-existent scope item.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{fake_id}\",\n            json={\"is_completed\": True},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_get_progress_empty",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 191,
      "docstring": "Test getting progress for a project with no scope items.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_progress_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test getting progress for a project with no scope items.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_items\"] == 0\n        assert data[\"completed_items\"] == 0\n        assert data[\"completion_percentage\"] == 0.0"
    },
    {
      "name": "test_get_progress_partial",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 210,
      "docstring": "Test getting progress with partial completion (1 of 3 = 33.33%).",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_with_progress"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_progress_partial(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_with_progress: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress with partial completion (1 of 3 = 33.33%).\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_items\"] == 3\n        assert data[\"completed_items\"] == 1\n        assert data[\"completion_percentage\"] == 33.33"
    },
    {
      "name": "test_get_progress_with_hours",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 230,
      "docstring": "Test getting progress with estimated hours calculations.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_with_hours"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_progress_with_hours(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_with_hours: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress with estimated hours calculations.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Total hours: 5 + 10 + 3 = 18\n        # Completed hours: 5 + 3 = 8 (tasks 1 and 3 are completed)\n        assert data[\"total_estimated_hours\"] is not None\n        assert data[\"completed_estimated_hours\"] is not None\n        assert Decimal(str(data[\"total_estimated_hours\"])) == Decimal(\"18.0\")\n        assert Decimal(str(data[\"completed_estimated_hours\"])) == Decimal(\"8.0\")"
    },
    {
      "name": "test_get_progress_all_completed",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 254,
      "docstring": "Test getting progress when all items are completed.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_all_completed"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_progress_all_completed(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_all_completed: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress when all items are completed.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"completion_percentage\"] == 100.0\n        assert data[\"total_items\"] == data[\"completed_items\"]"
    },
    {
      "name": "test_reorder_scope_items",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 277,
      "docstring": "Test reordering scope items from A,B,C to C,A,B.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_abc"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_reorder_scope_items(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reordering scope items from A,B,C to C,A,B.\"\"\"\n        item_a, item_b, item_c = scope_items_abc\n        new_order = [str(item_c.id), str(item_a.id), str(item_b.id)]\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": new_order},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Verify new orders: C=0, A=1, B=2\n        assert data[0][\"id\"] == str(item_c.id)\n        assert data[0][\"order\"] == 0\n        assert data[1][\"id\"] == str(item_a.id)\n        assert data[1][\"order\"] == 1\n        assert data[2][\"id\"] == str(item_b.id)\n        assert data[2][\"order\"] == 2"
    },
    {
      "name": "test_reorder_invalid_ids",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 306,
      "docstring": "Test reorder with non-existent item_id returns 400.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_abc"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_reorder_invalid_ids(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reorder with non-existent item_id returns 400.\"\"\"\n        fake_id = str(uuid4())\n        item_a, item_b, _ = scope_items_abc\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": [fake_id, str(item_a.id), str(item_b.id)]},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST"
    },
    {
      "name": "test_reorder_missing_items",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 326,
      "docstring": "Test reorder with missing items in the list returns 400.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_abc"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_reorder_missing_items(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reorder with missing items in the list returns 400.\"\"\"\n        item_a, item_b, _ = scope_items_abc\n        # Only providing 2 items when 3 exist\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": [str(item_a.id), str(item_b.id)]},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST"
    },
    {
      "name": "test_delete_scope_item",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 350,
      "docstring": "Test deleting a scope item.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test deleting a scope item.\"\"\"\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT"
    },
    {
      "name": "test_delete_scope_item_not_found",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 366,
      "docstring": "Test deleting a non-existent scope item.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_scope_item_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test deleting a non-existent scope item.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{fake_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_delete_middle_item_preserves_others",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 382,
      "docstring": "Test that deleting a middle item doesn't affect others.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "scope_items_abc"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_middle_item_preserves_others(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test that deleting a middle item doesn't affect others.\"\"\"\n        item_a, item_b, item_c = scope_items_abc\n        \n        # Delete middle item (B)\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{item_b.id}\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify remaining items still exist\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Should have 2 items left\n        assert len(data) == 2\n        item_ids = [item[\"id\"] for item in data]\n        assert str(item_a.id) in item_ids\n        assert str(item_b.id) not in item_ids\n        assert str(item_c.id) in item_ids"
    },
    {
      "name": "test_scope_item_other_users_project",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 419,
      "docstring": "Test that a user cannot add scope to another user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_scope_item_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"Test that a user cannot add scope to another user's project.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{other_user_project.id}/scope\",\n            json={\"title\": \"Unauthorized task\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_list_scope_other_users_project",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 435,
      "docstring": "Test that a user cannot list scope from another user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_scope_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"Test that a user cannot list scope from another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_unauthorized_access",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 450,
      "docstring": "Test that unauthenticated requests are rejected.",
      "parameters": [
        "self",
        "client",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_unauthorized_access(\n        self,\n        client: AsyncClient,\n        test_project: Project,\n    ):\n        \"\"\"Test that unauthenticated requests are rejected.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n        )\n        \n        # Accept either 401 (Unauthorized) or 403 (Forbidden) - both indicate auth required\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "test_create_scope_item_empty_title",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 468,
      "docstring": "Test that empty title is rejected.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_empty_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that empty title is rejected.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_create_scope_item_title_too_long",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 484,
      "docstring": "Test that overly long title is rejected.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_title_too_long(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that overly long title is rejected.\"\"\"\n        long_title = \"x\" * 256\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": long_title},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_create_scope_item_negative_hours",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 501,
      "docstring": "Test that negative estimated hours is rejected.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_scope_item_negative_hours(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that negative estimated hours is rejected.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"Task\", \"estimated_hours\": \"-5.0\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY"
    },
    {
      "name": "test_invalid_project_id_format",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 517,
      "docstring": "Test that invalid UUID format returns 404.",
      "parameters": [
        "self",
        "client",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_invalid_project_id_format(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n    ):\n        \"\"\"Test that invalid UUID format returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/not-a-uuid/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "mock_analyze_client_request",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 41,
      "docstring": "Mock the analyze_client_request function.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def mock_analyze_client_request():\n    \"\"\"Mock the analyze_client_request function.\"\"\"\n    with patch(\n        \"app.api.v1.endpoints.client_requests.analyze_client_request\"\n    ) as mock_func:\n        async def side_effect(client_request, session=None, commit=False):\n            # Simulate what the real function does - updates the client_request\n            client_request.classification = ScopeClassification.IN_SCOPE\n            client_request.confidence = Decimal(\"0.85\")\n            client_request.analysis_reasoning = \"Test reasoning\"\n            client_request.suggested_action = \"Proceed with task\"\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult()\n        \n        mock_func.side_effect = side_effect\n        yield mock_func"
    },
    {
      "name": "mock_analyze_out_of_scope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 60,
      "docstring": "Mock analyzer that returns OUT_OF_SCOPE.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def mock_analyze_out_of_scope():\n    \"\"\"Mock analyzer that returns OUT_OF_SCOPE.\"\"\"\n    with patch(\n        \"app.api.v1.endpoints.client_requests.analyze_client_request\"\n    ) as mock_func:\n        async def side_effect(client_request, session=None, commit=False):\n            client_request.classification = ScopeClassification.OUT_OF_SCOPE\n            client_request.confidence = Decimal(\"0.92\")\n            client_request.analysis_reasoning = \"This request is outside the defined project scope\"\n            client_request.suggested_action = \"Create a change request proposal\"\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult(\n                classification=\"out_of_scope\",\n                confidence=0.92,\n                reasoning=\"This request is outside the defined project scope\",\n                matched_scope_item_id=None,\n                suggested_action=\"Create a change request proposal\",\n                scope_creep_indicators=[\n                    \"Request introduces new deliverable\",\n                    \"Not mentioned in original scope\",\n                ],\n            )\n        \n        mock_func.side_effect = side_effect\n        yield mock_func"
    },
    {
      "name": "mock_analyze_in_scope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 88,
      "docstring": "Mock analyzer that returns IN_SCOPE with matched item.",
      "parameters": [
        "test_scope_item"
      ],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def mock_analyze_in_scope(test_scope_item: ScopeItem):\n    \"\"\"Mock analyzer that returns IN_SCOPE with matched item.\"\"\"\n    with patch(\n        \"app.api.v1.endpoints.client_requests.analyze_client_request\"\n    ) as mock_func:\n        async def side_effect(client_request, session=None, commit=False):\n            client_request.classification = ScopeClassification.IN_SCOPE\n            client_request.confidence = Decimal(\"0.95\")\n            client_request.analysis_reasoning = \"This request aligns with scope item: Build user authentication\"\n            client_request.suggested_action = \"Proceed with implementation\"\n            client_request.linked_scope_item_id = test_scope_item.id\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult(\n                classification=\"in_scope\",\n                confidence=0.95,\n                reasoning=\"This request aligns with scope item: Build user authentication\",\n                matched_scope_item_id=test_scope_item.id,\n                suggested_action=\"Proceed with implementation\",\n                scope_creep_indicators=[],\n            )\n        \n        mock_func.side_effect = side_effect\n        yield mock_func"
    },
    {
      "name": "__init__",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 23,
      "docstring": null,
      "parameters": [
        "self",
        "classification",
        "confidence",
        "reasoning",
        "matched_scope_item_id",
        "suggested_action",
        "scope_creep_indicators"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def __init__(\n        self,\n        classification: str = \"in_scope\",\n        confidence: float = 0.85,\n        reasoning: str = \"Test reasoning\",\n        matched_scope_item_id: UUID | None = None,\n        suggested_action: str = \"Proceed with task\",\n        scope_creep_indicators: list[str] | None = None,\n    ):\n        self.classification = classification\n        self.confidence = confidence\n        self.reasoning = reasoning\n        self.matched_scope_item_id = matched_scope_item_id\n        self.suggested_action = suggested_action\n        self.scope_creep_indicators = scope_creep_indicators or []"
    },
    {
      "name": "test_create_request_no_analysis",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 122,
      "docstring": "Create request with auto_analyze=False, verify PENDING classification.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_no_analysis(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Create request with auto_analyze=False, verify PENDING classification.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Test Request\",\n                \"content\": \"This is a test client request\",\n                \"source\": \"email\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"title\"] == \"Test Request\"\n        assert data[\"content\"] == \"This is a test client request\"\n        assert data[\"source\"] == \"email\"\n        assert data[\"status\"] == \"new\"\n        assert data[\"classification\"] == \"pending\"\n        assert data[\"analysis_reasoning\"] is None\n        assert data[\"confidence\"] is None\n        assert data[\"linked_scope_item_id\"] is None"
    },
    {
      "name": "test_create_request_with_analysis",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 162,
      "docstring": "Create request with auto_analyze=True, verify analysis is performed.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item",
        "mock_analyze_client_request"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_with_analysis(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_client_request,\n    ):\n        \"\"\"Create request with auto_analyze=True, verify analysis is performed.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Authentication Feature\",\n                \"content\": \"Working on the login form\",\n                \"source\": \"chat\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"classification\"] != \"pending\"\n        assert data[\"analysis_reasoning\"] is not None\n        assert data[\"suggested_action\"] is not None\n\n        # Verify analyzer was called\n        mock_analyze_client_request.assert_called_once()"
    },
    {
      "name": "test_create_request_out_of_scope_detected",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 203,
      "docstring": "Scope: [\"Build homepage\"]\nRequest: \"Can you also build a mobile app?\"\nVerify classification=out_of_scope, indicators detected.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item",
        "mock_analyze_out_of_scope"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_out_of_scope_detected(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_out_of_scope,\n    ):\n        \"\"\"\n        Scope: [\"Build homepage\"]\n        Request: \"Can you also build a mobile app?\"\n        Verify classification=out_of_scope, indicators detected.\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Mobile App Request\",\n                \"content\": \"Can you also build a mobile app?\",\n                \"source\": \"email\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"classification\"] == \"out_of_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"analysis_reasoning\"] is not None\n        assert \"scope\" in data[\"analysis_reasoning\"].lower()"
    },
    {
      "name": "test_create_request_in_scope_detected",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 245,
      "docstring": "Scope: [\"Build user authentication\"]\nRequest: \"Working on the login form\"\nVerify classification=in_scope, linked_scope_item set.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item",
        "mock_analyze_in_scope"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_in_scope_detected(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_in_scope,\n    ):\n        \"\"\"\n        Scope: [\"Build user authentication\"]\n        Request: \"Working on the login form\"\n        Verify classification=in_scope, linked_scope_item set.\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Login Form Update\",\n                \"content\": \"Working on the login form\",\n                \"source\": \"meeting\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"classification\"] == \"in_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"linked_scope_item_id\"] is not None"
    },
    {
      "name": "test_list_requests_filter_classification",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 286,
      "docstring": "Create IN_SCOPE and OUT_OF_SCOPE requests.\nFilter by classification=out_of_scope.\nVerify only out_of_scope returned.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "db_session"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_requests_filter_classification(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"\n        Create IN_SCOPE and OUT_OF_SCOPE requests.\n        Filter by classification=out_of_scope.\n        Verify only out_of_scope returned.\n        \"\"\"\n        # Create requests with different classifications directly in DB\n        in_scope_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"In Scope Request\",\n            content=\"This is in scope\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        out_scope_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"Out of Scope Request\",\n            content=\"This is out of scope\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.OUT_OF_SCOPE,\n        )\n        db_session.add_all([in_scope_request, out_scope_request])\n        await db_session.commit()\n\n        # Filter by out_of_scope (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"classification\": \"out_of_scope\"},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert \"items\" in data\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"classification\"] == \"out_of_scope\""
    },
    {
      "name": "test_list_requests_filter_status",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 342,
      "docstring": "Create NEW and ANALYZED requests.\nFilter appropriately.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "db_session"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_requests_filter_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"\n        Create NEW and ANALYZED requests.\n        Filter appropriately.\n        \"\"\"\n        # Create requests with different statuses\n        new_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"New Request\",\n            content=\"This is new\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n        )\n        analyzed_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"Analyzed Request\",\n            content=\"This is analyzed\",\n            source=RequestSource.CHAT,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        db_session.add_all([new_request, analyzed_request])\n        await db_session.commit()\n\n        # Filter by new status (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"status\": \"new\"},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"status\"] == \"new\"\n\n        # Filter by analyzed status (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"status\": \"analyzed\"},\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"status\"] == \"analyzed\""
    },
    {
      "name": "test_manual_analyze_endpoint",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 409,
      "docstring": "Create request with auto_analyze=False.\nCall /analyze endpoint.\nVerify analysis results returned and saved.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item",
        "mock_analyze_client_request"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_manual_analyze_endpoint(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_client_request,\n    ):\n        \"\"\"\n        Create request with auto_analyze=False.\n        Call /analyze endpoint.\n        Verify analysis results returned and saved.\n        \"\"\"\n        # Create request without analysis\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Pending Request\",\n                \"content\": \"This needs manual analysis\",\n                \"source\": \"call\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n        assert create_response.json()[\"classification\"] == \"pending\"\n\n        # Trigger manual analysis\n        analyze_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}/analyze\",\n            headers=auth_headers,\n        )\n\n        assert analyze_response.status_code == 200\n        analysis_data = analyze_response.json()\n\n        assert \"classification\" in analysis_data\n        assert \"confidence\" in analysis_data\n        assert \"reasoning\" in analysis_data\n        assert \"suggested_action\" in analysis_data\n        assert \"scope_creep_indicators\" in analysis_data\n\n        # Verify request was updated\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n        )\n\n        assert get_response.status_code == 200\n        updated_data = get_response.json()\n        assert updated_data[\"status\"] == \"analyzed\"\n        assert updated_data[\"classification\"] != \"pending\""
    },
    {
      "name": "test_update_request_status",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 474,
      "docstring": "Update status to addressed, verify change persisted.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_request_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Update status to addressed, verify change persisted.\"\"\"\n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Status Test\",\n                \"content\": \"Testing status update\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Update status (lowercase)\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"status\": \"addressed\"},\n        )\n\n        assert update_response.status_code == 200, f\"Response: {update_response.json()}\"\n        assert update_response.json()[\"status\"] == \"addressed\"\n\n        # Verify persistence\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n        )\n\n        assert get_response.json()[\"status\"] == \"addressed\""
    },
    {
      "name": "test_update_request_link_scope_item",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 523,
      "docstring": "Manually link request to scope item, verify linked_scope_item_id set.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_scope_item"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_request_link_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Manually link request to scope item, verify linked_scope_item_id set.\"\"\"\n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Link Test\",\n                \"content\": \"Testing scope item linking\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Link to scope item\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"linked_scope_item_id\": str(test_scope_item.id)},\n        )\n\n        assert update_response.status_code == 200\n        assert update_response.json()[\"linked_scope_item_id\"] == str(test_scope_item.id)"
    },
    {
      "name": "test_create_request_empty_scope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 565,
      "docstring": "Project with no scope items.\nauto_analyze=True.\nVerify handles gracefully (likely out_of_scope).",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_empty_scope(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,  # Project without scope items\n    ):\n        \"\"\"\n        Project with no scope items.\n        auto_analyze=True.\n        Verify handles gracefully (likely out_of_scope).\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Empty Scope Test\",\n                \"content\": \"What happens with no scope items?\",\n                \"source\": \"other\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        # Should handle gracefully - either out_of_scope or specific handling\n        assert data[\"classification\"] == \"out_of_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert \"no scope items\" in data[\"analysis_reasoning\"].lower()"
    },
    {
      "name": "test_create_request_missing_title",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 605,
      "docstring": "Verify validation error for missing title.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_missing_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify validation error for missing title.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"content\": \"Content without title\",\n            },\n        )\n\n        assert response.status_code == 422"
    },
    {
      "name": "test_create_request_empty_content",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 623,
      "docstring": "Verify validation error for empty content.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_request_empty_content(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify validation error for empty content.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Test\",\n                \"content\": \"\",\n            },\n        )\n\n        assert response.status_code == 422"
    },
    {
      "name": "test_get_nonexistent_request",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 651,
      "docstring": "Verify 404 for non-existent request.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_nonexistent_request(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify 404 for non-existent request.\"\"\"\n        import uuid\n        fake_uuid = uuid.uuid4()\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{fake_uuid}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "test_get_request_wrong_project",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 668,
      "docstring": "Verify 404 when accessing request from wrong project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "other_user_project",
        "other_auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_request_wrong_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        other_user_project: Project,\n        other_auth_headers: dict,\n    ):\n        \"\"\"Verify 404 when accessing request from wrong project.\"\"\"\n        # Create request in test_project\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Cross Project Test\",\n                \"content\": \"Test content\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Try to access from other_user_project (different owner)\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/requests/{request_id}\",\n            headers=other_auth_headers,\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "test_link_invalid_scope_item",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 709,
      "docstring": "Verify error when linking to non-existent scope item.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_link_invalid_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify error when linking to non-existent scope item.\"\"\"\n        import uuid\n        \n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Invalid Link Test\",\n                \"content\": \"Test content\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Try to link to non-existent scope item (use valid UUID format)\n        fake_scope_id = str(uuid.uuid4())\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"linked_scope_item_id\": fake_scope_id},\n        )\n\n        assert update_response.status_code == 400\n        assert \"scope item not found\" in update_response.json()[\"detail\"].lower()"
    },
    {
      "name": "test_cannot_access_other_users_project_requests",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 753,
      "docstring": "Verify user cannot access requests from another user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_cannot_access_other_users_project_requests(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_project: Project,\n    ):\n        \"\"\"Verify user cannot access requests from another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/requests\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "test_cannot_create_request_in_other_users_project",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 768,
      "docstring": "Verify user cannot create request in another user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_cannot_create_request_in_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_project: Project,\n    ):\n        \"\"\"Verify user cannot create request in another user's project.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{other_user_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Unauthorized Request\",\n                \"content\": \"Should not be allowed\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "test_list_requests_pagination",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 797,
      "docstring": "Test skip and limit parameters.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "db_session"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_requests_pagination(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"Test skip and limit parameters.\"\"\"\n        # Create multiple requests\n        for i in range(5):\n            request = ClientRequest(\n                project_id=test_project.id,\n                title=f\"Request {i}\",\n                content=f\"Content {i}\",\n                source=RequestSource.EMAIL,\n                status=RequestStatus.NEW,\n                classification=ScopeClassification.PENDING,\n            )\n            db_session.add(request)\n        await db_session.commit()\n\n        # Get first 2\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"skip\": 0, \"limit\": 2},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n        assert len(data[\"items\"]) == 2\n        assert data[\"total\"] == 5\n        assert data[\"skip\"] == 0\n        assert data[\"limit\"] == 2\n\n        # Get next 2\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"skip\": 2, \"limit\": 2},\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data[\"items\"]) == 2\n        assert data[\"skip\"] == 2"
    },
    {
      "name": "side_effect",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 46,
      "docstring": null,
      "parameters": [
        "client_request",
        "session",
        "commit"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def side_effect(client_request, session=None, commit=False):\n            # Simulate what the real function does - updates the client_request\n            client_request.classification = ScopeClassification.IN_SCOPE\n            client_request.confidence = Decimal(\"0.85\")\n            client_request.analysis_reasoning = \"Test reasoning\"\n            client_request.suggested_action = \"Proceed with task\"\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult()"
    },
    {
      "name": "side_effect",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 65,
      "docstring": null,
      "parameters": [
        "client_request",
        "session",
        "commit"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def side_effect(client_request, session=None, commit=False):\n            client_request.classification = ScopeClassification.OUT_OF_SCOPE\n            client_request.confidence = Decimal(\"0.92\")\n            client_request.analysis_reasoning = \"This request is outside the defined project scope\"\n            client_request.suggested_action = \"Create a change request proposal\"\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult(\n                classification=\"out_of_scope\",\n                confidence=0.92,\n                reasoning=\"This request is outside the defined project scope\",\n                matched_scope_item_id=None,\n                suggested_action=\"Create a change request proposal\",\n                scope_creep_indicators=[\n                    \"Request introduces new deliverable\",\n                    \"Not mentioned in original scope\",\n                ],\n            )"
    },
    {
      "name": "side_effect",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 93,
      "docstring": null,
      "parameters": [
        "client_request",
        "session",
        "commit"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def side_effect(client_request, session=None, commit=False):\n            client_request.classification = ScopeClassification.IN_SCOPE\n            client_request.confidence = Decimal(\"0.95\")\n            client_request.analysis_reasoning = \"This request aligns with scope item: Build user authentication\"\n            client_request.suggested_action = \"Proceed with implementation\"\n            client_request.linked_scope_item_id = test_scope_item.id\n            client_request.status = RequestStatus.ANALYZED\n            return MockAnalysisResult(\n                classification=\"in_scope\",\n                confidence=0.95,\n                reasoning=\"This request aligns with scope item: Build user authentication\",\n                matched_scope_item_id=test_scope_item.id,\n                suggested_action=\"Proceed with implementation\",\n                scope_creep_indicators=[],\n            )"
    },
    {
      "name": "_apply_result_to_request",
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 34,
      "docstring": "Apply analysis result to a ClientRequest model.",
      "parameters": [
        "client_request",
        "result"
      ],
      "return_type": "'ClientRequest'",
      "decorators": [],
      "is_async": false,
      "source": "def _apply_result_to_request(\n    client_request: \"ClientRequest\",\n    result: AnalysisResult,\n) -> \"ClientRequest\":\n    \"\"\"Apply analysis result to a ClientRequest model.\"\"\"\n    client_request.classification = CLASSIFICATION_MAP[result.classification]\n    client_request.confidence = Decimal(str(round(result.confidence, 2)))\n    client_request.analysis_reasoning = result.reasoning\n    client_request.suggested_action = result.suggested_action\n    client_request.status = RequestStatus.ANALYZED\n\n    if result.matched_scope_item_id:\n        client_request.linked_scope_item_id = result.matched_scope_item_id\n\n    return client_request"
    },
    {
      "name": "analyze_client_request",
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 51,
      "docstring": "Analyze a client request and optionally update it in the database.\n\nArgs:\n    client_request: The ClientRequest model to analyze (must have project loaded)\n    session: Optional async session for committing changes\n    commit: Whether to commit the changes\n\nReturns:\n    AnalysisResult with classification details\n\nExample:\n    async with async_session() as session:\n        request = await session.get(ClientRequest, request_id)\n        result = await analyze_client_request(request, session, commit=True)",
      "parameters": [
        "client_request",
        "session",
        "commit"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": true,
      "source": "async def analyze_client_request(\n    client_request: \"ClientRequest\",\n    session: \"AsyncSession | None\" = None,\n    commit: bool = False,\n) -> AnalysisResult:\n    \"\"\"\n    Analyze a client request and optionally update it in the database.\n\n    Args:\n        client_request: The ClientRequest model to analyze (must have project loaded)\n        session: Optional async session for committing changes\n        commit: Whether to commit the changes\n\n    Returns:\n        AnalysisResult with classification details\n\n    Example:\n        async with async_session() as session:\n            request = await session.get(ClientRequest, request_id)\n            result = await analyze_client_request(request, session, commit=True)\n    \"\"\"\n    analysis_request = AnalysisRequest.from_client_request(client_request)\n    result = await analyze_scope(analysis_request)\n    _apply_result_to_request(client_request, result)\n\n    if commit and session:\n        await session.commit()\n        await session.refresh(client_request)\n\n    return result"
    },
    {
      "name": "analyze_client_request_sync",
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 83,
      "docstring": "Synchronously analyze a client request (rules-only, no AI).\n\nArgs:\n    client_request: The ClientRequest model to analyze\n    session: Optional session for committing changes\n    commit: Whether to commit the changes\n\nReturns:\n    AnalysisResult with classification details",
      "parameters": [
        "client_request",
        "session",
        "commit"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": false,
      "source": "def analyze_client_request_sync(\n    client_request: \"ClientRequest\",\n    session: \"Session | None\" = None,\n    commit: bool = False,\n) -> AnalysisResult:\n    \"\"\"\n    Synchronously analyze a client request (rules-only, no AI).\n\n    Args:\n        client_request: The ClientRequest model to analyze\n        session: Optional session for committing changes\n        commit: Whether to commit the changes\n\n    Returns:\n        AnalysisResult with classification details\n    \"\"\"\n    analysis_request = AnalysisRequest.from_client_request(client_request)\n    result = analyze_scope_sync(analysis_request)\n    _apply_result_to_request(client_request, result)\n\n    if commit and session:\n        session.commit()\n        session.refresh(client_request)\n\n    return result"
    },
    {
      "name": "bulk_analyze_project_requests",
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 110,
      "docstring": "Analyze all client requests for a project.\n\nArgs:\n    project: Project with client_requests relationship loaded\n    session: Async session for database operations\n    commit: Whether to commit after all analyses\n    only_pending: If True, only analyze PENDING requests\n\nReturns:\n    List of (ClientRequest, AnalysisResult) tuples",
      "parameters": [
        "project",
        "session",
        "commit",
        "only_pending"
      ],
      "return_type": "list[tuple['ClientRequest', AnalysisResult]]",
      "decorators": [],
      "is_async": true,
      "source": "async def bulk_analyze_project_requests(\n    project: \"Project\",\n    session: \"AsyncSession\",\n    commit: bool = True,\n    only_pending: bool = True,\n) -> list[tuple[\"ClientRequest\", AnalysisResult]]:\n    \"\"\"\n    Analyze all client requests for a project.\n\n    Args:\n        project: Project with client_requests relationship loaded\n        session: Async session for database operations\n        commit: Whether to commit after all analyses\n        only_pending: If True, only analyze PENDING requests\n\n    Returns:\n        List of (ClientRequest, AnalysisResult) tuples\n    \"\"\"\n    results = []\n\n    for request in project.client_requests:\n        if only_pending and request.classification != ScopeClassification.PENDING:\n            continue\n\n        result = await analyze_client_request(request, commit=False)\n        results.append((request, result))\n\n    if commit:\n        await session.commit()\n\n    return results"
    },
    {
      "name": "health_check",
      "file_path": "app/api/v1/endpoints/health.py",
      "line_number": 13,
      "docstring": "Basic health check endpoint.",
      "parameters": [],
      "return_type": "dict",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def health_check() -> dict:\n    \"\"\"Basic health check endpoint.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"app\": settings.app_name,\n        \"version\": settings.app_version,\n    }"
    },
    {
      "name": "register",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 21,
      "docstring": "Register a new user.",
      "parameters": [
        "user_data",
        "db"
      ],
      "return_type": "User",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def register(\n    user_data: UserRegister,\n    db: Annotated[AsyncSession, Depends(get_db)],\n) -> User:\n    \"\"\"Register a new user.\"\"\"\n    \n    # Check if email already exists\n    result = await db.execute(\n        select(User).where(User.email == user_data.email)\n    )\n    existing_user = result.scalar_one_or_none()\n    \n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already registered\",\n        )\n    \n    # Create new user\n    user = User(\n        email=user_data.email,\n        hashed_password=hash_password(user_data.password),\n        full_name=user_data.full_name,\n        business_name=user_data.business_name,\n    )\n    \n    db.add(user)\n    await db.flush()\n    await db.refresh(user)\n    \n    return user"
    },
    {
      "name": "login",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 55,
      "docstring": "Login and get an access token.",
      "parameters": [
        "credentials",
        "db"
      ],
      "return_type": "dict",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def login(\n    credentials: UserLogin,\n    db: Annotated[AsyncSession, Depends(get_db)],\n) -> dict:\n    \"\"\"Login and get an access token.\"\"\"\n    \n    # Find user by email\n    result = await db.execute(\n        select(User).where(User.email == credentials.email)\n    )\n    user = result.scalar_one_or_none()\n    \n    if not user or not verify_password(credentials.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User account is deactivated\",\n        )\n    \n    # Create access token\n    access_token = create_access_token(data={\"sub\": str(user.id)})\n    \n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}"
    },
    {
      "name": "get_current_user_info",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 87,
      "docstring": "Get the current authenticated user's info.",
      "parameters": [
        "current_user"
      ],
      "return_type": "User",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_current_user_info(current_user: CurrentUser) -> User:\n    \"\"\"Get the current authenticated user's info.\"\"\"\n    return current_user"
    },
    {
      "name": "_build_analysis_response",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 37,
      "docstring": "Build the API response from a ClientRequest and AnalysisResult.",
      "parameters": [
        "client_request",
        "result"
      ],
      "return_type": "AnalyzeResponse",
      "decorators": [],
      "is_async": false,
      "source": "def _build_analysis_response(\n    client_request: ClientRequest,\n    result: AnalysisResult,\n) -> AnalyzeResponse:\n    \"\"\"Build the API response from a ClientRequest and AnalysisResult.\"\"\"\n    matched_item = None\n    if client_request.linked_scope_item:\n        matched_item = ScopeItemResponse.model_validate(client_request.linked_scope_item)\n\n    return AnalyzeResponse(\n        client_request=ClientRequestResponse.model_validate(client_request),\n        analysis=AnalysisResultResponse(\n            classification=client_request.classification,\n            confidence=client_request.confidence,\n            reasoning=result.reasoning,\n            suggested_action=result.suggested_action,\n            scope_creep_indicators=result.scope_creep_indicators,\n            matched_scope_item=matched_item,\n        ),\n    )"
    },
    {
      "name": "create_and_analyze_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 66,
      "docstring": "Create a new client request and analyze it.",
      "parameters": [
        "data",
        "db",
        "current_user"
      ],
      "return_type": "AnalyzeResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_and_analyze_request(\n    data: AnalyzeRequestCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> AnalyzeResponse:\n    \"\"\"Create a new client request and analyze it.\"\"\"\n    # Verify project exists and belongs to user\n    project = await db.scalar(\n        select(Project)\n        .options(selectinload(Project.scope_items))\n        .where(Project.id == data.project_id, Project.user_id == current_user.id)\n    )\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n\n    # Create the client request\n    client_request = ClientRequest(\n        project_id=data.project_id,\n        title=data.title,\n        content=data.content,\n        source=data.source,\n        status=RequestStatus.NEW,\n        classification=ScopeClassification.PENDING,\n    )\n    db.add(client_request)\n    await db.flush()\n\n    # Manually set the project for analysis (avoid another query)\n    client_request.project = project\n\n    # Analyze the request\n    result = await analyze_client_request(client_request, db, commit=True)\n\n    # Reload with relationships\n    await db.refresh(client_request, [\"linked_scope_item\"])\n\n    return _build_analysis_response(client_request, result)"
    },
    {
      "name": "analyze_existing_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 114,
      "docstring": "Analyze an existing client request.",
      "parameters": [
        "request_id",
        "db",
        "current_user"
      ],
      "return_type": "AnalyzeResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def analyze_existing_request(\n    request_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> AnalyzeResponse:\n    \"\"\"Analyze an existing client request.\"\"\"\n    # Get the request with project and scope items\n    client_request = await db.scalar(\n        select(ClientRequest)\n        .options(\n            selectinload(ClientRequest.project).selectinload(Project.scope_items),\n            selectinload(ClientRequest.linked_scope_item),\n        )\n        .join(Project)\n        .where(\n            ClientRequest.id == request_id,\n            Project.user_id == current_user.id,\n        )\n    )\n\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n\n    # Analyze the request\n    result = await analyze_client_request(client_request, db, commit=True)\n\n    # Reload relationships\n    await db.refresh(client_request, [\"linked_scope_item\"])\n\n    return _build_analysis_response(client_request, result)"
    },
    {
      "name": "analyze_project_requests",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 155,
      "docstring": "Analyze all client requests in a project.",
      "parameters": [
        "project_id",
        "db",
        "current_user",
        "only_pending"
      ],
      "return_type": "BulkAnalyzeResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def analyze_project_requests(\n    project_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    only_pending: bool = True,\n) -> BulkAnalyzeResponse:\n    \"\"\"Analyze all client requests in a project.\"\"\"\n    # Get the project with all relationships\n    project = await db.scalar(\n        select(Project)\n        .options(\n            selectinload(Project.scope_items),\n            selectinload(Project.client_requests).selectinload(\n                ClientRequest.linked_scope_item\n            ),\n        )\n        .where(Project.id == project_id, Project.user_id == current_user.id)\n    )\n\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n\n    # Bulk analyze\n    analyzed = await bulk_analyze_project_requests(\n        project, db, commit=True, only_pending=only_pending\n    )\n\n    # Build responses\n    results = [\n        _build_analysis_response(client_request, result)\n        for client_request, result in analyzed\n    ]\n\n    return BulkAnalyzeResponse(\n        analyzed_count=len(results),\n        results=results,\n    )"
    },
    {
      "name": "get_client_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 203,
      "docstring": "Get a client request with its analysis results.",
      "parameters": [
        "request_id",
        "db",
        "current_user"
      ],
      "return_type": "ClientRequestResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_client_request(\n    request_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ClientRequestResponse:\n    \"\"\"Get a client request with its analysis results.\"\"\"\n    client_request = await db.scalar(\n        select(ClientRequest)\n        .options(selectinload(ClientRequest.linked_scope_item))\n        .join(Project)\n        .where(\n            ClientRequest.id == request_id,\n            Project.user_id == current_user.id,\n        )\n    )\n\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n\n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "name": "test_register_success",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 12,
      "docstring": "Test successful user registration.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_register_success(self, client: AsyncClient):\n        \"\"\"Test successful user registration.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"newuser@example.com\",\n                \"password\": \"securepassword123\",\n                \"full_name\": \"New User\",\n                \"business_name\": \"New Business\",\n            },\n        )\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"email\"] == \"newuser@example.com\"\n        assert data[\"full_name\"] == \"New User\"\n        assert data[\"business_name\"] == \"New Business\"\n        assert data[\"is_active\"] is True\n        assert \"id\" in data\n        assert \"password\" not in data\n        assert \"hashed_password\" not in data"
    },
    {
      "name": "test_register_duplicate_email",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 34,
      "docstring": "Test registration with existing email fails.",
      "parameters": [
        "self",
        "client",
        "test_user"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_register_duplicate_email(self, client: AsyncClient, test_user):\n        \"\"\"Test registration with existing email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"test@example.com\",  # Same as test_user\n                \"password\": \"anotherpassword123\",\n                \"full_name\": \"Another User\",\n            },\n        )\n        \n        assert response.status_code == 400\n        assert \"already registered\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "test_register_invalid_email",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 48,
      "docstring": "Test registration with invalid email fails.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_register_invalid_email(self, client: AsyncClient):\n        \"\"\"Test registration with invalid email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"not-an-email\",\n                \"password\": \"securepassword123\",\n                \"full_name\": \"New User\",\n            },\n        )\n        \n        assert response.status_code == 422"
    },
    {
      "name": "test_register_short_password",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 61,
      "docstring": "Test registration with short password fails.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_register_short_password(self, client: AsyncClient):\n        \"\"\"Test registration with short password fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"newuser@example.com\",\n                \"password\": \"short\",\n                \"full_name\": \"New User\",\n            },\n        )\n        \n        assert response.status_code == 422"
    },
    {
      "name": "test_login_success",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 78,
      "docstring": "Test successful login.",
      "parameters": [
        "self",
        "client",
        "test_user"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_login_success(self, client: AsyncClient, test_user):\n        \"\"\"Test successful login.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"test@example.com\",\n                \"password\": \"testpassword123\",\n            },\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert \"access_token\" in data\n        assert data[\"token_type\"] == \"bearer\""
    },
    {
      "name": "test_login_wrong_password",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 93,
      "docstring": "Test login with wrong password fails.",
      "parameters": [
        "self",
        "client",
        "test_user"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_login_wrong_password(self, client: AsyncClient, test_user):\n        \"\"\"Test login with wrong password fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"test@example.com\",\n                \"password\": \"wrongpassword\",\n            },\n        )\n        \n        assert response.status_code == 401\n        assert \"incorrect\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "test_login_nonexistent_user",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 106,
      "docstring": "Test login with nonexistent email fails.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_login_nonexistent_user(self, client: AsyncClient):\n        \"\"\"Test login with nonexistent email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"nonexistent@example.com\",\n                \"password\": \"anypassword123\",\n            },\n        )\n        \n        assert response.status_code == 401"
    },
    {
      "name": "test_get_current_user",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 122,
      "docstring": "Test getting current user info.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_user"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_current_user(self, client: AsyncClient, auth_headers, test_user):\n        \"\"\"Test getting current user info.\"\"\"\n        response = await client.get(\n            \"/api/v1/auth/me\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"email\"] == \"test@example.com\"\n        assert data[\"full_name\"] == \"Test User\""
    },
    {
      "name": "test_get_current_user_no_token",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 134,
      "docstring": "Test getting current user without token fails.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_current_user_no_token(self, client: AsyncClient):\n        \"\"\"Test getting current user without token fails.\"\"\"\n        response = await client.get(\"/api/v1/auth/me\")\n        \n        assert response.status_code == 403"
    },
    {
      "name": "test_get_current_user_invalid_token",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 140,
      "docstring": "Test getting current user with invalid token fails.",
      "parameters": [
        "self",
        "client"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "    async def test_get_current_user_invalid_token(self, client: AsyncClient):\n        \"\"\"Test getting current user with invalid token fails.\"\"\"\n        response = await client.get(\n            \"/api/v1/auth/me\",\n            headers={\"Authorization\": \"Bearer invalidtoken\"},\n        )\n        \n        assert response.status_code == 401"
    },
    {
      "name": "_normalize_text",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 10,
      "docstring": "Normalize text for comparison.",
      "parameters": [
        "text"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "def _normalize_text(text: str) -> str:\n    \"\"\"Normalize text for comparison.\"\"\"\n    return re.sub(r\"\\s+\", \" \", text.lower().strip())"
    },
    {
      "name": "_tokenize",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 15,
      "docstring": "Extract words from text for comparison.",
      "parameters": [
        "text"
      ],
      "return_type": "set[str]",
      "decorators": [],
      "is_async": false,
      "source": "def _tokenize(text: str) -> set[str]:\n    \"\"\"Extract words from text for comparison.\"\"\"\n    normalized = _normalize_text(text)\n    words = re.findall(r\"\\b[a-z]+\\b\", normalized)\n    return set(words)"
    },
    {
      "name": "_find_phrases",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 22,
      "docstring": "Find which phrases from the list appear in the text.",
      "parameters": [
        "text",
        "phrases"
      ],
      "return_type": "list[str]",
      "decorators": [],
      "is_async": false,
      "source": "def _find_phrases(text: str, phrases: list[str]) -> list[str]:\n    \"\"\"Find which phrases from the list appear in the text.\"\"\"\n    normalized = _normalize_text(text)\n    return [phrase for phrase in phrases if phrase.lower() in normalized]"
    },
    {
      "name": "_calculate_word_overlap",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 28,
      "docstring": "Calculate Jaccard similarity between two texts.",
      "parameters": [
        "text1",
        "text2"
      ],
      "return_type": "float",
      "decorators": [],
      "is_async": false,
      "source": "def _calculate_word_overlap(text1: str, text2: str) -> float:\n    \"\"\"Calculate Jaccard similarity between two texts.\"\"\"\n    words1 = _tokenize(text1)\n    words2 = _tokenize(text2)\n\n    if not words1 or not words2:\n        return 0.0\n\n    intersection = words1 & words2\n    union = words1 | words2\n\n    return len(intersection) / len(union) if union else 0.0"
    },
    {
      "name": "_find_best_scope_match",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 42,
      "docstring": "Find the best matching scope item for the request.",
      "parameters": [
        "request_content",
        "scope_items"
      ],
      "return_type": "tuple[int | None, float, uuid.UUID | None]",
      "decorators": [],
      "is_async": false,
      "source": "def _find_best_scope_match(\n    request_content: str,\n    scope_items: list,\n) -> tuple[int | None, float, uuid.UUID | None]:\n    \"\"\"Find the best matching scope item for the request.\"\"\"\n    if not scope_items:\n        return None, 0.0, None\n\n    best_index = None\n    best_score = 0.0\n    best_id = None\n\n    for i, item in enumerate(scope_items):\n        scope_text = item.title\n        if item.description:\n            scope_text += \" \" + item.description\n\n        score = _calculate_word_overlap(request_content, scope_text)\n\n        if score > best_score:\n            best_score = score\n            best_index = i\n            best_id = getattr(item, \"id\", None)\n\n    return best_index, best_score, best_id"
    },
    {
      "name": "_get_suggested_action",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 69,
      "docstring": "Get the suggested action based on classification.",
      "parameters": [
        "classification"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "def _get_suggested_action(classification: ScopeClassificationType) -> str:\n    \"\"\"Get the suggested action based on classification.\"\"\"\n    actions = {\n        \"in_scope\": \"Proceed with the work as it falls within the agreed scope.\",\n        \"out_of_scope\": \"Send a proposal or quote for this additional work before proceeding.\",\n        \"clarification_needed\": \"Respond to the client's question to clarify the requirements.\",\n        \"revision\": \"Discuss the revision with the client - minor changes may be included, major changes may require a change order.\",\n    }\n    return actions[classification]"
    },
    {
      "name": "analyze_with_rules",
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 80,
      "docstring": "Analyze scope using rule-based matching.\n\nLogic:\n1. Check for clarification phrases -> CLARIFICATION_NEEDED\n2. Check for revision phrases + scope match -> REVISION\n3. Check for scope creep indicators -> likely OUT_OF_SCOPE\n4. Fuzzy match against scope items -> IN_SCOPE if good match\n5. Default to OUT_OF_SCOPE with low confidence",
      "parameters": [
        "request"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": false,
      "source": "def analyze_with_rules(request: AnalysisRequest) -> AnalysisResult:\n    \"\"\"\n    Analyze scope using rule-based matching.\n\n    Logic:\n    1. Check for clarification phrases -> CLARIFICATION_NEEDED\n    2. Check for revision phrases + scope match -> REVISION\n    3. Check for scope creep indicators -> likely OUT_OF_SCOPE\n    4. Fuzzy match against scope items -> IN_SCOPE if good match\n    5. Default to OUT_OF_SCOPE with low confidence\n    \"\"\"\n    content = request.request_content\n\n    # Detect indicator phrases\n    clarification_indicators = _find_phrases(content, CLARIFICATION_PHRASES)\n    revision_indicators = _find_phrases(content, REVISION_PHRASES)\n    scope_creep_indicators = _find_phrases(content, SCOPE_CREEP_PHRASES)\n\n    # Find best matching scope item\n    matched_index, match_score, matched_id = _find_best_scope_match(\n        content, request.scope_items\n    )\n\n    # Handle empty scope\n    if not request.scope_items:\n        return AnalysisResult(\n            classification=\"out_of_scope\",\n            confidence=0.9,\n            reasoning=\"No scope items defined - cannot determine if request is in scope.\",\n            matched_scope_item_index=None,\n            matched_scope_item_id=None,\n            suggested_action=_get_suggested_action(\"out_of_scope\"),\n            scope_creep_indicators=scope_creep_indicators,\n        )\n\n    # Step 1: Check for clarification\n    if clarification_indicators:\n        return AnalysisResult(\n            classification=\"clarification_needed\",\n            confidence=0.85,\n            reasoning=f\"Client appears to be asking for clarification. Detected phrases: {', '.join(clarification_indicators)}\",\n            matched_scope_item_index=matched_index if match_score > 0.1 else None,\n            matched_scope_item_id=matched_id if match_score > 0.1 else None,\n            suggested_action=_get_suggested_action(\"clarification_needed\"),\n            scope_creep_indicators=scope_creep_indicators,\n        )\n\n    # Step 2: Check for revision with scope match\n    if revision_indicators and match_score > 0.15:\n        confidence = min(0.8, 0.5 + match_score)\n        return AnalysisResult(\n            classification=\"revision\",\n            confidence=confidence,\n            reasoning=f\"Client requesting changes to existing scope item. Detected revision phrases: {', '.join(revision_indicators)}. Matched scope item: '{request.scope_items[matched_index].title}'\",\n            matched_scope_item_index=matched_index,\n            matched_scope_item_id=matched_id,\n            suggested_action=_get_suggested_action(\"revision\"),\n            scope_creep_indicators=scope_creep_indicators,\n        )\n\n    # Step 3: Check for scope creep indicators\n    if scope_creep_indicators:\n        if match_score > 0.4:\n            confidence = max(0.5, 0.7 - len(scope_creep_indicators) * 0.1)\n            return AnalysisResult(\n                classification=\"in_scope\",\n                confidence=confidence,\n                reasoning=f\"Request matches scope item '{request.scope_items[matched_index].title}' but contains scope creep language: {', '.join(scope_creep_indicators)}. Review carefully.\",\n                matched_scope_item_index=matched_index,\n                matched_scope_item_id=matched_id,\n                suggested_action=_get_suggested_action(\"in_scope\"),\n                scope_creep_indicators=scope_creep_indicators,\n            )\n        else:\n            confidence = min(0.95, 0.7 + len(scope_creep_indicators) * 0.05)\n            return AnalysisResult(\n                classification=\"out_of_scope\",\n                confidence=confidence,\n                reasoning=f\"Request contains scope creep indicators: {', '.join(scope_creep_indicators)}. No strong match to existing scope items.\",\n                matched_scope_item_index=None,\n                matched_scope_item_id=None,\n                suggested_action=_get_suggested_action(\"out_of_scope\"),\n                scope_creep_indicators=scope_creep_indicators,\n            )\n\n    # Step 4: Fuzzy match against scope items\n    if match_score > 0.3:\n        confidence = min(0.95, 0.5 + match_score)\n        return AnalysisResult(\n            classification=\"in_scope\",\n            confidence=confidence,\n            reasoning=f\"Request matches scope item: '{request.scope_items[matched_index].title}' with {match_score:.0%} similarity.\",\n            matched_scope_item_index=matched_index,\n            matched_scope_item_id=matched_id,\n            suggested_action=_get_suggested_action(\"in_scope\"),\n            scope_creep_indicators=scope_creep_indicators,\n        )\n    elif match_score > 0.15:\n        return AnalysisResult(\n            classification=\"in_scope\",\n            confidence=0.5 + match_score,\n            reasoning=f\"Partial match to scope item: '{request.scope_items[matched_index].title}'. Consider clarifying with client.\",\n            matched_scope_item_index=matched_index,\n            matched_scope_item_id=matched_id,\n            suggested_action=_get_suggested_action(\"in_scope\"),\n            scope_creep_indicators=scope_creep_indicators,\n        )\n\n    # Step 5: Default to out of scope\n    return AnalysisResult(\n        classification=\"out_of_scope\",\n        confidence=0.6,\n        reasoning=\"No significant match to any scope items. Request may be outside project scope.\",\n        matched_scope_item_index=None,\n        matched_scope_item_id=None,\n        suggested_action=_get_suggested_action(\"out_of_scope\"),\n        scope_creep_indicators=scope_creep_indicators,\n    )"
    },
    {
      "name": "get_settings",
      "file_path": "app/core/config.py",
      "line_number": 51,
      "docstring": "Get cached settings instance.",
      "parameters": [],
      "return_type": "Settings",
      "decorators": [
        "lru_cache"
      ],
      "is_async": false,
      "source": "def get_settings() -> Settings:\n    \"\"\"Get cached settings instance.\"\"\"\n    return Settings()"
    },
    {
      "name": "get_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 32,
      "docstring": "Get current user's subscription details.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Get current user's subscription details.\"\"\"\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    # If no subscription exists, create a free one\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    # Get current usage\n    projects_result = await db.execute(\n        select(func.count(Project.id)).where(Project.user_id == current_user.id)\n    )\n    current_projects = projects_result.scalar() or 0\n    \n    clients_result = await db.execute(\n        select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    )\n    current_clients = clients_result.scalar() or 0\n\n    return SubscriptionResponse(\n        plan=subscription.plan,\n        status=subscription.status,\n        is_pro=subscription.is_pro,\n        current_period_end=subscription.current_period_end,\n        cancel_at_period_end=subscription.cancel_at_period_end or False,\n        max_projects=subscription.max_projects,\n        max_clients=subscription.max_clients,\n        current_projects=current_projects,\n        current_clients=current_clients,\n    )"
    },
    {
      "name": "get_plan_limits",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 78,
      "docstring": "Get current plan limits and usage.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_plan_limits(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Get current plan limits and usage.\"\"\"\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    projects_result = await db.execute(\n        select(func.count(Project.id)).where(Project.user_id == current_user.id)\n    )\n    current_projects = projects_result.scalar() or 0\n    \n    clients_result = await db.execute(\n        select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    )\n    current_clients = clients_result.scalar() or 0\n\n    return PlanLimits(\n        plan=subscription.plan,\n        max_projects=subscription.max_projects,\n        max_clients=subscription.max_clients,\n        current_projects=current_projects,\n        current_clients=current_clients,\n        can_create_project=current_projects < subscription.max_projects,\n        can_create_client=current_clients < subscription.max_clients,\n    )"
    },
    {
      "name": "create_checkout_session",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 120,
      "docstring": "Create a Stripe Checkout session for Pro subscription.",
      "parameters": [
        "request",
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_checkout_session(\n    request: CreateCheckoutRequest,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Create a Stripe Checkout session for Pro subscription.\"\"\"\n    try:\n        checkout_url = await StripeService.create_checkout_session(\n            db=db,\n            user=current_user,\n            success_url=request.success_url,\n            cancel_url=request.cancel_url,\n        )\n        return CreateCheckoutResponse(checkout_url=checkout_url)\n    except stripe.error.StripeError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create checkout session: {str(e)}\")"
    },
    {
      "name": "create_portal_session",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 141,
      "docstring": "Create a Stripe Customer Portal session for managing subscription.",
      "parameters": [
        "request",
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_portal_session(\n    request: CreatePortalRequest,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Create a Stripe Customer Portal session for managing subscription.\"\"\"\n    try:\n        portal_url = await StripeService.create_portal_session(\n            db=db,\n            user=current_user,\n            return_url=request.return_url,\n        )\n        return CreatePortalResponse(portal_url=portal_url)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except stripe.error.StripeError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create portal session: {str(e)}\")"
    },
    {
      "name": "cancel_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 163,
      "docstring": "Cancel subscription at end of billing period.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def cancel_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Cancel subscription at end of billing period.\"\"\"\n    success = await StripeService.cancel_subscription(db, current_user)\n    if not success:\n        raise HTTPException(status_code=400, detail=\"No active subscription to cancel\")\n    return {\"message\": \"Subscription will be canceled at end of billing period\"}"
    },
    {
      "name": "reactivate_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 175,
      "docstring": "Reactivate a canceled subscription before it expires.",
      "parameters": [
        "db",
        "current_user"
      ],
      "return_type": null,
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def reactivate_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Reactivate a canceled subscription before it expires.\"\"\"\n    success = await StripeService.reactivate_subscription(db, current_user)\n    if not success:\n        raise HTTPException(status_code=400, detail=\"No subscription to reactivate\")\n    return {\"message\": \"Subscription reactivated\"}"
    },
    {
      "name": "stripe_webhook",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 187,
      "docstring": "Handle Stripe webhook events.",
      "parameters": [
        "request",
        "db",
        "stripe_signature"
      ],
      "return_type": null,
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def stripe_webhook(\n    request: Request,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    stripe_signature: str = Header(None, alias=\"Stripe-Signature\"),\n):\n    \"\"\"Handle Stripe webhook events.\"\"\"\n    payload = await request.body()\n    webhook_secret = os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")\n    \n    try:\n        event = stripe.Webhook.construct_event(\n            payload,\n            stripe_signature,\n            webhook_secret,\n        )\n    except ValueError:\n        raise HTTPException(status_code=400, detail=\"Invalid payload\")\n    except stripe.error.SignatureVerificationError:\n        raise HTTPException(status_code=400, detail=\"Invalid signature\")\n\n    # Handle the event\n    event_type = event[\"type\"]\n    event_data = event[\"data\"][\"object\"]\n\n    if event_type == \"checkout.session.completed\":\n        await StripeService.handle_checkout_completed(db, event_data)\n    \n    elif event_type == \"customer.subscription.updated\":\n        await StripeService.handle_subscription_updated(db, event_data)\n    \n    elif event_type == \"customer.subscription.deleted\":\n        await StripeService.handle_subscription_deleted(db, event_data)\n    \n    elif event_type == \"invoice.payment_failed\":\n        await StripeService.handle_invoice_payment_failed(db, event_data)\n\n    return {\"status\": \"success\"}"
    },
    {
      "name": "event_loop",
      "file_path": "tests/conftest.py",
      "line_number": 29,
      "docstring": "Create an event loop for the test session.",
      "parameters": [],
      "return_type": "Generator[asyncio.AbstractEventLoop, None, None]",
      "decorators": [
        "pytest.fixture"
      ],
      "is_async": false,
      "source": "def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:\n    \"\"\"Create an event loop for the test session.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()"
    },
    {
      "name": "db_engine",
      "file_path": "tests/conftest.py",
      "line_number": 37,
      "docstring": "Create a test database engine.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "pytest_asyncio.fixture"
      ],
      "is_async": true,
      "source": "async def db_engine():\n    \"\"\"Create a test database engine.\"\"\"\n    engine = create_async_engine(\n        TEST_DATABASE_URL,\n        connect_args={\"check_same_thread\": False},\n        poolclass=StaticPool,\n    )\n    \n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    \n    yield engine\n    \n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n    \n    await engine.dispose()"
    },
    {
      "name": "db_session",
      "file_path": "tests/conftest.py",
      "line_number": 57,
      "docstring": "Create a test database session.",
      "parameters": [
        "db_engine"
      ],
      "return_type": "AsyncGenerator[AsyncSession, None]",
      "decorators": [
        "pytest_asyncio.fixture"
      ],
      "is_async": true,
      "source": "async def db_session(db_engine) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create a test database session.\"\"\"\n    async_session_maker = async_sessionmaker(\n        db_engine,\n        class_=AsyncSession,\n        expire_on_commit=False,\n        autocommit=False,\n        autoflush=False,\n    )\n    \n    async with async_session_maker() as session:\n        yield session"
    },
    {
      "name": "client",
      "file_path": "tests/conftest.py",
      "line_number": 72,
      "docstring": "Create a test client with database session override.",
      "parameters": [
        "db_session"
      ],
      "return_type": "AsyncGenerator[AsyncClient, None]",
      "decorators": [
        "pytest_asyncio.fixture"
      ],
      "is_async": true,
      "source": "async def client(db_session: AsyncSession) -> AsyncGenerator[AsyncClient, None]:\n    \"\"\"Create a test client with database session override.\"\"\"\n    \n    async def override_get_db() -> AsyncGenerator[AsyncSession, None]:\n        yield db_session\n    \n    app.dependency_overrides[get_db] = override_get_db\n    \n    async with AsyncClient(\n        transport=ASGITransport(app=app),\n        base_url=\"http://test\",\n    ) as ac:\n        yield ac\n    \n    app.dependency_overrides.clear()"
    },
    {
      "name": "test_user",
      "file_path": "tests/conftest.py",
      "line_number": 90,
      "docstring": "Create a test user.",
      "parameters": [
        "db_session"
      ],
      "return_type": "User",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_user(db_session: AsyncSession) -> User:\n    \"\"\"Create a test user.\"\"\"\n    user = User(\n        email=\"test@example.com\",\n        hashed_password=hash_password(\"testpassword123\"),\n        full_name=\"Test User\",\n        business_name=\"Test Business\",\n    )\n    db_session.add(user)\n    await db_session.commit()\n    await db_session.refresh(user)\n    return user"
    },
    {
      "name": "other_user",
      "file_path": "tests/conftest.py",
      "line_number": 105,
      "docstring": "Create another user for cross-user authorization tests.",
      "parameters": [
        "db_session"
      ],
      "return_type": "User",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def other_user(db_session: AsyncSession) -> User:\n    \"\"\"Create another user for cross-user authorization tests.\"\"\"\n    user = User(\n        email=\"other@example.com\",\n        hashed_password=hash_password(\"otherpassword123\"),\n        full_name=\"Other User\",\n        business_name=\"Other Business\",\n    )\n    db_session.add(user)\n    await db_session.commit()\n    await db_session.refresh(user)\n    return user"
    },
    {
      "name": "auth_headers",
      "file_path": "tests/conftest.py",
      "line_number": 120,
      "docstring": "Get authentication headers for test user.",
      "parameters": [
        "client",
        "test_user"
      ],
      "return_type": "dict[str, str]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def auth_headers(client: AsyncClient, test_user: User) -> dict[str, str]:\n    \"\"\"Get authentication headers for test user.\"\"\"\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        json={\"email\": \"test@example.com\", \"password\": \"testpassword123\"},\n    )\n    token = response.json()[\"access_token\"]\n    return {\"Authorization\": f\"Bearer {token}\"}"
    },
    {
      "name": "other_auth_headers",
      "file_path": "tests/conftest.py",
      "line_number": 136,
      "docstring": "Get authentication headers for the other user.",
      "parameters": [
        "client",
        "other_user"
      ],
      "return_type": "dict[str, str]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def other_auth_headers(client: AsyncClient, other_user: User) -> dict[str, str]:\n    \"\"\"Get authentication headers for the other user.\"\"\"\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        json={\"email\": \"other@example.com\", \"password\": \"otherpassword123\"},\n    )\n    token = response.json()[\"access_token\"]\n    return {\"Authorization\": f\"Bearer {token}\"}"
    },
    {
      "name": "test_client",
      "file_path": "tests/conftest.py",
      "line_number": 147,
      "docstring": "Create a test client owned by the test user.",
      "parameters": [
        "db_session",
        "test_user"
      ],
      "return_type": "Client",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_client(db_session: AsyncSession, test_user: User) -> Client:\n    \"\"\"Create a test client owned by the test user.\"\"\"\n    client_obj = Client(\n        user_id=test_user.id,\n        name=\"Test Client\",\n        email=\"client@example.com\",\n    )\n    db_session.add(client_obj)\n    await db_session.commit()\n    await db_session.refresh(client_obj)\n    return client_obj"
    },
    {
      "name": "other_user_client",
      "file_path": "tests/conftest.py",
      "line_number": 161,
      "docstring": "Create a client owned by the other user.",
      "parameters": [
        "db_session",
        "other_user"
      ],
      "return_type": "Client",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def other_user_client(db_session: AsyncSession, other_user: User) -> Client:\n    \"\"\"Create a client owned by the other user.\"\"\"\n    client_obj = Client(\n        user_id=other_user.id,\n        name=\"Other Client\",\n        email=\"otherclient@example.com\",\n    )\n    db_session.add(client_obj)\n    await db_session.commit()\n    await db_session.refresh(client_obj)\n    return client_obj"
    },
    {
      "name": "test_project",
      "file_path": "tests/conftest.py",
      "line_number": 175,
      "docstring": "Create a test project owned by the test user.",
      "parameters": [
        "db_session",
        "test_user",
        "test_client"
      ],
      "return_type": "Project",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_project(db_session: AsyncSession, test_user: User, test_client: Client) -> Project:\n    \"\"\"Create a test project owned by the test user.\"\"\"\n    project = Project(\n        user_id=test_user.id,\n        client_id=test_client.id,\n        name=\"Test Project\",\n        description=\"A test project for scope items\",\n    )\n    db_session.add(project)\n    await db_session.commit()\n    await db_session.refresh(project)\n    return project"
    },
    {
      "name": "other_user_project",
      "file_path": "tests/conftest.py",
      "line_number": 190,
      "docstring": "Create a project owned by a different user (for authorization tests).",
      "parameters": [
        "db_session",
        "other_user",
        "other_user_client"
      ],
      "return_type": "Project",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def other_user_project(db_session: AsyncSession, other_user: User, other_user_client: Client) -> Project:\n    \"\"\"Create a project owned by a different user (for authorization tests).\"\"\"\n    project = Project(\n        user_id=other_user.id,\n        client_id=other_user_client.id,\n        name=\"Other User's Project\",\n        description=\"Project owned by another user\",\n    )\n    db_session.add(project)\n    await db_session.commit()\n    await db_session.refresh(project)\n    return project"
    },
    {
      "name": "test_scope_item",
      "file_path": "tests/conftest.py",
      "line_number": 205,
      "docstring": "Create a single test scope item.",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "ScopeItem",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_scope_item(db_session: AsyncSession, test_project: Project) -> ScopeItem:\n    \"\"\"Create a single test scope item.\"\"\"\n    scope_item = ScopeItem(\n        project_id=test_project.id,\n        title=\"Test Task\",\n        description=\"Test description\",\n        order=0,\n        is_completed=False,\n        estimated_hours=Decimal(\"5.0\"),\n    )\n    db_session.add(scope_item)\n    await db_session.commit()\n    await db_session.refresh(scope_item)\n    return scope_item"
    },
    {
      "name": "scope_items_ordered",
      "file_path": "tests/conftest.py",
      "line_number": 222,
      "docstring": "Create multiple scope items in order.",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "list[ScopeItem]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def scope_items_ordered(\n    db_session: AsyncSession, test_project: Project\n) -> list[ScopeItem]:\n    \"\"\"Create multiple scope items in order.\"\"\"\n    items = []\n    for i, title in enumerate([\"Task 1\", \"Task 2\", \"Task 3\"]):\n        item = ScopeItem(\n            project_id=test_project.id,\n            title=title,\n            order=i,\n            is_completed=False,\n        )\n        db_session.add(item)\n        items.append(item)\n    \n    await db_session.commit()\n    for item in items:\n        await db_session.refresh(item)\n    return items"
    },
    {
      "name": "scope_items_abc",
      "file_path": "tests/conftest.py",
      "line_number": 244,
      "docstring": "Create three scope items A, B, C for reorder testing.",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "tuple[ScopeItem, ScopeItem, ScopeItem]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def scope_items_abc(\n    db_session: AsyncSession, test_project: Project\n) -> tuple[ScopeItem, ScopeItem, ScopeItem]:\n    \"\"\"Create three scope items A, B, C for reorder testing.\"\"\"\n    item_a = ScopeItem(project_id=test_project.id, title=\"Item A\", order=0)\n    item_b = ScopeItem(project_id=test_project.id, title=\"Item B\", order=1)\n    item_c = ScopeItem(project_id=test_project.id, title=\"Item C\", order=2)\n    \n    db_session.add_all([item_a, item_b, item_c])\n    await db_session.commit()\n    \n    await db_session.refresh(item_a)\n    await db_session.refresh(item_b)\n    await db_session.refresh(item_c)\n    \n    return item_a, item_b, item_c"
    },
    {
      "name": "scope_items_with_progress",
      "file_path": "tests/conftest.py",
      "line_number": 263,
      "docstring": "Create scope items with 1 of 3 completed (33.33% completion).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "list[ScopeItem]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def scope_items_with_progress(\n    db_session: AsyncSession, test_project: Project\n) -> list[ScopeItem]:\n    \"\"\"Create scope items with 1 of 3 completed (33.33% completion).\"\"\"\n    items = [\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 1\",\n            order=0,\n            is_completed=True,\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 2\",\n            order=1,\n            is_completed=False,\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 3\",\n            order=2,\n            is_completed=False,\n        ),\n    ]\n    \n    db_session.add_all(items)\n    await db_session.commit()\n    for item in items:\n        await db_session.refresh(item)\n    return items"
    },
    {
      "name": "scope_items_with_hours",
      "file_path": "tests/conftest.py",
      "line_number": 296,
      "docstring": "Create scope items with estimated hours (some completed).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "list[ScopeItem]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def scope_items_with_hours(\n    db_session: AsyncSession, test_project: Project\n) -> list[ScopeItem]:\n    \"\"\"Create scope items with estimated hours (some completed).\"\"\"\n    items = [\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 1\",\n            order=0,\n            is_completed=True,\n            estimated_hours=Decimal(\"5.0\"),\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 2\",\n            order=1,\n            is_completed=False,\n            estimated_hours=Decimal(\"10.0\"),\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 3\",\n            order=2,\n            is_completed=True,\n            estimated_hours=Decimal(\"3.0\"),\n        ),\n    ]\n    \n    db_session.add_all(items)\n    await db_session.commit()\n    for item in items:\n        await db_session.refresh(item)\n    return items"
    },
    {
      "name": "scope_items_all_completed",
      "file_path": "tests/conftest.py",
      "line_number": 332,
      "docstring": "Create scope items that are all completed (100% completion).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "list[ScopeItem]",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def scope_items_all_completed(\n    db_session: AsyncSession, test_project: Project\n) -> list[ScopeItem]:\n    \"\"\"Create scope items that are all completed (100% completion).\"\"\"\n    items = [\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 1\",\n            order=0,\n            is_completed=True,\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 2\",\n            order=1,\n            is_completed=True,\n        ),\n        ScopeItem(\n            project_id=test_project.id,\n            title=\"Task 3\",\n            order=2,\n            is_completed=True,\n        ),\n    ]\n    \n    db_session.add_all(items)\n    await db_session.commit()\n    for item in items:\n        await db_session.refresh(item)\n    return items"
    },
    {
      "name": "test_client_request",
      "file_path": "tests/conftest.py",
      "line_number": 370,
      "docstring": "Create a test client request (out of scope).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "ClientRequest",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_client_request(\n    db_session: AsyncSession, test_project: Project\n) -> ClientRequest:\n    \"\"\"Create a test client request (out of scope).\"\"\"\n    request = ClientRequest(\n        project_id=test_project.id,\n        title=\"Add new feature\",\n        content=\"Please add a new feature to the system that was not in the original scope.\",\n        classification=ScopeClassification.OUT_OF_SCOPE,\n        status=RequestStatus.ANALYZED,\n        analysis_reasoning=\"This request is out of scope because it involves new functionality not covered in the original project agreement.\",\n    )\n    db_session.add(request)\n    await db_session.commit()\n    await db_session.refresh(request)\n    return request"
    },
    {
      "name": "test_client_request_in_scope",
      "file_path": "tests/conftest.py",
      "line_number": 389,
      "docstring": "Create a test client request (in scope).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "ClientRequest",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_client_request_in_scope(\n    db_session: AsyncSession, test_project: Project\n) -> ClientRequest:\n    \"\"\"Create a test client request (in scope).\"\"\"\n    request = ClientRequest(\n        project_id=test_project.id,\n        title=\"Fix login bug\",\n        content=\"The login button is not working correctly on mobile devices.\",\n        classification=ScopeClassification.IN_SCOPE,\n        status=RequestStatus.ANALYZED,\n        analysis_reasoning=\"This is a bug fix which falls within the original project scope.\",\n    )\n    db_session.add(request)\n    await db_session.commit()\n    await db_session.refresh(request)\n    return request"
    },
    {
      "name": "test_client_request_pending",
      "file_path": "tests/conftest.py",
      "line_number": 408,
      "docstring": "Create a test client request (pending analysis).",
      "parameters": [
        "db_session",
        "test_project"
      ],
      "return_type": "ClientRequest",
      "decorators": [
        "fixture"
      ],
      "is_async": true,
      "source": "async def test_client_request_pending(\n    db_session: AsyncSession, test_project: Project\n) -> ClientRequest:\n    \"\"\"Create a test client request (pending analysis).\"\"\"\n    request = ClientRequest(\n        project_id=test_project.id,\n        title=\"New request pending review\",\n        content=\"I would like to discuss some changes to the dashboard.\",\n        classification=ScopeClassification.PENDING,\n        status=RequestStatus.NEW,\n    )\n    db_session.add(request)\n    await db_session.commit()\n    await db_session.refresh(request)\n    return request"
    },
    {
      "name": "override_get_db",
      "file_path": "tests/conftest.py",
      "line_number": 75,
      "docstring": null,
      "parameters": [],
      "return_type": "AsyncGenerator[AsyncSession, None]",
      "decorators": [],
      "is_async": true,
      "source": "    async def override_get_db() -> AsyncGenerator[AsyncSession, None]:\n        yield db_session"
    },
    {
      "name": "basic_scope_items",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 34,
      "docstring": "Basic scope items for testing.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def basic_scope_items():\n    \"\"\"Basic scope items for testing.\"\"\"\n    return [\n        ScopeItemDTO(\n            id=uuid.uuid4(),\n            title=\"Build login page\",\n            description=\"Create user authentication UI\",\n        ),\n        ScopeItemDTO(\n            id=uuid.uuid4(),\n            title=\"Create user dashboard\",\n            description=\"Main dashboard after login\",\n        ),\n    ]"
    },
    {
      "name": "single_scope_item",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 51,
      "docstring": "Single scope item for focused tests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def single_scope_item():\n    \"\"\"Single scope item for focused tests.\"\"\"\n    return [ScopeItemDTO(id=uuid.uuid4(), title=\"Implement user authentication system\")]"
    },
    {
      "name": "design_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 57,
      "docstring": "Scope for design-related tests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def design_scope():\n    \"\"\"Scope for design-related tests.\"\"\"\n    return [\n        ScopeItemDTO(\n            id=uuid.uuid4(), title=\"Design logo\", description=\"Company logo design\"\n        )\n    ]"
    },
    {
      "name": "header_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 67,
      "docstring": "Scope for revision tests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def header_scope():\n    \"\"\"Scope for revision tests.\"\"\"\n    return [ScopeItemDTO(id=uuid.uuid4(), title=\"Create blue header design\")]"
    },
    {
      "name": "ecommerce_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 73,
      "docstring": "Scope for e-commerce tests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def ecommerce_scope():\n    \"\"\"Scope for e-commerce tests.\"\"\"\n    return [ScopeItemDTO(id=uuid.uuid4(), title=\"Build e-commerce checkout\")]"
    },
    {
      "name": "api_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 79,
      "docstring": "Scope for multi-item tests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def api_scope():\n    \"\"\"Scope for multi-item tests.\"\"\"\n    return [\n        ScopeItemDTO(\n            id=uuid.uuid4(),\n            title=\"Build API endpoints\",\n            description=\"REST API development\",\n        ),\n        ScopeItemDTO(\n            id=uuid.uuid4(), title=\"Write documentation\", description=\"API docs\"\n        ),\n    ]"
    },
    {
      "name": "test_in_scope_exact_match",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 101,
      "docstring": "Test 1: Exact match returns IN_SCOPE with high confidence.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_in_scope_exact_match(self, basic_scope_items):\n        \"\"\"Test 1: Exact match returns IN_SCOPE with high confidence.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Working on the login page design\",\n            scope_items=basic_scope_items,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"in_scope\"\n        assert result.confidence >= 0.6\n        assert result.matched_scope_item_index == 0\n        assert result.matched_scope_item_id == basic_scope_items[0].id"
    },
    {
      "name": "test_in_scope_fuzzy_match",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 115,
      "docstring": "Test 2: Fuzzy match returns IN_SCOPE.",
      "parameters": [
        "self",
        "single_scope_item"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_in_scope_fuzzy_match(self, single_scope_item):\n        \"\"\"Test 2: Fuzzy match returns IN_SCOPE.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Working on implementing the user authentication system now\",\n            scope_items=single_scope_item,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"in_scope\"\n        assert result.confidence >= 0.5"
    },
    {
      "name": "test_out_of_scope_no_match",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 127,
      "docstring": "Test 3: No match with scope creep indicator.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_out_of_scope_no_match(self):\n        \"\"\"Test 3: No match with scope creep indicator.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you also build a mobile app?\",\n            scope_items=[\n                ScopeItemDTO(title=\"Build homepage\"),\n                ScopeItemDTO(title=\"Create contact form\"),\n            ],\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert result.confidence >= 0.7\n        assert \"also\" in result.scope_creep_indicators"
    },
    {
      "name": "test_out_of_scope_with_indicators",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 143,
      "docstring": "Test 4: Multiple scope creep indicators detected.",
      "parameters": [
        "self",
        "design_scope"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_out_of_scope_with_indicators(self, design_scope):\n        \"\"\"Test 4: Multiple scope creep indicators detected.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Quick addition - can you also create business cards? Shouldn't take long\",\n            scope_items=design_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"quick addition\" in result.scope_creep_indicators\n        assert \"also\" in result.scope_creep_indicators\n        assert \"shouldn't take long\" in result.scope_creep_indicators"
    },
    {
      "name": "test_clarification_needed",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 157,
      "docstring": "Test 5: Clarification question returns CLARIFICATION_NEEDED.",
      "parameters": [
        "self",
        "ecommerce_scope"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_clarification_needed(self, ecommerce_scope):\n        \"\"\"Test 5: Clarification question returns CLARIFICATION_NEEDED.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you explain what payment gateways you'll support?\",\n            scope_items=ecommerce_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"clarification_needed\""
    },
    {
      "name": "test_revision_request",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 168,
      "docstring": "Test 6: Revision request returns REVISION.",
      "parameters": [
        "self",
        "header_scope"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_revision_request(self, header_scope):\n        \"\"\"Test 6: Revision request returns REVISION.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Actually, can we change the blue header design to use red instead?\",\n            scope_items=header_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"revision\"\n        assert result.matched_scope_item_index == 0"
    },
    {
      "name": "test_empty_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 180,
      "docstring": "Test 7: Empty scope returns OUT_OF_SCOPE.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_empty_scope(self):\n        \"\"\"Test 7: Empty scope returns OUT_OF_SCOPE.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Build the homepage\",\n            scope_items=[],\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"no scope\" in result.reasoning.lower()"
    },
    {
      "name": "test_long_request_multiple_items",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 192,
      "docstring": "Test 8: Long request with scope creep indicators.",
      "parameters": [
        "self",
        "api_scope"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_long_request_multiple_items(self, api_scope):\n        \"\"\"Test 8: Long request with scope creep indicators.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"I need the API done by Friday. Also, can you add a mobile app?\",\n            scope_items=api_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"also\" in result.scope_creep_indicators"
    },
    {
      "name": "test_suggested_action_for_out_of_scope",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 204,
      "docstring": "Test 9: OUT_OF_SCOPE suggests proposal/quote.",
      "parameters": [
        "self",
        "design_scope"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_suggested_action_for_out_of_scope(self, design_scope):\n        \"\"\"Test 9: OUT_OF_SCOPE suggests proposal/quote.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you also build me a website?\",\n            scope_items=design_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"proposal\" in result.suggested_action.lower() or \"quote\" in result.suggested_action.lower()"
    },
    {
      "name": "test_confidence_ranges",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 216,
      "docstring": "Test 10: Confidence is always between 0.0 and 1.0.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_confidence_ranges(self, basic_scope_items):\n        \"\"\"Test 10: Confidence is always between 0.0 and 1.0.\"\"\"\n        test_requests = [\n            \"Working on the login page\",\n            \"Can you also build something else?\",\n            \"What do you mean by authentication?\",\n            \"Change it to red instead\",\n            \"Random unrelated text here\",\n        ]\n\n        for content in test_requests:\n            request = AnalysisRequest(\n                request_content=content,\n                scope_items=basic_scope_items,\n            )\n            result = analyze_with_rules(request)\n            assert 0.0 <= result.confidence <= 1.0"
    },
    {
      "name": "test_ai_analyzer_success",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 244,
      "docstring": "Test 11: Successful AI analysis.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_ai_analyzer_success(self, basic_scope_items):\n        \"\"\"Test 11: Successful AI analysis.\"\"\"\n        mock_response = {\n            \"choices\": [\n                {\n                    \"message\": {\n                        \"content\": json.dumps(\n                            {\n                                \"classification\": \"in_scope\",\n                                \"confidence\": 0.9,\n                                \"reasoning\": \"Matches login page scope.\",\n                                \"matched_scope_item_index\": 0,\n                                \"suggested_action\": \"Proceed.\",\n                                \"scope_creep_indicators\": [],\n                            }\n                        )\n                    }\n                }\n            ]\n        }\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_http_response = MagicMock()\n            mock_http_response.json.return_value = mock_response\n            mock_http_response.raise_for_status = MagicMock()\n            mock_client.post.return_value = mock_http_response\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert result.classification == \"in_scope\"\n            assert result.confidence == 0.9"
    },
    {
      "name": "test_ai_analyzer_fallback_on_error",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 285,
      "docstring": "Test 12: AI analyzer falls back to rules on error.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_ai_analyzer_fallback_on_error(self, basic_scope_items):\n        \"\"\"Test 12: AI analyzer falls back to rules on error.\"\"\"\n        import httpx\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_response = MagicMock()\n            mock_response.status_code = 500\n            mock_client.post.return_value = mock_response\n            mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(\n                \"Error\", request=MagicMock(), response=mock_response\n            )\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert isinstance(result, AnalysisResult)"
    },
    {
      "name": "test_ai_analyzer_invalid_response",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 310,
      "docstring": "Test 13: AI analyzer handles malformed JSON.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_ai_analyzer_invalid_response(self, basic_scope_items):\n        \"\"\"Test 13: AI analyzer handles malformed JSON.\"\"\"\n        mock_response = {\n            \"choices\": [{\"message\": {\"content\": \"This is not valid JSON!\"}}]\n        }\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_http_response = MagicMock()\n            mock_http_response.json.return_value = mock_response\n            mock_http_response.raise_for_status = MagicMock()\n            mock_client.post.return_value = mock_http_response\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert isinstance(result, AnalysisResult)"
    },
    {
      "name": "test_uses_rules_when_no_api_key",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 344,
      "docstring": "Test 14: Uses rules when no API key configured.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_uses_rules_when_no_api_key(self, basic_scope_items):\n        \"\"\"Test 14: Uses rules when no API key configured.\"\"\"\n        with patch(\"app.services.scope_analyzer.analyzer.settings\") as mock_settings:\n            mock_settings.OPENAI_API_KEY = \"\"\n            mock_settings.USE_AI_ANALYZER = False\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_scope(request)\n\n            assert isinstance(result, AnalysisResult)"
    },
    {
      "name": "test_uses_ai_when_configured",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 360,
      "docstring": "Test 15: Uses AI when configured.",
      "parameters": [
        "self",
        "basic_scope_items"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_uses_ai_when_configured(self, basic_scope_items):\n        \"\"\"Test 15: Uses AI when configured.\"\"\"\n        mock_ai_result = AnalysisResult(\n            classification=\"in_scope\",\n            confidence=0.95,\n            reasoning=\"AI determined in scope.\",\n            matched_scope_item_index=0,\n            matched_scope_item_id=None,\n            suggested_action=\"Proceed.\",\n            scope_creep_indicators=[],\n        )\n\n        with patch(\"app.services.scope_analyzer.analyzer.settings\") as mock_settings:\n            mock_settings.OPENAI_API_KEY = \"test-key\"\n            mock_settings.USE_AI_ANALYZER = True\n            mock_settings.OPENAI_MODEL = \"gpt-4\"\n\n            with patch(\n                \"app.services.scope_analyzer.analyzer.analyze_with_ai\",\n                return_value=mock_ai_result,\n            ) as mock_ai:\n                request = AnalysisRequest(\n                    request_content=\"Working on the login page\",\n                    scope_items=basic_scope_items,\n                )\n\n                result = await analyze_scope(request)\n\n                mock_ai.assert_called_once()\n                assert result.classification == \"in_scope\""
    },
    {
      "name": "test_classification_map_completeness",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 400,
      "docstring": "Ensure all classifications are mapped.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_classification_map_completeness(self):\n        \"\"\"Ensure all classifications are mapped.\"\"\"\n        from app.models.enums import ScopeClassification\n\n        expected = {\"in_scope\", \"out_of_scope\", \"clarification_needed\", \"revision\"}\n        assert set(CLASSIFICATION_MAP.keys()) == expected\n\n        # Each maps to a valid enum\n        for key, value in CLASSIFICATION_MAP.items():\n            assert isinstance(value, ScopeClassification)"
    },
    {
      "name": "test_to_client_request_update",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 415,
      "docstring": "Test converting result to DB update fields.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def test_to_client_request_update(self):\n        \"\"\"Test converting result to DB update fields.\"\"\"\n        scope_id = uuid.uuid4()\n        result = AnalysisResult(\n            classification=\"out_of_scope\",\n            confidence=0.85,\n            reasoning=\"Test reasoning\",\n            matched_scope_item_index=None,\n            matched_scope_item_id=scope_id,\n            suggested_action=\"Send proposal\",\n            scope_creep_indicators=[\"also\"],\n        )\n\n        fields = result.to_client_request_update()\n\n        assert fields[\"classification\"] == \"out_of_scope\"\n        assert fields[\"confidence\"] == Decimal(\"0.85\")\n        assert fields[\"analysis_reasoning\"] == \"Test reasoning\"\n        assert fields[\"suggested_action\"] == \"Send proposal\"\n        assert fields[\"linked_scope_item_id\"] == scope_id"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/project.py",
      "line_number": 92,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<Project {self.name}>\""
    },
    {
      "name": "load_dialect_impl",
      "file_path": "app/models/base.py",
      "line_number": 59,
      "docstring": null,
      "parameters": [
        "self",
        "dialect"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def load_dialect_impl(self, dialect):\n        # Use native UUID type for PostgreSQL\n        if dialect.name == 'postgresql':\n            return dialect.type_descriptor(postgresql.UUID())\n        # Use CHAR(32) (TEXT) for SQLite and others\n        return dialect.type_descriptor(CHAR(32))"
    },
    {
      "name": "process_bind_param",
      "file_path": "app/models/base.py",
      "line_number": 66,
      "docstring": null,
      "parameters": [
        "self",
        "value",
        "dialect"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def process_bind_param(self, value, dialect):\n        if value is None:\n            return value\n        # Ensure the value is converted to a string format SQLite can store\n        if isinstance(value, uuid.UUID):\n            if dialect.name != 'postgresql':\n                return value.hex\n        return value"
    },
    {
      "name": "process_result_value",
      "file_path": "app/models/base.py",
      "line_number": 75,
      "docstring": null,
      "parameters": [
        "self",
        "value",
        "dialect"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": false,
      "source": "    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        # Convert stored string back to Python UUID object\n        if dialect.name != 'postgresql':\n            return uuid.UUID(value)\n        return value"
    },
    {
      "name": "get_project_or_404",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 31,
      "docstring": "Helper to fetch project and verify ownership.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "Project",
      "decorators": [],
      "is_async": true,
      "source": "async def get_project_or_404(\n    project_id: UUID,\n    db: AsyncSession,\n    current_user: User,\n) -> Project:\n    \"\"\"Helper to fetch project and verify ownership.\"\"\"\n    result = await db.execute(\n        select(Project).where(\n            Project.id == project_id,\n            Project.user_id == current_user.id,\n        )\n    )\n    project = result.scalar_one_or_none()\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    return project"
    },
    {
      "name": "get_request_or_404",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 52,
      "docstring": "Helper to fetch client request and verify it belongs to project.",
      "parameters": [
        "request_id",
        "project_id",
        "db"
      ],
      "return_type": "ClientRequest",
      "decorators": [],
      "is_async": true,
      "source": "async def get_request_or_404(\n    request_id: UUID,\n    project_id: UUID,\n    db: AsyncSession,\n) -> ClientRequest:\n    \"\"\"Helper to fetch client request and verify it belongs to project.\"\"\"\n    result = await db.execute(\n        select(ClientRequest).where(\n            ClientRequest.id == request_id,\n            ClientRequest.project_id == project_id,\n        )\n    )\n    client_request = result.scalar_one_or_none()\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n    return client_request"
    },
    {
      "name": "get_project_scope_items",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 73,
      "docstring": "Fetch all scope items for a project.",
      "parameters": [
        "project_id",
        "db"
      ],
      "return_type": "list[ScopeItem]",
      "decorators": [],
      "is_async": true,
      "source": "async def get_project_scope_items(\n    project_id: UUID,\n    db: AsyncSession,\n) -> list[ScopeItem]:\n    \"\"\"Fetch all scope items for a project.\"\"\"\n    result = await db.execute(\n        select(ScopeItem).where(ScopeItem.project_id == project_id)\n    )\n    return list(result.scalars().all())"
    },
    {
      "name": "load_request_with_project",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 84,
      "docstring": "Load a client request with its project relationship for analysis.",
      "parameters": [
        "request_id",
        "project_id",
        "db"
      ],
      "return_type": "ClientRequest",
      "decorators": [],
      "is_async": true,
      "source": "async def load_request_with_project(\n    request_id: UUID,\n    project_id: UUID,\n    db: AsyncSession,\n) -> ClientRequest:\n    \"\"\"Load a client request with its project relationship for analysis.\"\"\"\n    from sqlalchemy.orm import selectinload\n    \n    result = await db.execute(\n        select(ClientRequest)\n        .options(selectinload(ClientRequest.project).selectinload(Project.scope_items))\n        .where(\n            ClientRequest.id == request_id,\n            ClientRequest.project_id == project_id,\n        )\n    )\n    client_request = result.scalar_one_or_none()\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n    return client_request"
    },
    {
      "name": "run_scope_analysis",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 109,
      "docstring": "Run scope analysis on a client request.\n\nReturns the analysis result and updates the client request in the database.",
      "parameters": [
        "client_request",
        "db"
      ],
      "return_type": "AnalyzeRequestResponse",
      "decorators": [],
      "is_async": true,
      "source": "async def run_scope_analysis(\n    client_request: ClientRequest,\n    db: AsyncSession,\n) -> AnalyzeRequestResponse:\n    \"\"\"\n    Run scope analysis on a client request.\n    \n    Returns the analysis result and updates the client request in the database.\n    \"\"\"\n    # Use the analyze_client_request function from your service\n    analysis_result = await analyze_client_request(\n        client_request=client_request,\n        session=db,\n        commit=True,\n    )\n    \n    return AnalyzeRequestResponse(\n        classification=client_request.classification,\n        confidence=float(client_request.confidence) if client_request.confidence else 0.0,\n        reasoning=client_request.analysis_reasoning or \"\",\n        matched_scope_item_id=client_request.linked_scope_item_id,\n        suggested_action=client_request.suggested_action or \"\",\n        scope_creep_indicators=analysis_result.scope_creep_indicators or [],\n    )"
    },
    {
      "name": "list_client_requests",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 141,
      "docstring": "List client requests for a project.\n\nSupports filtering by status and classification.",
      "parameters": [
        "project_id",
        "status",
        "classification",
        "skip",
        "limit",
        "db",
        "current_user"
      ],
      "return_type": "ClientRequestListResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def list_client_requests(\n    project_id: UUID,\n    status: Optional[RequestStatus] = None,\n    classification: Optional[ScopeClassification] = None,\n    skip: int = 0,\n    limit: int = 20,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestListResponse:\n    \"\"\"\n    List client requests for a project.\n    \n    Supports filtering by status and classification.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Build query\n    query = select(ClientRequest).where(ClientRequest.project_id == project_id)\n    count_query = select(func.count(ClientRequest.id)).where(\n        ClientRequest.project_id == project_id\n    )\n    \n    # Apply filters\n    if status is not None:\n        query = query.where(ClientRequest.status == status)\n        count_query = count_query.where(ClientRequest.status == status)\n    \n    if classification is not None:\n        query = query.where(ClientRequest.classification == classification)\n        count_query = count_query.where(ClientRequest.classification == classification)\n    \n    # Get total count\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    # Apply pagination and ordering\n    query = query.order_by(ClientRequest.created_at.desc()).offset(skip).limit(limit)\n    \n    # Execute query\n    result = await db.execute(query)\n    requests = list(result.scalars().all())\n    \n    return ClientRequestListResponse(\n        items=[ClientRequestResponse.model_validate(r) for r in requests],\n        total=total,\n        skip=skip,\n        limit=limit,\n    )"
    },
    {
      "name": "create_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 199,
      "docstring": "Create a new client request.\n\nIf auto_analyze is True (default), the request will be automatically\nanalyzed against the project's scope items.",
      "parameters": [
        "project_id",
        "request_data",
        "db",
        "current_user"
      ],
      "return_type": "ClientRequestResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_client_request_endpoint(\n    project_id: UUID,\n    request_data: ClientRequestCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"\n    Create a new client request.\n    \n    If auto_analyze is True (default), the request will be automatically\n    analyzed against the project's scope items.\n    \"\"\"\n    # Verify project ownership\n    project = await get_project_or_404(project_id, db, current_user)\n    \n    # Create the client request\n    client_request = ClientRequest(\n        project_id=project_id,\n        title=request_data.title,\n        content=request_data.content,\n        source=request_data.source,\n        status=RequestStatus.NEW,\n        classification=ScopeClassification.PENDING,\n    )\n    \n    db.add(client_request)\n    await db.commit()\n    await db.refresh(client_request)\n    \n    # Run auto-analysis if requested\n    if request_data.auto_analyze:\n        scope_items = await get_project_scope_items(project_id, db)\n        \n        if scope_items:\n            # Load the request with project relationship for analysis\n            client_request = await load_request_with_project(\n                client_request.id, project_id, db\n            )\n            await run_scope_analysis(client_request, db)\n        else:\n            # No scope items - mark as out of scope with note\n            client_request.classification = ScopeClassification.OUT_OF_SCOPE\n            client_request.analysis_reasoning = (\n                \"No scope items defined for this project. \"\n                \"Unable to determine if request is in scope.\"\n            )\n            client_request.suggested_action = (\n                \"Define project scope items before analyzing requests.\"\n            )\n            client_request.status = RequestStatus.ANALYZED\n            await db.commit()\n            await db.refresh(client_request)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "name": "get_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 261,
      "docstring": "Get a single client request.",
      "parameters": [
        "project_id",
        "request_id",
        "db",
        "current_user"
      ],
      "return_type": "ClientRequestResponse",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_client_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"Get a single client request.\"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get the request\n    client_request = await get_request_or_404(request_id, project_id, db)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "name": "update_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 283,
      "docstring": "Update a client request.\n\nAllows updating title, content, source, status, and linked scope item.",
      "parameters": [
        "project_id",
        "request_id",
        "request_data",
        "db",
        "current_user"
      ],
      "return_type": "ClientRequestResponse",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_client_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    request_data: ClientRequestUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"\n    Update a client request.\n    \n    Allows updating title, content, source, status, and linked scope item.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get the request\n    client_request = await get_request_or_404(request_id, project_id, db)\n    \n    # Update fields that were provided\n    update_data = request_data.model_dump(exclude_unset=True)\n    \n    # Validate linked_scope_item_id if provided\n    if \"linked_scope_item_id\" in update_data and update_data[\"linked_scope_item_id\"]:\n        scope_item_result = await db.execute(\n            select(ScopeItem).where(\n                ScopeItem.id == update_data[\"linked_scope_item_id\"],\n                ScopeItem.project_id == project_id,\n            )\n        )\n        if not scope_item_result.scalar_one_or_none():\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Scope item not found in this project\",\n            )\n    \n    for field, value in update_data.items():\n        setattr(client_request, field, value)\n    \n    await db.commit()\n    await db.refresh(client_request)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "name": "analyze_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 333,
      "docstring": "Manually trigger scope analysis for a client request.\n\nThis is useful for requests created with auto_analyze=False\nor to re-analyze after scope items have been updated.",
      "parameters": [
        "project_id",
        "request_id",
        "db",
        "current_user"
      ],
      "return_type": "AnalyzeRequestResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def analyze_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> AnalyzeRequestResponse:\n    \"\"\"\n    Manually trigger scope analysis for a client request.\n    \n    This is useful for requests created with auto_analyze=False\n    or to re-analyze after scope items have been updated.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get project scope items\n    scope_items = await get_project_scope_items(project_id, db)\n    \n    if not scope_items:\n        # Handle case with no scope items\n        client_request = await get_request_or_404(request_id, project_id, db)\n        client_request.classification = ScopeClassification.OUT_OF_SCOPE\n        client_request.analysis_reasoning = (\n            \"No scope items defined for this project. \"\n            \"Unable to determine if request is in scope.\"\n        )\n        client_request.suggested_action = (\n            \"Define project scope items before analyzing requests.\"\n        )\n        client_request.status = RequestStatus.ANALYZED\n        client_request.confidence = 0.0\n        await db.commit()\n        await db.refresh(client_request)\n        \n        return AnalyzeRequestResponse(\n            classification=ScopeClassification.OUT_OF_SCOPE,\n            confidence=0.0,\n            reasoning=client_request.analysis_reasoning,\n            matched_scope_item_id=None,\n            suggested_action=client_request.suggested_action,\n            scope_creep_indicators=[],\n        )\n    \n    # Load request with project relationship and run analysis\n    client_request = await load_request_with_project(request_id, project_id, db)\n    return await run_scope_analysis(client_request, db)"
    },
    {
      "name": "analyze_scope",
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 10,
      "docstring": "Main entry point for scope analysis.\n\nUses AI analyzer if configured, otherwise falls back to rules.",
      "parameters": [
        "request"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": true,
      "source": "async def analyze_scope(request: AnalysisRequest) -> AnalysisResult:\n    \"\"\"\n    Main entry point for scope analysis.\n\n    Uses AI analyzer if configured, otherwise falls back to rules.\n    \"\"\"\n    if settings.use_ai_analyzer and settings.openai_api_key:\n        return await analyze_with_ai(\n            request,\n            settings.openai_api_key,\n            model=getattr(settings, \"openai_model\", \"gpt-4\"),\n        )\n    return analyze_with_rules(request)"
    },
    {
      "name": "analyze_scope_sync",
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 25,
      "docstring": "Synchronous version that always uses rules-based analyzer.",
      "parameters": [
        "request"
      ],
      "return_type": "AnalysisResult",
      "decorators": [],
      "is_async": false,
      "source": "def analyze_scope_sync(request: AnalysisRequest) -> AnalysisResult:\n    \"\"\"\n    Synchronous version that always uses rules-based analyzer.\n    \"\"\"\n    return analyze_with_rules(request)"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/scope_item.py",
      "line_number": 66,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<ScopeItem {self.title}>\""
    },
    {
      "name": "mock_user",
      "file_path": "tests/unit/test_users.py",
      "line_number": 15,
      "docstring": "Create a mock user for testing.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def mock_user():\n    \"\"\"Create a mock user for testing.\"\"\"\n    user = MagicMock()\n    user.id = \"test-user-id-123\"\n    user.email = \"test@example.com\"\n    user.full_name = \"Test User\"\n    user.business_name = \"Test Business\"\n    user.is_active = True\n    user.created_at = datetime(2024, 1, 15, 10, 30, 0, tzinfo=timezone.utc)\n    return user"
    },
    {
      "name": "mock_db",
      "file_path": "tests/unit/test_users.py",
      "line_number": 28,
      "docstring": "Create a mock database session.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def mock_db():\n    \"\"\"Create a mock database session.\"\"\"\n    db = AsyncMock()\n    return db"
    },
    {
      "name": "auth_headers",
      "file_path": "tests/unit/test_users.py",
      "line_number": 35,
      "docstring": "Return authorization headers for authenticated requests.",
      "parameters": [],
      "return_type": null,
      "decorators": [
        "fixture"
      ],
      "is_async": false,
      "source": "def auth_headers():\n    \"\"\"Return authorization headers for authenticated requests.\"\"\"\n    return {\"Authorization\": \"Bearer valid-test-token\"}"
    },
    {
      "name": "test_get_profile_success",
      "file_path": "tests/unit/test_users.py",
      "line_number": 44,
      "docstring": "Test that an authenticated user can successfully retrieve their profile.\nVerifies all fields are returned including created_at.",
      "parameters": [
        "self",
        "mock_user",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_profile_success(self, mock_user, auth_headers):\n        \"\"\"\n        Test that an authenticated user can successfully retrieve their profile.\n        Verifies all fields are returned including created_at.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.get(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"id\"] == \"test-user-id-123\"\n            assert data[\"email\"] == \"test@example.com\"\n            assert data[\"full_name\"] == \"Test User\"\n            assert data[\"business_name\"] == \"Test Business\"\n            assert data[\"is_active\"] is True\n            assert \"created_at\" in data\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "test_get_profile_unauthorized",
      "file_path": "tests/unit/test_users.py",
      "line_number": 74,
      "docstring": "Test that unauthenticated requests are rejected.\nExpected: 403 Forbidden.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_profile_unauthorized(self):\n        \"\"\"\n        Test that unauthenticated requests are rejected.\n        Expected: 403 Forbidden.\n        \"\"\"\n        app.dependency_overrides.clear()\n\n        async with AsyncClient(\n            transport=ASGITransport(app=app),\n            base_url=\"http://test\",\n        ) as client:\n            response = await client.get(\"/api/v1/users/profile\")\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "test_update_profile_full_name",
      "file_path": "tests/unit/test_users.py",
      "line_number": 94,
      "docstring": "Test updating only the full_name field.\nVerifies full_name changes while other fields remain unchanged.",
      "parameters": [
        "self",
        "mock_user",
        "mock_db",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_full_name(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating only the full_name field.\n        Verifies full_name changes while other fields remain unchanged.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.full_name = \"Updated Name\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"full_name\": \"Updated Name\"},\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"full_name\"] == \"Updated Name\"\n            assert data[\"email\"] == \"test@example.com\"\n            assert data[\"business_name\"] == \"Test Business\"\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "test_update_profile_business_name",
      "file_path": "tests/unit/test_users.py",
      "line_number": 129,
      "docstring": "Test updating only the business_name field.\nVerifies business_name changes while other fields remain unchanged.",
      "parameters": [
        "self",
        "mock_user",
        "mock_db",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_business_name(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating only the business_name field.\n        Verifies business_name changes while other fields remain unchanged.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.business_name = \"New Business LLC\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"business_name\": \"New Business LLC\"},\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"business_name\"] == \"New Business LLC\"\n            assert data[\"full_name\"] == \"Test User\"\n            assert data[\"email\"] == \"test@example.com\"\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "test_update_profile_both_fields",
      "file_path": "tests/unit/test_users.py",
      "line_number": 164,
      "docstring": "Test updating both full_name and business_name simultaneously.\nVerifies both fields are updated correctly.",
      "parameters": [
        "self",
        "mock_user",
        "mock_db",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_both_fields(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating both full_name and business_name simultaneously.\n        Verifies both fields are updated correctly.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.full_name = \"New Full Name\"\n            obj.business_name = \"New Business Name\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\n                        \"full_name\": \"New Full Name\",\n                        \"business_name\": \"New Business Name\",\n                    },\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"full_name\"] == \"New Full Name\"\n            assert data[\"business_name\"] == \"New Business Name\"\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "test_update_profile_unauthorized",
      "file_path": "tests/unit/test_users.py",
      "line_number": 202,
      "docstring": "Test that unauthenticated update requests are rejected.\nExpected: 403 Forbidden.",
      "parameters": [
        "self"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_unauthorized(self):\n        \"\"\"\n        Test that unauthenticated update requests are rejected.\n        Expected: 403 Forbidden.\n        \"\"\"\n        app.dependency_overrides.clear()\n\n        async with AsyncClient(\n            transport=ASGITransport(app=app),\n            base_url=\"http://test\",\n        ) as client:\n            response = await client.patch(\n                \"/api/v1/users/profile\",\n                json={\"full_name\": \"Hacker\"},\n            )\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "test_update_profile_empty_body",
      "file_path": "tests/unit/test_users.py",
      "line_number": 221,
      "docstring": "Test that empty update requests are rejected.\nExpected: 400 Bad Request.",
      "parameters": [
        "self",
        "mock_user",
        "mock_db",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_empty_body(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test that empty update requests are rejected.\n        Expected: 400 Bad Request.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={},\n                )\n\n            assert response.status_code == status.HTTP_400_BAD_REQUEST\n            assert \"No fields to update\" in response.json()[\"detail\"]\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "test_update_profile_full_name_validation",
      "file_path": "tests/unit/test_users.py",
      "line_number": 246,
      "docstring": "Test that full_name validation is enforced (min_length=1).\nExpected: 422 Unprocessable Entity for empty string.",
      "parameters": [
        "self",
        "mock_user",
        "mock_db",
        "auth_headers"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_profile_full_name_validation(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test that full_name validation is enforced (min_length=1).\n        Expected: 422 Unprocessable Entity for empty string.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"full_name\": \"\"},\n                )\n\n            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "mock_refresh",
      "file_path": "tests/unit/test_users.py",
      "line_number": 100,
      "docstring": null,
      "parameters": [
        "obj"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def mock_refresh(obj):\n            obj.full_name = \"Updated Name\""
    },
    {
      "name": "mock_refresh",
      "file_path": "tests/unit/test_users.py",
      "line_number": 135,
      "docstring": null,
      "parameters": [
        "obj"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def mock_refresh(obj):\n            obj.business_name = \"New Business LLC\""
    },
    {
      "name": "mock_refresh",
      "file_path": "tests/unit/test_users.py",
      "line_number": 170,
      "docstring": null,
      "parameters": [
        "obj"
      ],
      "return_type": null,
      "decorators": [],
      "is_async": true,
      "source": "        async def mock_refresh(obj):\n            obj.full_name = \"New Full Name\"\n            obj.business_name = \"New Business Name\""
    },
    {
      "name": "from_db_model",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 37,
      "docstring": "Create DTO from SQLAlchemy ScopeItem model.",
      "parameters": [
        "cls",
        "db_scope_item"
      ],
      "return_type": "'ScopeItemDTO'",
      "decorators": [
        "classmethod"
      ],
      "is_async": false,
      "source": "    def from_db_model(cls, db_scope_item: \"DBScopeItem\") -> \"ScopeItemDTO\":\n        \"\"\"Create DTO from SQLAlchemy ScopeItem model.\"\"\"\n        return cls(\n            id=db_scope_item.id,\n            title=db_scope_item.title,\n            description=db_scope_item.description,\n            order=db_scope_item.order,\n        )"
    },
    {
      "name": "from_client_request",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 55,
      "docstring": "Create an AnalysisRequest from a ClientRequest and its Project.\n\nArgs:\n    client_request: SQLAlchemy ClientRequest model instance\n    project: Optional Project model (uses client_request.project if not provided)\n\nReturns:\n    AnalysisRequest ready for analysis",
      "parameters": [
        "cls",
        "client_request",
        "project"
      ],
      "return_type": "'AnalysisRequest'",
      "decorators": [
        "classmethod"
      ],
      "is_async": false,
      "source": "    def from_client_request(\n        cls,\n        client_request: \"ClientRequest\",\n        project: \"Project | None\" = None,\n    ) -> \"AnalysisRequest\":\n        \"\"\"\n        Create an AnalysisRequest from a ClientRequest and its Project.\n\n        Args:\n            client_request: SQLAlchemy ClientRequest model instance\n            project: Optional Project model (uses client_request.project if not provided)\n\n        Returns:\n            AnalysisRequest ready for analysis\n        \"\"\"\n        proj = project or client_request.project\n        scope_items = [\n            ScopeItemDTO.from_db_model(item)\n            for item in proj.scope_items\n        ]\n        return cls(\n            request_content=client_request.content,\n            scope_items=scope_items,\n            project_context=proj.description,\n        )"
    },
    {
      "name": "to_client_request_update",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 93,
      "docstring": "Convert result to fields for updating a ClientRequest model.\n\nReturns:\n    Dict with fields compatible with ClientRequest model",
      "parameters": [
        "self"
      ],
      "return_type": "dict",
      "decorators": [],
      "is_async": false,
      "source": "    def to_client_request_update(self) -> dict:\n        \"\"\"\n        Convert result to fields for updating a ClientRequest model.\n\n        Returns:\n            Dict with fields compatible with ClientRequest model\n        \"\"\"\n        return {\n            \"classification\": self.classification,\n            \"confidence\": Decimal(str(round(self.confidence, 2))),\n            \"analysis_reasoning\": self.reasoning,\n            \"suggested_action\": self.suggested_action,\n            \"linked_scope_item_id\": self.matched_scope_item_id,\n        }"
    },
    {
      "name": "test_create_proposal_success",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 17,
      "docstring": "Create proposal manually and verify all fields.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_proposal_success(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create proposal manually and verify all fields.\"\"\"\n        proposal_data = {\n            \"title\": \"New Feature Proposal\",\n            \"description\": \"This proposal outlines the new feature development\",\n            \"amount\": \"1500.00\",\n            \"estimated_hours\": \"20.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == proposal_data[\"title\"]\n        assert data[\"description\"] == proposal_data[\"description\"]\n        assert Decimal(data[\"amount\"]) == Decimal(proposal_data[\"amount\"])\n        assert Decimal(data[\"estimated_hours\"]) == Decimal(proposal_data[\"estimated_hours\"])\n        assert data[\"status\"] == ProposalStatus.DRAFT.value\n        assert data[\"source_request_id\"] is None\n        assert data[\"sent_at\"] is None\n        assert data[\"responded_at\"] is None"
    },
    {
      "name": "test_create_proposal_from_request",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 50,
      "docstring": "Create from OUT_OF_SCOPE request, verify title auto-generated and request linked.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_client_request"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_proposal_from_request(\n        self, client: AsyncClient, auth_headers: dict, test_project, test_client_request\n    ):\n        \"\"\"Create from OUT_OF_SCOPE request, verify title auto-generated and request linked.\"\"\"\n        proposal_data = {\n            \"source_request_id\": str(test_client_request.id),\n            \"amount\": \"2000.00\",\n            \"estimated_hours\": \"25.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{test_client_request.id}/create-proposal\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == f\"Proposal: {test_client_request.title}\"\n        assert data[\"source_request_id\"] == str(test_client_request.id)\n        assert test_client_request.content in data[\"description\"]\n        assert Decimal(data[\"amount\"]) == Decimal(proposal_data[\"amount\"])"
    },
    {
      "name": "test_create_proposal_from_in_scope_request",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 74,
      "docstring": "Create from IN_SCOPE request - should still work (user's choice).",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "test_client_request_in_scope"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_proposal_from_in_scope_request(\n        self, client: AsyncClient, auth_headers: dict, test_project, test_client_request_in_scope\n    ):\n        \"\"\"Create from IN_SCOPE request - should still work (user's choice).\"\"\"\n        proposal_data = {\n            \"source_request_id\": str(test_client_request_in_scope.id),\n            \"amount\": \"500.00\",\n            \"estimated_hours\": \"5.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{test_client_request_in_scope.id}/create-proposal\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        # Should succeed - it's the user's choice to create proposals for any request\n        assert response.status_code == status.HTTP_201_CREATED"
    },
    {
      "name": "test_list_proposals",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 98,
      "docstring": "Create multiple proposals and verify list returns all.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_proposals(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create multiple proposals and verify list returns all.\"\"\"\n        # Create multiple proposals first\n        proposals_to_create = [\n            {\"title\": \"Proposal 1\", \"description\": \"Desc 1\", \"amount\": \"1000.00\"},\n            {\"title\": \"Proposal 2\", \"description\": \"Desc 2\", \"amount\": \"2000.00\"},\n            {\"title\": \"Proposal 3\", \"description\": \"Desc 3\", \"amount\": \"3000.00\"},\n        ]\n        \n        for proposal_data in proposals_to_create:\n            await client.post(\n                f\"/api/v1/projects/{test_project.id}/proposals\",\n                json=proposal_data,\n                headers=auth_headers,\n            )\n        \n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data) >= len(proposals_to_create)"
    },
    {
      "name": "test_list_proposals_with_status_filter",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 126,
      "docstring": "Filter proposals by status.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_proposals_with_status_filter(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Filter proposals by status.\"\"\"\n        # Create a draft proposal\n        await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Draft\", \"description\": \"Draft desc\", \"amount\": \"100.00\"},\n            headers=auth_headers,\n        )\n        \n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals?status=draft\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        for proposal in data:\n            assert proposal[\"status\"] == \"draft\""
    },
    {
      "name": "test_update_proposal_amount",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 152,
      "docstring": "Update amount and verify change.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_proposal_amount(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Update amount and verify change.\"\"\"\n        # First create a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Original Title\",\n                \"description\": \"Original description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Update the amount\n        update_data = {\"amount\": \"1500.00\"}\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            json=update_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert Decimal(data[\"amount\"]) == Decimal(\"1500.00\")"
    },
    {
      "name": "test_update_status_to_accepted",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 182,
      "docstring": "Update status to ACCEPTED, verify responded_at is set automatically.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_update_status_to_accepted(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Update status to ACCEPTED, verify responded_at is set automatically.\"\"\"\n        # Create and send a proposal first\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        send_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_response.status_code == status.HTTP_200_OK\n        \n        # Update status to accepted\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            json={\"status\": \"accepted\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"status\"] == ProposalStatus.ACCEPTED.value\n        assert data[\"responded_at\"] is not None"
    },
    {
      "name": "test_send_proposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 223,
      "docstring": "Call /send endpoint, verify status=SENT and sent_at set.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_send_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Call /send endpoint, verify status=SENT and sent_at set.\"\"\"\n        # Create a proposal first\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"status\"] == ProposalStatus.SENT.value\n        assert data[\"sent_at\"] is not None"
    },
    {
      "name": "test_send_already_sent",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 252,
      "docstring": "Try to send already-sent proposal - expect 400.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_send_already_sent(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Try to send already-sent proposal - expect 400.\"\"\"\n        # Create and send a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it first time\n        first_send = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert first_send.status_code == status.HTTP_200_OK\n        \n        # Try to send again\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"already\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "test_get_stats",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 290,
      "docstring": "Create proposals with various statuses and verify stats calculations.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_stats(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create proposals with various statuses and verify stats calculations.\"\"\"\n        # Create proposals with different statuses\n        # Draft\n        draft_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Draft 1\", \"description\": \"Desc\", \"amount\": \"100.00\"},\n            headers=auth_headers,\n        )\n        assert draft_resp.status_code == status.HTTP_201_CREATED\n        \n        # Sent\n        sent_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Sent 1\", \"description\": \"Desc\", \"amount\": \"200.00\"},\n            headers=auth_headers,\n        )\n        assert sent_response.status_code == status.HTTP_201_CREATED\n        sent_id = sent_response.json()[\"id\"]\n        send_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{sent_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_resp.status_code == status.HTTP_200_OK\n        \n        # Accepted (must be sent first)\n        accepted_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Accepted 1\", \"description\": \"Desc\", \"amount\": \"500.00\"},\n            headers=auth_headers,\n        )\n        assert accepted_response.status_code == status.HTTP_201_CREATED\n        accepted_id = accepted_response.json()[\"id\"]\n        await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{accepted_id}/send\",\n            headers=auth_headers,\n        )\n        await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{accepted_id}\",\n            json={\"status\": \"accepted\"},\n            headers=auth_headers,\n        )\n        \n        # Get stats\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/stats\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_proposals\"] >= 3\n        assert data[\"draft_count\"] >= 1\n        assert data[\"sent_count\"] >= 1\n        assert data[\"accepted_count\"] >= 1\n        assert Decimal(data[\"total_amount_accepted\"]) >= Decimal(\"500.00\")"
    },
    {
      "name": "test_delete_proposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 354,
      "docstring": "Delete draft proposal and verify it's deleted.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Delete draft proposal and verify it's deleted.\"\"\"\n        # Create a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"To Delete\",\n                \"description\": \"This will be deleted\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Delete it\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify it's gone\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_delete_sent_proposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 387,
      "docstring": "Try to delete sent proposal - expect 400.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_delete_sent_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Try to delete sent proposal - expect 400.\"\"\"\n        # Create and send a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Sent Proposal\",\n                \"description\": \"This was sent\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        send_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_resp.status_code == status.HTTP_200_OK\n        \n        # Try to delete\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"sent\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "test_get_nonexistent_proposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 425,
      "docstring": "Get a proposal that doesn't exist.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_get_nonexistent_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Get a proposal that doesn't exist.\"\"\"\n        fake_id = str(uuid.uuid4())\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/{fake_id}\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_proposal_in_wrong_project",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 437,
      "docstring": "Try to access proposal from a different user's project.",
      "parameters": [
        "self",
        "client",
        "auth_headers",
        "test_project",
        "other_user_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_proposal_in_wrong_project(\n        self, client: AsyncClient, auth_headers: dict, test_project, other_user_project\n    ):\n        \"\"\"Try to access proposal from a different user's project.\"\"\"\n        # Create a proposal in the test user's project\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test\",\n                \"description\": \"Test\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Try to access from a different user's project (should fail - not found because user doesn't own it)\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        # Should return 404 (project not found for this user)\n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "test_list_proposals_unauthorized",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 467,
      "docstring": "Try to list proposals without auth - expect 403.",
      "parameters": [
        "self",
        "client",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_list_proposals_unauthorized(\n        self, client: AsyncClient, test_project\n    ):\n        \"\"\"Try to list proposals without auth - expect 403.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n        )\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "test_create_proposal_unauthorized",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 477,
      "docstring": "Try to create proposal without auth - expect 403.",
      "parameters": [
        "self",
        "client",
        "test_project"
      ],
      "return_type": null,
      "decorators": [
        "asyncio"
      ],
      "is_async": true,
      "source": "    async def test_create_proposal_unauthorized(\n        self, client: AsyncClient, test_project\n    ):\n        \"\"\"Try to create proposal without auth - expect 403.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Test\", \"description\": \"Test\", \"amount\": \"100.00\"},\n        )\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "lifespan",
      "file_path": "app/main.py",
      "line_number": 19,
      "docstring": "Application lifespan handler for startup/shutdown events.",
      "parameters": [
        "app"
      ],
      "return_type": "AsyncIterator[None]",
      "decorators": [
        "asynccontextmanager"
      ],
      "is_async": true,
      "source": "async def lifespan(app: FastAPI) -> AsyncIterator[None]:\n    \"\"\"Application lifespan handler for startup/shutdown events.\"\"\"\n    # Startup\n    await init_db()\n    yield\n    # Shutdown\n    await close_db()"
    },
    {
      "name": "create_app",
      "file_path": "app/main.py",
      "line_number": 28,
      "docstring": "Create and configure the FastAPI application.",
      "parameters": [],
      "return_type": "FastAPI",
      "decorators": [],
      "is_async": false,
      "source": "def create_app() -> FastAPI:\n    \"\"\"Create and configure the FastAPI application.\"\"\"\n    \n    app = FastAPI(\n        title=settings.app_name,\n        version=settings.app_version,\n        description=\"Detect scope creep and protect your freelance earnings\",\n        docs_url=\"/docs\" if settings.debug else None,\n        redoc_url=\"/redoc\" if settings.debug else None,\n        lifespan=lifespan,\n    )\n    \n    # CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=settings.cors_origins,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    \n    # Include API router\n    app.include_router(api_router, prefix=settings.api_v1_prefix)\n    \n    return app"
    },
    {
      "name": "root",
      "file_path": "app/main.py",
      "line_number": 60,
      "docstring": "Root endpoint with API info.",
      "parameters": [],
      "return_type": "dict",
      "decorators": [
        "app.get"
      ],
      "is_async": true,
      "source": "async def root() -> dict:\n    \"\"\"Root endpoint with API info.\"\"\"\n    return {\n        \"app\": settings.app_name,\n        \"version\": settings.app_version,\n        \"docs\": f\"{settings.api_v1_prefix}/docs\" if settings.debug else \"Disabled in production\",\n    }"
    },
    {
      "name": "__repr__",
      "file_path": "app/models/user.py",
      "line_number": 62,
      "docstring": null,
      "parameters": [
        "self"
      ],
      "return_type": "str",
      "decorators": [],
      "is_async": false,
      "source": "    def __repr__(self) -> str:\n        return f\"<User {self.email}>\""
    },
    {
      "name": "verify_project_access",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 25,
      "docstring": "Verify the current user has access to the specified project.\n\nArgs:\n    project_id: The ID of the project to verify access for.\n    db: Database session.\n    current_user: The currently authenticated user.\n    \nReturns:\n    The Project object if access is verified.\n    \nRaises:\n    HTTPException: 404 if project not found or user doesn't have access.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "Project",
      "decorators": [],
      "is_async": true,
      "source": "async def verify_project_access(\n    project_id: str,\n    db: AsyncSession,\n    current_user: User,\n) -> Project:\n    \"\"\"\n    Verify the current user has access to the specified project.\n    \n    Args:\n        project_id: The ID of the project to verify access for.\n        db: Database session.\n        current_user: The currently authenticated user.\n        \n    Returns:\n        The Project object if access is verified.\n        \n    Raises:\n        HTTPException: 404 if project not found or user doesn't have access.\n    \"\"\"\n    try:\n        uuid_project_id = UUID(project_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    result = await db.execute(\n        select(Project).where(\n            Project.id == uuid_project_id,\n            Project.user_id == current_user.id,\n        )\n    )\n    project = result.scalar_one_or_none()\n    \n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    return project"
    },
    {
      "name": "get_scope_item_or_404",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 69,
      "docstring": "Get a scope item by ID or raise 404.\n\nArgs:\n    item_id: The ID of the scope item.\n    project_id: The ID of the project the item belongs to.\n    db: Database session.\n    \nReturns:\n    The ScopeItem object if found.\n    \nRaises:\n    HTTPException: 404 if scope item not found.",
      "parameters": [
        "item_id",
        "project_id",
        "db"
      ],
      "return_type": "ScopeItem",
      "decorators": [],
      "is_async": true,
      "source": "async def get_scope_item_or_404(\n    item_id: str,\n    project_id: str,\n    db: AsyncSession,\n) -> ScopeItem:\n    \"\"\"\n    Get a scope item by ID or raise 404.\n    \n    Args:\n        item_id: The ID of the scope item.\n        project_id: The ID of the project the item belongs to.\n        db: Database session.\n        \n    Returns:\n        The ScopeItem object if found.\n        \n    Raises:\n        HTTPException: 404 if scope item not found.\n    \"\"\"\n    try:\n        uuid_item_id = UUID(item_id)\n        uuid_project_id = UUID(project_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Scope item not found\",\n        )\n    \n    result = await db.execute(\n        select(ScopeItem).where(\n            ScopeItem.id == uuid_item_id,\n            ScopeItem.project_id == uuid_project_id,\n        )\n    )\n    scope_item = result.scalar_one_or_none()\n    \n    if not scope_item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Scope item not found\",\n        )\n    \n    return scope_item"
    },
    {
      "name": "list_scope_items",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 120,
      "docstring": "List all scope items for a project, ordered by order field.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "list[ScopeItemResponse]",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def list_scope_items(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[ScopeItemResponse]:\n    \"\"\"List all scope items for a project, ordered by order field.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    result = await db.execute(\n        select(ScopeItem)\n        .where(ScopeItem.project_id == UUID(project_id))\n        .order_by(ScopeItem.order)\n    )\n    scope_items = result.scalars().all()\n    \n    return [\n        ScopeItemResponse(\n            id=str(item.id),\n            project_id=str(item.project_id),\n            title=item.title,\n            description=item.description,\n            order=item.order,\n            is_completed=item.is_completed,\n            estimated_hours=item.estimated_hours,\n            created_at=item.created_at,\n            updated_at=item.updated_at,\n        )\n        for item in scope_items\n    ]"
    },
    {
      "name": "create_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 158,
      "docstring": "Create a new scope item for a project.",
      "parameters": [
        "project_id",
        "scope_item_in",
        "db",
        "current_user"
      ],
      "return_type": "ScopeItemResponse",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def create_scope_item(\n    project_id: str,\n    scope_item_in: ScopeItemCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeItemResponse:\n    \"\"\"Create a new scope item for a project.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get the max order for existing items\n    result = await db.execute(\n        select(func.coalesce(func.max(ScopeItem.order), -1)).where(\n            ScopeItem.project_id == UUID(project_id)\n        )\n    )\n    max_order = result.scalar()\n    new_order = max_order + 1\n    \n    # Create the new scope item\n    scope_item = ScopeItem(\n        project_id=UUID(project_id),\n        title=scope_item_in.title,\n        description=scope_item_in.description,\n        estimated_hours=scope_item_in.estimated_hours,\n        order=new_order,\n        is_completed=False,\n    )\n    \n    db.add(scope_item)\n    await db.commit()\n    await db.refresh(scope_item)\n    \n    return ScopeItemResponse(\n        id=str(scope_item.id),\n        project_id=str(scope_item.project_id),\n        title=scope_item.title,\n        description=scope_item.description,\n        order=scope_item.order,\n        is_completed=scope_item.is_completed,\n        estimated_hours=scope_item.estimated_hours,\n        created_at=scope_item.created_at,\n        updated_at=scope_item.updated_at,\n    )"
    },
    {
      "name": "get_scope_progress",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 209,
      "docstring": "Get completion statistics for project scope items.",
      "parameters": [
        "project_id",
        "db",
        "current_user"
      ],
      "return_type": "ScopeProgress",
      "decorators": [
        "router.get"
      ],
      "is_async": true,
      "source": "async def get_scope_progress(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeProgress:\n    \"\"\"Get completion statistics for project scope items.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get all scope items for the project\n    result = await db.execute(\n        select(ScopeItem).where(ScopeItem.project_id == UUID(project_id))\n    )\n    scope_items = result.scalars().all()\n    \n    total_items = len(scope_items)\n    completed_items = sum(1 for item in scope_items if item.is_completed)\n    \n    # Calculate completion percentage\n    completion_percentage = 0.0\n    if total_items > 0:\n        completion_percentage = round((completed_items / total_items) * 100, 2)\n    \n    # Calculate hours\n    total_estimated_hours = None\n    completed_estimated_hours = None\n    \n    items_with_hours = [item for item in scope_items if item.estimated_hours is not None]\n    completed_with_hours = [\n        item for item in scope_items \n        if item.is_completed and item.estimated_hours is not None\n    ]\n    \n    if items_with_hours:\n        total_estimated_hours = sum(\n            item.estimated_hours for item in items_with_hours\n        )\n    \n    if completed_with_hours:\n        completed_estimated_hours = sum(\n            item.estimated_hours for item in completed_with_hours\n        )\n    elif items_with_hours:\n        # If there are items with hours but none completed, set to 0\n        completed_estimated_hours = Decimal(\"0\")\n    \n    return ScopeProgress(\n        total_items=total_items,\n        completed_items=completed_items,\n        completion_percentage=completion_percentage,\n        total_estimated_hours=total_estimated_hours,\n        completed_estimated_hours=completed_estimated_hours,\n    )"
    },
    {
      "name": "update_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 269,
      "docstring": "Update a scope item.",
      "parameters": [
        "project_id",
        "item_id",
        "scope_item_update",
        "db",
        "current_user"
      ],
      "return_type": "ScopeItemResponse",
      "decorators": [
        "router.patch"
      ],
      "is_async": true,
      "source": "async def update_scope_item(\n    project_id: str,\n    item_id: str,\n    scope_item_update: ScopeItemUpdate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeItemResponse:\n    \"\"\"Update a scope item.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    scope_item = await get_scope_item_or_404(item_id, project_id, db)\n    \n    # Update fields if provided\n    update_data = scope_item_update.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(scope_item, field, value)\n    \n    await db.commit()\n    await db.refresh(scope_item)\n    \n    return ScopeItemResponse(\n        id=str(scope_item.id),\n        project_id=str(scope_item.project_id),\n        title=scope_item.title,\n        description=scope_item.description,\n        order=scope_item.order,\n        is_completed=scope_item.is_completed,\n        estimated_hours=scope_item.estimated_hours,\n        created_at=scope_item.created_at,\n        updated_at=scope_item.updated_at,\n    )"
    },
    {
      "name": "delete_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 307,
      "docstring": "Delete a scope item.",
      "parameters": [
        "project_id",
        "item_id",
        "db",
        "current_user"
      ],
      "return_type": "None",
      "decorators": [
        "router.delete"
      ],
      "is_async": true,
      "source": "async def delete_scope_item(\n    project_id: str,\n    item_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Delete a scope item.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    scope_item = await get_scope_item_or_404(item_id, project_id, db)\n    \n    await db.delete(scope_item)\n    await db.commit()"
    },
    {
      "name": "reorder_scope_items",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 327,
      "docstring": "Reorder scope items by providing a list of item IDs in the desired order.",
      "parameters": [
        "project_id",
        "reorder_data",
        "db",
        "current_user"
      ],
      "return_type": "list[ScopeItemResponse]",
      "decorators": [
        "router.post"
      ],
      "is_async": true,
      "source": "async def reorder_scope_items(\n    project_id: str,\n    reorder_data: ScopeItemReorder,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[ScopeItemResponse]:\n    \"\"\"Reorder scope items by providing a list of item IDs in the desired order.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get all existing scope items for this project\n    result = await db.execute(\n        select(ScopeItem).where(ScopeItem.project_id == UUID(project_id))\n    )\n    existing_items = {str(item.id): item for item in result.scalars().all()}\n    \n    # Validate all provided IDs exist and belong to this project\n    for item_id in reorder_data.item_ids:\n        if item_id not in existing_items:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Scope item {item_id} not found in this project\",\n            )\n    \n    # Validate all existing items are included\n    if set(reorder_data.item_ids) != set(existing_items.keys()):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Reorder must include all scope items for the project\",\n        )\n    \n    # Update orders in a single transaction\n    for new_order, item_id in enumerate(reorder_data.item_ids):\n        existing_items[item_id].order = new_order\n    \n    await db.commit()\n    \n    # Refresh and return updated items in new order\n    updated_items = []\n    for item_id in reorder_data.item_ids:\n        await db.refresh(existing_items[item_id])\n        item = existing_items[item_id]\n        updated_items.append(\n            ScopeItemResponse(\n                id=str(item.id),\n                project_id=str(item.project_id),\n                title=item.title,\n                description=item.description,\n                order=item.order,\n                is_completed=item.is_completed,\n                estimated_hours=item.estimated_hours,\n                created_at=item.created_at,\n                updated_at=item.updated_at,\n            )\n        )\n    \n    return updated_items"
    }
  ],
  "classes": [
    {
      "name": "TestCreateProject",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 72,
      "docstring": "Tests for POST /api/v1/projects.",
      "bases": [],
      "methods": [
        "test_create_project_success",
        "test_create_project_invalid_client",
        "test_create_project_other_users_client"
      ],
      "decorators": [],
      "source": "class TestCreateProject:\n    \"\"\"Tests for POST /api/v1/projects.\"\"\"\n\n    async def test_create_project_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test creating a project with valid client_id.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": str(test_client_fixture.id),\n                \"name\": \"New Project\",\n                \"description\": \"Project description\",\n                \"status\": \"active\",\n                \"budget\": \"5000.00\",\n                \"hourly_rate\": \"100.00\",\n                \"estimated_hours\": \"50.0\",\n            },\n        )\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"New Project\"\n        assert data[\"description\"] == \"Project description\"\n        assert data[\"client_id\"] == str(test_client_fixture.id)\n        assert data[\"client_name\"] == test_client_fixture.name\n        assert data[\"status\"] == \"active\"\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n\n    async def test_create_project_invalid_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test creating project with non-existent client_id returns 404.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": \"00000000-0000-0000-0000-000000000000\",\n                \"name\": \"New Project\",\n            },\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Client not found\"\n\n    async def test_create_project_other_users_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_client: Client,\n    ):\n        \"\"\"Test creating project with another user's client returns 404.\"\"\"\n        response = await client.post(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            json={\n                \"client_id\": str(other_user_client.id),\n                \"name\": \"New Project\",\n            },\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Client not found\""
    },
    {
      "name": "TestListProjects",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 145,
      "docstring": "Tests for GET /api/v1/projects.",
      "bases": [],
      "methods": [
        "test_list_projects_empty",
        "test_list_projects_filter_by_status",
        "test_list_projects_filter_by_client"
      ],
      "decorators": [],
      "source": "class TestListProjects:\n    \"\"\"Tests for GET /api/v1/projects.\"\"\"\n\n    async def test_list_projects_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test listing projects when user has none.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"projects\"] == []\n        assert data[\"total\"] == 0\n\n    async def test_list_projects_filter_by_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        db_session: AsyncSession,\n        test_user: User,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test filtering projects by status.\"\"\"\n        # Create ACTIVE project\n        active_project = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Active Project\",\n            status=ProjectStatus.ACTIVE,\n        )\n        # Create COMPLETED project\n        completed_project = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Completed Project\",\n            status=ProjectStatus.COMPLETED,\n        )\n        db_session.add_all([active_project, completed_project])\n        await db_session.commit()\n        \n        # Filter by ACTIVE status\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            params={\"status\": \"active\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"total\"] == 1\n        assert len(data[\"projects\"]) == 1\n        assert data[\"projects\"][0][\"name\"] == \"Active Project\"\n        assert data[\"projects\"][0][\"status\"] == \"active\"\n\n    async def test_list_projects_filter_by_client(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        db_session: AsyncSession,\n        test_user: User,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test filtering projects by client_id.\"\"\"\n        # Create another client\n        other_client = Client(\n            user_id=test_user.id,\n            name=\"Other Client\",\n            email=\"other@example.com\",\n        )\n        db_session.add(other_client)\n        await db_session.commit()\n        await db_session.refresh(other_client)\n        \n        # Create project for test_client\n        project1 = Project(\n            user_id=test_user.id,\n            client_id=test_client_fixture.id,\n            name=\"Project for Test Client\",\n            status=ProjectStatus.ACTIVE,\n        )\n        # Create project for other_client\n        project2 = Project(\n            user_id=test_user.id,\n            client_id=other_client.id,\n            name=\"Project for Other Client\",\n            status=ProjectStatus.ACTIVE,\n        )\n        db_session.add_all([project1, project2])\n        await db_session.commit()\n        \n        # Filter by test_client_fixture\n        response = await client.get(\n            \"/api/v1/projects\",\n            headers=auth_headers,\n            params={\"client_id\": str(test_client_fixture.id)},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"total\"] == 1\n        assert len(data[\"projects\"]) == 1\n        assert data[\"projects\"][0][\"name\"] == \"Project for Test Client\"\n        assert data[\"projects\"][0][\"client_id\"] == str(test_client_fixture.id)"
    },
    {
      "name": "TestGetProject",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 255,
      "docstring": "Tests for GET /api/v1/projects/{project_id}.",
      "bases": [],
      "methods": [
        "test_get_project_with_stats",
        "test_get_project_not_found",
        "test_get_project_invalid_uuid"
      ],
      "decorators": [],
      "source": "class TestGetProject:\n    \"\"\"Tests for GET /api/v1/projects/{project_id}.\"\"\"\n\n    async def test_get_project_with_stats(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_client_fixture: Client,\n    ):\n        \"\"\"Test getting a project with stats.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == str(test_project.id)\n        assert data[\"name\"] == \"Test Project\"\n        assert data[\"client_name\"] == test_client_fixture.name\n        # Stats should be 0 initially\n        assert data[\"scope_item_count\"] == 0\n        assert data[\"completed_scope_count\"] == 0\n        assert data[\"out_of_scope_request_count\"] == 0\n\n    async def test_get_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test getting non-existent project returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Project not found\"\n\n    async def test_get_project_invalid_uuid(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test getting project with invalid UUID returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/invalid-uuid\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == \"Project not found\""
    },
    {
      "name": "TestGetProjectDetail",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 310,
      "docstring": "Tests for GET /api/v1/projects/{project_id}/detail.",
      "bases": [],
      "methods": [
        "test_get_project_detail"
      ],
      "decorators": [],
      "source": "class TestGetProjectDetail:\n    \"\"\"Tests for GET /api/v1/projects/{project_id}/detail.\"\"\"\n\n    async def test_get_project_detail(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test getting project detail with scope items and requests.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/detail\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == str(test_project.id)\n        assert \"scope_items\" in data\n        assert \"recent_requests\" in data\n        assert data[\"scope_items\"] == []\n        assert data[\"recent_requests\"] == []"
    },
    {
      "name": "TestUpdateProject",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 334,
      "docstring": "Tests for PATCH /api/v1/projects/{project_id}.",
      "bases": [],
      "methods": [
        "test_update_project_status",
        "test_update_project_partial",
        "test_update_project_not_found"
      ],
      "decorators": [],
      "source": "class TestUpdateProject:\n    \"\"\"Tests for PATCH /api/v1/projects/{project_id}.\"\"\"\n\n    async def test_update_project_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test updating project status from ACTIVE to COMPLETED.\"\"\"\n        assert test_project.status == ProjectStatus.ACTIVE\n        \n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n            json={\"status\": \"completed\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"completed\"\n\n    async def test_update_project_partial(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test partial update only changes specified fields.\"\"\"\n        original_description = test_project.description\n        \n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n            json={\"name\": \"Updated Name\"},\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n        assert data[\"description\"] == original_description\n\n    async def test_update_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test updating non-existent project returns 404.\"\"\"\n        response = await client.patch(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n            json={\"name\": \"New Name\"},\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "TestDeleteProject",
      "file_path": "tests/unit/test_projects.py",
      "line_number": 391,
      "docstring": "Tests for DELETE /api/v1/projects/{project_id}.",
      "bases": [],
      "methods": [
        "test_delete_project_success",
        "test_delete_project_not_found"
      ],
      "decorators": [],
      "source": "class TestDeleteProject:\n    \"\"\"Tests for DELETE /api/v1/projects/{project_id}.\"\"\"\n\n    async def test_delete_project_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Test deleting a project returns 204.\"\"\"\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 204\n        \n        # Verify project is deleted\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == 404\n\n    async def test_delete_project_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n    ):\n        \"\"\"Test deleting non-existent project returns 404.\"\"\"\n        response = await client.delete(\n            \"/api/v1/projects/00000000-0000-0000-0000-000000000000\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "ScopeItemBase",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 9,
      "docstring": "Base schema for scope items.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "validate_estimated_hours"
      ],
      "decorators": [],
      "source": "class ScopeItemBase(BaseModel):\n    \"\"\"Base schema for scope items.\"\"\"\n    title: str = Field(min_length=1, max_length=255)\n    description: Optional[str] = None\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)\n\n    @field_validator(\"estimated_hours\", mode=\"before\")\n    @classmethod\n    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "ScopeItemCreate",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 24,
      "docstring": "Schema for creating a scope item.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "validate_estimated_hours"
      ],
      "decorators": [],
      "source": "class ScopeItemCreate(BaseModel):\n    \"\"\"Schema for creating a scope item.\"\"\"\n    title: str = Field(min_length=1, max_length=255)\n    description: Optional[str] = None\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)\n\n    @field_validator(\"estimated_hours\", mode=\"before\")\n    @classmethod\n    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "ScopeItemUpdate",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 39,
      "docstring": "Schema for updating a scope item.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "validate_estimated_hours"
      ],
      "decorators": [],
      "source": "class ScopeItemUpdate(BaseModel):\n    \"\"\"Schema for updating a scope item.\"\"\"\n    title: Optional[str] = Field(default=None, min_length=1, max_length=255)\n    description: Optional[str] = None\n    is_completed: Optional[bool] = None\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)\n\n    @field_validator(\"estimated_hours\", mode=\"before\")\n    @classmethod\n    def validate_estimated_hours(cls, v):\n        \"\"\"Validate and round estimated hours to 1 decimal place.\"\"\"\n        if v is not None:\n            return Decimal(str(v)).quantize(Decimal(\"0.1\"))\n        return v"
    },
    {
      "name": "ScopeItemResponse",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 55,
      "docstring": "Schema for scope item response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ScopeItemResponse(BaseModel):\n    \"\"\"Schema for scope item response.\"\"\"\n    id: str\n    project_id: str\n    title: str\n    description: Optional[str]\n    order: int\n    is_completed: bool\n    estimated_hours: Optional[Decimal]\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = {\"from_attributes\": True}"
    },
    {
      "name": "ScopeItemReorder",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 70,
      "docstring": "Schema for reordering scope items.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ScopeItemReorder(BaseModel):\n    \"\"\"Schema for reordering scope items.\"\"\"\n    item_ids: list[str]  # Ordered list of scope item IDs"
    },
    {
      "name": "ScopeProgress",
      "file_path": "app/schemas/scope_item.py",
      "line_number": 75,
      "docstring": "Schema for scope completion progress.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ScopeProgress(BaseModel):\n    \"\"\"Schema for scope completion progress.\"\"\"\n    total_items: int\n    completed_items: int\n    completion_percentage: float\n    total_estimated_hours: Optional[Decimal]\n    completed_estimated_hours: Optional[Decimal]"
    },
    {
      "name": "StripeService",
      "file_path": "app/services/stripe_service.py",
      "line_number": 20,
      "docstring": "Service for Stripe operations.",
      "bases": [],
      "methods": [
        "create_customer",
        "create_checkout_session",
        "create_portal_session",
        "handle_checkout_completed",
        "handle_subscription_updated",
        "handle_subscription_deleted",
        "handle_invoice_payment_failed",
        "cancel_subscription",
        "reactivate_subscription",
        "get_webhook_secret"
      ],
      "decorators": [],
      "source": "class StripeService:\n    \"\"\"Service for Stripe operations.\"\"\"\n\n    # Price ID from environment\n    PRO_MONTHLY_PRICE_ID = os.getenv(\"STRIPE_PRO_PRICE_ID\", \"\")\n    WEBHOOK_SECRET = os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")\n\n    @staticmethod\n    def create_customer(user: User) -> str:\n        \"\"\"Create a Stripe customer for a user.\"\"\"\n        customer = stripe.Customer.create(\n            email=user.email,\n            name=user.full_name,\n            metadata={\n                \"user_id\": str(user.id),\n            }\n        )\n        return customer.id\n\n    @staticmethod\n    async def create_checkout_session(\n        db: AsyncSession,\n        user: User,\n        success_url: str,\n        cancel_url: str,\n    ) -> str:\n        \"\"\"Create a Stripe Checkout session for Pro subscription.\"\"\"\n        # Get or create subscription record\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription:\n            subscription = Subscription(user_id=user.id)\n            db.add(subscription)\n            await db.commit()\n            await db.refresh(subscription)\n\n        # Get or create Stripe customer\n        if not subscription.stripe_customer_id:\n            customer_id = StripeService.create_customer(user)\n            subscription.stripe_customer_id = customer_id\n            await db.commit()\n        else:\n            customer_id = subscription.stripe_customer_id\n\n        # Create checkout session\n        checkout_session = stripe.checkout.Session.create(\n            customer=customer_id,\n            payment_method_types=[\"card\"],\n            line_items=[\n                {\n                    \"price\": StripeService.PRO_MONTHLY_PRICE_ID,\n                    \"quantity\": 1,\n                }\n            ],\n            mode=\"subscription\",\n            success_url=success_url,\n            cancel_url=cancel_url,\n            metadata={\n                \"user_id\": str(user.id),\n            },\n            subscription_data={\n                \"metadata\": {\n                    \"user_id\": str(user.id),\n                }\n            },\n            allow_promotion_codes=True,\n        )\n\n        return checkout_session.url\n\n    @staticmethod\n    async def create_portal_session(\n        db: AsyncSession,\n        user: User,\n        return_url: str,\n    ) -> str:\n        \"\"\"Create a Stripe Customer Portal session for managing subscription.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_customer_id:\n            raise ValueError(\"No subscription found for user\")\n\n        portal_session = stripe.billing_portal.Session.create(\n            customer=subscription.stripe_customer_id,\n            return_url=return_url,\n        )\n\n        return portal_session.url\n\n    @staticmethod\n    async def handle_checkout_completed(db: AsyncSession, session: dict) -> None:\n        \"\"\"Handle successful checkout session completion.\"\"\"\n        customer_id = session.get(\"customer\")\n        subscription_id = session.get(\"subscription\")\n        user_id = session.get(\"metadata\", {}).get(\"user_id\")\n\n        if not user_id:\n            result = await db.execute(\n                select(Subscription).where(Subscription.stripe_customer_id == customer_id)\n            )\n            subscription = result.scalar_one_or_none()\n        else:\n            result = await db.execute(\n                select(Subscription).where(Subscription.user_id == user_id)\n            )\n            subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.stripe_subscription_id = subscription_id\n            subscription.stripe_customer_id = customer_id\n            subscription.plan = PlanType.PRO\n            subscription.status = SubscriptionStatus.ACTIVE\n            await db.commit()\n\n    @staticmethod\n    async def handle_subscription_updated(db: AsyncSession, stripe_subscription: dict) -> None:\n        \"\"\"Handle subscription update from Stripe webhook.\"\"\"\n        subscription_id = stripe_subscription.get(\"id\")\n        customer_id = stripe_subscription.get(\"customer\")\n        status = stripe_subscription.get(\"status\")\n        \n        result = await db.execute(\n            select(Subscription).where(\n                (Subscription.stripe_subscription_id == subscription_id) |\n                (Subscription.stripe_customer_id == customer_id)\n            )\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription:\n            return\n\n        subscription.stripe_subscription_id = subscription_id\n        subscription.status = SubscriptionStatus(status) if status in [s.value for s in SubscriptionStatus] else SubscriptionStatus.ACTIVE\n        \n        current_period_start = stripe_subscription.get(\"current_period_start\")\n        current_period_end = stripe_subscription.get(\"current_period_end\")\n        \n        if current_period_start:\n            subscription.current_period_start = datetime.fromtimestamp(current_period_start)\n        if current_period_end:\n            subscription.current_period_end = datetime.fromtimestamp(current_period_end)\n\n        subscription.cancel_at_period_end = stripe_subscription.get(\"cancel_at_period_end\", False)\n\n        if status in [\"active\", \"trialing\"]:\n            subscription.plan = PlanType.PRO\n        elif status in [\"canceled\", \"unpaid\"]:\n            subscription.plan = PlanType.FREE\n\n        await db.commit()\n\n    @staticmethod\n    async def handle_subscription_deleted(db: AsyncSession, stripe_subscription: dict) -> None:\n        \"\"\"Handle subscription cancellation/deletion.\"\"\"\n        subscription_id = stripe_subscription.get(\"id\")\n        \n        result = await db.execute(\n            select(Subscription).where(Subscription.stripe_subscription_id == subscription_id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.plan = PlanType.FREE\n            subscription.status = SubscriptionStatus.CANCELED\n            subscription.stripe_subscription_id = None\n            await db.commit()\n\n    @staticmethod\n    async def handle_invoice_payment_failed(db: AsyncSession, invoice: dict) -> None:\n        \"\"\"Handle failed invoice payment.\"\"\"\n        customer_id = invoice.get(\"customer\")\n        \n        result = await db.execute(\n            select(Subscription).where(Subscription.stripe_customer_id == customer_id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if subscription:\n            subscription.status = SubscriptionStatus.PAST_DUE\n            await db.commit()\n\n    @staticmethod\n    async def cancel_subscription(db: AsyncSession, user: User) -> bool:\n        \"\"\"Cancel a user's subscription at period end.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_subscription_id:\n            return False\n\n        stripe.Subscription.modify(\n            subscription.stripe_subscription_id,\n            cancel_at_period_end=True\n        )\n\n        subscription.cancel_at_period_end = True\n        await db.commit()\n\n        return True\n\n    @staticmethod\n    async def reactivate_subscription(db: AsyncSession, user: User) -> bool:\n        \"\"\"Reactivate a canceled subscription before period ends.\"\"\"\n        result = await db.execute(\n            select(Subscription).where(Subscription.user_id == user.id)\n        )\n        subscription = result.scalar_one_or_none()\n\n        if not subscription or not subscription.stripe_subscription_id:\n            return False\n\n        stripe.Subscription.modify(\n            subscription.stripe_subscription_id,\n            cancel_at_period_end=False\n        )\n\n        subscription.cancel_at_period_end = False\n        await db.commit()\n\n        return True\n    \n    @staticmethod\n    def get_webhook_secret() -> str:\n        \"\"\"Get the webhook secret for verifying Stripe webhooks.\"\"\"\n        return os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")"
    },
    {
      "name": "ProposalCreate",
      "file_path": "app/schemas/proposal.py",
      "line_number": 12,
      "docstring": "Schema for creating a proposal manually.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalCreate(BaseModel):\n    \"\"\"Schema for creating a proposal manually.\"\"\"\n    title: str = Field(min_length=1, max_length=255)\n    description: str = Field(min_length=1)\n    amount: Decimal = Field(ge=0)\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)"
    },
    {
      "name": "ProposalFromRequest",
      "file_path": "app/schemas/proposal.py",
      "line_number": 20,
      "docstring": "Create proposal from a client request.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalFromRequest(BaseModel):\n    \"\"\"Create proposal from a client request.\"\"\"\n    source_request_id: UUID\n    amount: Decimal = Field(ge=0)\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)"
    },
    {
      "name": "ProposalUpdate",
      "file_path": "app/schemas/proposal.py",
      "line_number": 28,
      "docstring": "Schema for updating a proposal.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalUpdate(BaseModel):\n    \"\"\"Schema for updating a proposal.\"\"\"\n    title: Optional[str] = Field(default=None, min_length=1, max_length=255)\n    description: Optional[str] = None\n    status: Optional[ProposalStatus] = None\n    amount: Optional[Decimal] = Field(default=None, ge=0)\n    estimated_hours: Optional[Decimal] = Field(default=None, ge=0)"
    },
    {
      "name": "ProposalResponse",
      "file_path": "app/schemas/proposal.py",
      "line_number": 37,
      "docstring": "Schema for proposal response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalResponse(BaseModel):\n    \"\"\"Schema for proposal response.\"\"\"\n    model_config = ConfigDict(from_attributes=True)\n    \n    id: UUID\n    project_id: UUID\n    source_request_id: Optional[UUID] = None\n    title: str\n    description: str\n    status: ProposalStatus\n    amount: Decimal\n    estimated_hours: Optional[Decimal] = None\n    sent_at: Optional[datetime] = None\n    responded_at: Optional[datetime] = None\n    created_at: datetime\n    updated_at: datetime\n    # Include source request info if linked\n    source_request_title: Optional[str] = None"
    },
    {
      "name": "ProposalStats",
      "file_path": "app/schemas/proposal.py",
      "line_number": 57,
      "docstring": "Proposal statistics for a project.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalStats(BaseModel):\n    \"\"\"Proposal statistics for a project.\"\"\"\n    total_proposals: int\n    draft_count: int\n    sent_count: int\n    accepted_count: int\n    declined_count: int\n    expired_count: int\n    total_amount_accepted: Decimal"
    },
    {
      "name": "TestCreateClient",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 9,
      "docstring": "Tests for POST /api/v1/clients endpoint.",
      "bases": [],
      "methods": [
        "test_create_client_success",
        "test_create_client_minimal",
        "test_create_client_invalid_email",
        "test_create_client_empty_name",
        "test_create_client_name_too_long",
        "test_create_client_unauthorized"
      ],
      "decorators": [],
      "source": "class TestCreateClient:\n    \"\"\"Tests for POST /api/v1/clients endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_client_success(self, client, auth_headers):\n        \"\"\"Test creating a client with all fields.\"\"\"\n        client_data = {\n            \"name\": \"New Client\",\n            \"email\": \"newclient@example.com\",\n            \"company\": \"New Company Inc.\",\n            \"notes\": \"Important client notes\",\n        }\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"name\"] == client_data[\"name\"]\n        assert data[\"email\"] == client_data[\"email\"]\n        assert data[\"company\"] == client_data[\"company\"]\n        assert data[\"notes\"] == client_data[\"notes\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n        assert data[\"project_count\"] == 0\n\n    @pytest.mark.asyncio\n    async def test_create_client_minimal(self, client, auth_headers):\n        \"\"\"Test creating a client with only required fields.\"\"\"\n        client_data = {\"name\": \"Minimal Client\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"name\"] == client_data[\"name\"]\n        assert data[\"email\"] is None\n        assert data[\"company\"] is None\n        assert data[\"notes\"] is None\n        assert data[\"project_count\"] == 0\n\n    @pytest.mark.asyncio\n    async def test_create_client_invalid_email(self, client, auth_headers):\n        \"\"\"Test creating a client with invalid email format.\"\"\"\n        client_data = {\n            \"name\": \"Invalid Email Client\",\n            \"email\": \"not-an-email\",\n        }\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_create_client_empty_name(self, client, auth_headers):\n        \"\"\"Test creating a client with empty name fails.\"\"\"\n        client_data = {\"name\": \"\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_create_client_name_too_long(self, client, auth_headers):\n        \"\"\"Test creating a client with name exceeding max length.\"\"\"\n        client_data = {\"name\": \"a\" * 256}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_create_client_unauthorized(self, client):\n        \"\"\"Test creating a client without authentication.\"\"\"\n        client_data = {\"name\": \"Unauthorized Client\"}\n\n        response = await client.post(\n            \"/api/v1/clients\",\n            json=client_data,\n        )\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "TestListClients",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 113,
      "docstring": "Tests for GET /api/v1/clients endpoint.",
      "bases": [],
      "methods": [
        "test_list_clients_empty",
        "test_list_clients_with_data",
        "test_list_clients_pagination",
        "test_list_clients_unauthorized"
      ],
      "decorators": [],
      "source": "class TestListClients:\n    \"\"\"Tests for GET /api/v1/clients endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_list_clients_empty(self, client, auth_headers):\n        \"\"\"Test listing clients when user has none.\"\"\"\n        response = await client.get(\n            \"/api/v1/clients\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"clients\"] == []\n        assert data[\"total\"] == 0\n\n    @pytest.mark.asyncio\n    async def test_list_clients_with_data(self, client, auth_headers):\n        \"\"\"Test listing clients when user has multiple clients.\"\"\"\n        # Create 3 clients first\n        for i in range(3):\n            await client.post(\n                \"/api/v1/clients\",\n                json={\"name\": f\"Client {i + 1}\"},\n                headers=auth_headers,\n            )\n\n        response = await client.get(\n            \"/api/v1/clients\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 3\n        assert data[\"total\"] == 3\n        for c in data[\"clients\"]:\n            assert c[\"project_count\"] == 0\n\n    @pytest.mark.asyncio\n    async def test_list_clients_pagination(self, client, auth_headers):\n        \"\"\"Test listing clients with pagination parameters.\"\"\"\n        # Create 5 clients\n        for i in range(5):\n            await client.post(\n                \"/api/v1/clients\",\n                json={\"name\": f\"Client {i + 1}\"},\n                headers=auth_headers,\n            )\n\n        # Get first page\n        response = await client.get(\n            \"/api/v1/clients\",\n            params={\"skip\": 0, \"limit\": 2},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 2\n        assert data[\"total\"] == 5\n\n        # Get second page\n        response = await client.get(\n            \"/api/v1/clients\",\n            params={\"skip\": 2, \"limit\": 2},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"clients\"]) == 2\n        assert data[\"total\"] == 5\n\n    @pytest.mark.asyncio\n    async def test_list_clients_unauthorized(self, client):\n        \"\"\"Test listing clients without authentication.\"\"\"\n        response = await client.get(\"/api/v1/clients\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "TestGetClient",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 195,
      "docstring": "Tests for GET /api/v1/clients/{client_id} endpoint.",
      "bases": [],
      "methods": [
        "test_get_client_success",
        "test_get_client_not_found",
        "test_get_client_unauthorized"
      ],
      "decorators": [],
      "source": "class TestGetClient:\n    \"\"\"Tests for GET /api/v1/clients/{client_id} endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_get_client_success(self, client, auth_headers):\n        \"\"\"Test getting an existing client.\"\"\"\n        # Create a client first\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\n                \"name\": \"Test Client\",\n                \"email\": \"test@client.com\",\n                \"company\": \"Test Co\",\n                \"notes\": \"Some notes\",\n            },\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Get the client\n        response = await client.get(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == client_id\n        assert data[\"name\"] == \"Test Client\"\n        assert data[\"email\"] == \"test@client.com\"\n        assert data[\"company\"] == \"Test Co\"\n        assert data[\"notes\"] == \"Some notes\"\n        assert \"created_at\" in data\n        assert \"updated_at\" in data\n\n    @pytest.mark.asyncio\n    async def test_get_client_not_found(self, client, auth_headers):\n        \"\"\"Test getting a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.get(\n            f\"/api/v1/clients/{fake_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\"\n\n    @pytest.mark.asyncio\n    async def test_get_client_unauthorized(self, client):\n        \"\"\"Test getting a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.get(f\"/api/v1/clients/{fake_id}\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "TestUpdateClient",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 253,
      "docstring": "Tests for PATCH /api/v1/clients/{client_id} endpoint.",
      "bases": [],
      "methods": [
        "test_update_client_partial",
        "test_update_client_all_fields",
        "test_update_client_not_found",
        "test_update_client_invalid_email",
        "test_update_client_unauthorized"
      ],
      "decorators": [],
      "source": "class TestUpdateClient:\n    \"\"\"Tests for PATCH /api/v1/clients/{client_id} endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_update_client_partial(self, client, auth_headers):\n        \"\"\"Test updating only the name field.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\n                \"name\": \"Original Name\",\n                \"email\": \"original@example.com\",\n                \"company\": \"Original Company\",\n            },\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Update only the name\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json={\"name\": \"Updated Name\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n        # Other fields should remain unchanged\n        assert data[\"email\"] == \"original@example.com\"\n        assert data[\"company\"] == \"Original Company\"\n\n    @pytest.mark.asyncio\n    async def test_update_client_all_fields(self, client, auth_headers):\n        \"\"\"Test updating all fields.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"Original\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Update all fields\n        update_data = {\n            \"name\": \"Updated Name\",\n            \"email\": \"updated@example.com\",\n            \"company\": \"Updated Company\",\n            \"notes\": \"Updated notes\",\n        }\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json=update_data,\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"name\"] == update_data[\"name\"]\n        assert data[\"email\"] == update_data[\"email\"]\n        assert data[\"company\"] == update_data[\"company\"]\n        assert data[\"notes\"] == update_data[\"notes\"]\n\n    @pytest.mark.asyncio\n    async def test_update_client_not_found(self, client, auth_headers):\n        \"\"\"Test updating a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.patch(\n            f\"/api/v1/clients/{fake_id}\",\n            json={\"name\": \"Updated\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\"\n\n    @pytest.mark.asyncio\n    async def test_update_client_invalid_email(self, client, auth_headers):\n        \"\"\"Test updating client with invalid email.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"Test Client\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Try to update with invalid email\n        response = await client.patch(\n            f\"/api/v1/clients/{client_id}\",\n            json={\"email\": \"not-valid-email\"},\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_update_client_unauthorized(self, client):\n        \"\"\"Test updating a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.patch(\n            f\"/api/v1/clients/{fake_id}\",\n            json={\"name\": \"Updated\"},\n        )\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "TestDeleteClient",
      "file_path": "tests/unit/test_clients.py",
      "line_number": 363,
      "docstring": "Tests for DELETE /api/v1/clients/{client_id} endpoint.",
      "bases": [],
      "methods": [
        "test_delete_client_success",
        "test_delete_client_not_found",
        "test_delete_client_unauthorized"
      ],
      "decorators": [],
      "source": "class TestDeleteClient:\n    \"\"\"Tests for DELETE /api/v1/clients/{client_id} endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_delete_client_success(self, client, auth_headers):\n        \"\"\"Test deleting an existing client.\"\"\"\n        # Create a client\n        create_response = await client.post(\n            \"/api/v1/clients\",\n            json={\"name\": \"To Be Deleted\"},\n            headers=auth_headers,\n        )\n        client_id = create_response.json()[\"id\"]\n\n        # Delete the client\n        response = await client.delete(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n        # Verify client is gone\n        get_response = await client.get(\n            f\"/api/v1/clients/{client_id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_delete_client_not_found(self, client, auth_headers):\n        \"\"\"Test deleting a non-existent client.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.delete(\n            f\"/api/v1/clients/{fake_id}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert response.json()[\"detail\"] == \"Client not found\"\n\n    @pytest.mark.asyncio\n    async def test_delete_client_unauthorized(self, client):\n        \"\"\"Test deleting a client without authentication.\"\"\"\n        fake_id = str(uuid4())\n\n        response = await client.delete(f\"/api/v1/clients/{fake_id}\")\n\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "Base",
      "file_path": "app/db/session.py",
      "line_number": 36,
      "docstring": "Base class for all SQLAlchemy models.",
      "bases": [
        "DeclarativeBase"
      ],
      "methods": [],
      "decorators": [],
      "source": "class Base(DeclarativeBase):\n    \"\"\"Base class for all SQLAlchemy models.\"\"\"\n    pass"
    },
    {
      "name": "ClientCreate",
      "file_path": "app/schemas/client.py",
      "line_number": 7,
      "docstring": "Schema for creating a new client.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientCreate(BaseModel):\n    \"\"\"Schema for creating a new client.\"\"\"\n    name: str = Field(min_length=1, max_length=255)\n    email: EmailStr | None = None\n    company: str | None = Field(default=None, max_length=255)\n    notes: str | None = None"
    },
    {
      "name": "ClientUpdate",
      "file_path": "app/schemas/client.py",
      "line_number": 15,
      "docstring": "Schema for updating an existing client.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientUpdate(BaseModel):\n    \"\"\"Schema for updating an existing client.\"\"\"\n    name: str | None = Field(default=None, min_length=1, max_length=255)\n    email: EmailStr | None = None\n    company: str | None = Field(default=None, max_length=255)\n    notes: str | None = None"
    },
    {
      "name": "ClientResponse",
      "file_path": "app/schemas/client.py",
      "line_number": 23,
      "docstring": "Schema for client response with computed project count.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientResponse(BaseModel):\n    \"\"\"Schema for client response with computed project count.\"\"\"\n    model_config = ConfigDict(from_attributes=True)\n    \n    id: str\n    name: str\n    email: str | None\n    company: str | None\n    notes: str | None\n    created_at: datetime\n    updated_at: datetime\n    project_count: int = 0"
    },
    {
      "name": "ClientList",
      "file_path": "app/schemas/client.py",
      "line_number": 37,
      "docstring": "Schema for paginated list of clients.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientList(BaseModel):\n    \"\"\"Schema for paginated list of clients.\"\"\"\n    clients: list[ClientResponse]\n    total: int"
    },
    {
      "name": "UserRegister",
      "file_path": "app/schemas/auth.py",
      "line_number": 9,
      "docstring": "Schema for user registration.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UserRegister(BaseModel):\n    \"\"\"Schema for user registration.\"\"\"\n    \n    email: EmailStr\n    password: str = Field(min_length=8, max_length=100)\n    full_name: str = Field(min_length=1, max_length=255)\n    business_name: str | None = Field(default=None, max_length=255)"
    },
    {
      "name": "UserLogin",
      "file_path": "app/schemas/auth.py",
      "line_number": 18,
      "docstring": "Schema for user login.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UserLogin(BaseModel):\n    \"\"\"Schema for user login.\"\"\"\n    \n    email: EmailStr\n    password: str"
    },
    {
      "name": "Token",
      "file_path": "app/schemas/auth.py",
      "line_number": 25,
      "docstring": "Schema for access token response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class Token(BaseModel):\n    \"\"\"Schema for access token response.\"\"\"\n    \n    access_token: str\n    token_type: str = \"bearer\""
    },
    {
      "name": "UserResponse",
      "file_path": "app/schemas/auth.py",
      "line_number": 32,
      "docstring": "Schema for user response (without password).",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UserResponse(BaseModel):\n    \"\"\"Schema for user response (without password).\"\"\"\n    \n    id: UUID\n    email: str\n    full_name: str\n    business_name: str | None\n    is_active: bool\n    \n    class Config:\n        from_attributes = True"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/auth.py",
      "line_number": 41,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "PlanType",
      "file_path": "app/models/subscription.py",
      "line_number": 12,
      "docstring": "Subscription plan types.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class PlanType(str, enum.Enum):\n    \"\"\"Subscription plan types.\"\"\"\n    FREE = \"free\"\n    PRO = \"pro\""
    },
    {
      "name": "SubscriptionStatus",
      "file_path": "app/models/subscription.py",
      "line_number": 18,
      "docstring": "Subscription status from Stripe.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class SubscriptionStatus(str, enum.Enum):\n    \"\"\"Subscription status from Stripe.\"\"\"\n    ACTIVE = \"active\"\n    CANCELED = \"canceled\"\n    PAST_DUE = \"past_due\"\n    INCOMPLETE = \"incomplete\"\n    TRIALING = \"trialing\"\n    UNPAID = \"unpaid\""
    },
    {
      "name": "Subscription",
      "file_path": "app/models/subscription.py",
      "line_number": 28,
      "docstring": "User subscription model.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "is_pro",
        "is_active",
        "max_projects",
        "max_clients",
        "__repr__"
      ],
      "decorators": [],
      "source": "class Subscription(BaseModel):\n    \"\"\"User subscription model.\"\"\"\n    \n    __tablename__ = \"subscriptions\"\n\n    id: Mapped[uuid.UUID] = mapped_column(\n        UUID(as_uuid=True), \n        primary_key=True, \n        default=uuid.uuid4\n    )\n    user_id: Mapped[uuid.UUID] = mapped_column(\n        UUID(as_uuid=True), \n        ForeignKey(\"users.id\", ondelete=\"CASCADE\"), \n        unique=True, \n        nullable=False\n    )\n    \n    # Stripe identifiers\n    stripe_customer_id: Mapped[str | None] = mapped_column(\n        String(255), \n        unique=True, \n        nullable=True\n    )\n    stripe_subscription_id: Mapped[str | None] = mapped_column(\n        String(255), \n        unique=True, \n        nullable=True\n    )\n    stripe_price_id: Mapped[str | None] = mapped_column(\n        String(255), \n        nullable=True\n    )\n    \n    # Plan info\n    plan: Mapped[PlanType] = mapped_column(\n        ENUM(PlanType, name='plantype', create_type=False),\n        default=PlanType.FREE, \n        nullable=False\n    )\n    status: Mapped[SubscriptionStatus] = mapped_column(\n        ENUM(SubscriptionStatus, name='subscriptionstatus', create_type=False),\n        default=SubscriptionStatus.ACTIVE, \n        nullable=False\n    )\n    \n    # Billing period\n    current_period_start: Mapped[datetime | None] = mapped_column(\n        DateTime(timezone=True), \n        nullable=True\n    )\n    current_period_end: Mapped[datetime | None] = mapped_column(\n        DateTime(timezone=True), \n        nullable=True\n    )\n    cancel_at_period_end: Mapped[bool] = mapped_column(\n        Boolean,\n        default=False,\n        nullable=False\n    )\n\n    # Relationships\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"subscription\")\n\n    @property\n    def is_pro(self) -> bool:\n        \"\"\"Check if user has active Pro subscription.\"\"\"\n        return (\n            self.plan == PlanType.PRO \n            and self.status in [SubscriptionStatus.ACTIVE, SubscriptionStatus.TRIALING]\n        )\n\n    @property\n    def is_active(self) -> bool:\n        \"\"\"Check if subscription is active (any plan).\"\"\"\n        return self.status in [SubscriptionStatus.ACTIVE, SubscriptionStatus.TRIALING]\n\n    # Plan limits\n    @property\n    def max_projects(self) -> int:\n        \"\"\"Maximum projects allowed for this plan.\"\"\"\n        return 999 if self.is_pro else 3\n\n    @property\n    def max_clients(self) -> int:\n        \"\"\"Maximum clients allowed for this plan.\"\"\"\n        return 999 if self.is_pro else 2\n\n    def __repr__(self):\n        return f\"<Subscription {self.user_id} - {self.plan.value}>\""
    },
    {
      "name": "Proposal",
      "file_path": "app/models/proposal.py",
      "line_number": 17,
      "docstring": "A proposal for out-of-scope work.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class Proposal(BaseModel):\n    \"\"\"A proposal for out-of-scope work.\"\"\"\n    \n    __tablename__ = \"proposals\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4,\n    )\n    \n    project_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"projects.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    source_request_id: Mapped[uuid.UUID | None] = mapped_column(\n        GUID(),\n        ForeignKey(\"client_requests.id\", ondelete=\"SET NULL\"),\n        nullable=True,\n    )\n    title: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    description: Mapped[str] = mapped_column(\n        Text,\n        nullable=False,\n    )\n    status: Mapped[ProposalStatus] = mapped_column(\n        default=ProposalStatus.DRAFT,\n        nullable=False,\n    )\n    amount: Mapped[Decimal] = mapped_column(\n        Numeric(10, 2),\n        nullable=False,\n    )\n    estimated_hours: Mapped[Decimal | None] = mapped_column(\n        Numeric(5, 1),\n        nullable=True,\n    )\n    sent_at: Mapped[datetime | None] = mapped_column(\n        DateTime(timezone=True),\n        nullable=True,\n    )\n    responded_at: Mapped[datetime | None] = mapped_column(\n        DateTime(timezone=True),\n        nullable=True,\n    )\n    \n    # Relationships\n    project: Mapped[\"Project\"] = relationship(\n        \"Project\",\n        back_populates=\"proposals\",\n    )\n    source_request: Mapped[\"ClientRequest | None\"] = relationship(\n        \"ClientRequest\",\n        back_populates=\"proposal\",\n        foreign_keys=[source_request_id],\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<Proposal {self.title}>\""
    },
    {
      "name": "ClientRequest",
      "file_path": "app/models/client_request.py",
      "line_number": 16,
      "docstring": "A request or communication from a client.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class ClientRequest(BaseModel):\n    \"\"\"A request or communication from a client.\"\"\"\n    \n    __tablename__ = \"client_requests\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4,\n    )\n    \n    project_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"projects.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    linked_scope_item_id: Mapped[uuid.UUID | None] = mapped_column(\n        GUID(),\n        ForeignKey(\"scope_items.id\", ondelete=\"SET NULL\"),\n        nullable=True,\n    )\n    title: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    content: Mapped[str] = mapped_column(\n        Text,\n        nullable=False,\n    )\n    source: Mapped[RequestSource] = mapped_column(\n        default=RequestSource.EMAIL,\n        nullable=False,\n    )\n    status: Mapped[RequestStatus] = mapped_column(\n        default=RequestStatus.NEW,\n        nullable=False,\n    )\n    \n    # Analysis results\n    classification: Mapped[ScopeClassification] = mapped_column(\n        default=ScopeClassification.PENDING,\n        nullable=False,\n    )\n    confidence: Mapped[Decimal | None] = mapped_column(\n        Numeric(3, 2),  # 0.00 to 1.00\n        nullable=True,\n    )\n    analysis_reasoning: Mapped[str | None] = mapped_column(\n        Text,\n        nullable=True,\n    )\n    suggested_action: Mapped[str | None] = mapped_column(\n        Text,\n        nullable=True,\n    )\n    \n    # Relationships\n    project: Mapped[\"Project\"] = relationship(\n        \"Project\",\n        back_populates=\"client_requests\",\n    )\n    linked_scope_item: Mapped[\"ScopeItem | None\"] = relationship(\n        \"ScopeItem\",\n        back_populates=\"linked_requests\",\n        foreign_keys=[linked_scope_item_id],\n    )\n    proposal: Mapped[\"Proposal | None\"] = relationship(\n        \"Proposal\",\n        back_populates=\"source_request\",\n        uselist=False,\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<ClientRequest {self.title}>\""
    },
    {
      "name": "TestDashboardSummaryEmpty",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 142,
      "docstring": "Test dashboard summary with no data.",
      "bases": [],
      "methods": [
        "test_summary_empty"
      ],
      "decorators": [],
      "source": "class TestDashboardSummaryEmpty:\n    \"\"\"Test dashboard summary with no data.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_summary_empty(self, client: AsyncClient, auth_headers: dict[str, str]):\n        \"\"\"New user with no data should have all counts at 0.\"\"\"\n        response = await client.get(\"/api/v1/dashboard/summary\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"total_projects\"] == 0\n        assert data[\"active_projects\"] == 0\n        assert data[\"total_clients\"] == 0\n        assert data[\"total_requests\"] == 0\n        assert data[\"out_of_scope_requests\"] == 0\n        assert data[\"pending_requests\"] == 0\n        assert data[\"total_proposals\"] == 0\n        assert data[\"pending_proposals\"] == 0\n        assert data[\"accepted_proposals\"] == 0\n        assert Decimal(data[\"total_revenue_protected\"]) == Decimal(\"0.00\")"
    },
    {
      "name": "TestDashboardSummaryWithData",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 165,
      "docstring": "Test dashboard summary with existing data.",
      "bases": [],
      "methods": [
        "test_summary_with_data"
      ],
      "decorators": [],
      "source": "class TestDashboardSummaryWithData:\n    \"\"\"Test dashboard summary with existing data.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_summary_with_data(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n        completed_project: Project,\n        second_client: Client,\n    ):\n        \"\"\"User with projects, requests, proposals should have accurate counts.\"\"\"\n        # Create requests\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n        )\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.OUT_OF_SCOPE,\n        )\n        await create_client_request(\n            db_session, completed_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        \n        # Create proposals\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"300.00\"),\n        )\n        await create_proposal(\n            db_session, completed_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"750.00\"),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/summary\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"total_projects\"] == 2\n        assert data[\"active_projects\"] == 1\n        assert data[\"total_clients\"] == 2  # test_client + second_client\n        assert data[\"total_requests\"] == 3\n        assert data[\"out_of_scope_requests\"] == 1\n        assert data[\"pending_requests\"] == 1\n        assert data[\"total_proposals\"] == 3\n        assert data[\"pending_proposals\"] == 1  # SENT only\n        assert data[\"accepted_proposals\"] == 2\n        assert Decimal(data[\"total_revenue_protected\"]) == Decimal(\"1250.00\")"
    },
    {
      "name": "TestAlertsGeneration",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 230,
      "docstring": "Test alert generation logic.",
      "bases": [],
      "methods": [
        "test_alerts_scope_creep",
        "test_alerts_pending_request",
        "test_alerts_proposal_expiring",
        "test_no_alerts_clean_project"
      ],
      "decorators": [],
      "source": "class TestAlertsGeneration:\n    \"\"\"Test alert generation logic.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_alerts_scope_creep(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with 4 OUT_OF_SCOPE requests in last week should trigger alert.\"\"\"\n        # Create 4 out-of-scope requests in the last 7 days\n        for _ in range(4):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n                created_at=datetime.now(timezone.utc) - timedelta(days=2),\n            )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        scope_creep_alerts = [a for a in alerts if a[\"type\"] == \"scope_creep\"]\n        assert len(scope_creep_alerts) >= 1\n        assert scope_creep_alerts[0][\"severity\"] == \"high\"\n        assert \"out-of-scope\" in scope_creep_alerts[0][\"message\"].lower()\n    \n    @pytest.mark.asyncio\n    async def test_alerts_pending_request(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Request with status=NEW, created 3 days ago should trigger alert.\"\"\"\n        # Create a request that's 3 days old and still NEW\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n            created_at=datetime.now(timezone.utc) - timedelta(days=3),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        pending_alerts = [a for a in alerts if a[\"type\"] == \"pending_request\"]\n        assert len(pending_alerts) >= 1\n        assert pending_alerts[0][\"severity\"] == \"medium\"\n        assert \"pending\" in pending_alerts[0][\"message\"].lower()\n    \n    @pytest.mark.asyncio\n    async def test_alerts_proposal_expiring(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"SENT proposal older than 14 days should trigger alert.\"\"\"\n        # Create a proposal that's 15 days old and still SENT\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(days=15),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        expiring_alerts = [a for a in alerts if a[\"type\"] == \"proposal_expiring\"]\n        assert len(expiring_alerts) >= 1\n        assert expiring_alerts[0][\"severity\"] == \"medium\"\n    \n    @pytest.mark.asyncio\n    async def test_no_alerts_clean_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Well-maintained project should have no alerts.\"\"\"\n        # Create recent, analyzed in-scope request\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=1),\n        )\n        \n        # Create recent accepted proposal\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(days=5),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/alerts\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        alerts = response.json()\n        \n        # Should have no alerts\n        assert len(alerts) == 0"
    },
    {
      "name": "TestRecentActivity",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 348,
      "docstring": "Test recent activity retrieval.",
      "bases": [],
      "methods": [
        "test_recent_activity"
      ],
      "decorators": [],
      "source": "class TestRecentActivity:\n    \"\"\"Test recent activity retrieval.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_recent_activity(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Activities should be returned in reverse chronological order.\"\"\"\n        # Create activities at different times\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=3),\n        )\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n            created_at=datetime.now(timezone.utc) - timedelta(hours=1),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"500.00\"),\n            created_at=datetime.now(timezone.utc) - timedelta(minutes=30),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard/activity\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        activities = response.json()\n        \n        assert len(activities) > 0\n        \n        # Verify reverse chronological order\n        timestamps = [\n            datetime.fromisoformat(a[\"timestamp\"].replace(\"Z\", \"+00:00\"))\n            for a in activities\n        ]\n        assert timestamps == sorted(timestamps, reverse=True)"
    },
    {
      "name": "TestProjectHealth",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 393,
      "docstring": "Test project health calculation.",
      "bases": [],
      "methods": [
        "test_project_health_score_perfect",
        "test_project_health_score_poor",
        "test_revenue_protected_calculation",
        "test_scope_creep_ratio"
      ],
      "decorators": [],
      "source": "class TestProjectHealth:\n    \"\"\"Test project health calculation.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_project_health_score_perfect(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with all IN_SCOPE requests, accepted proposals should have high score.\"\"\"\n        # Create in-scope analyzed requests\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ADDRESSED,  # Addressed, not unaddressed\n                classification=ScopeClassification.IN_SCOPE,\n            )\n        \n        # Create accepted proposals (adds +5 each)\n        for _ in range(2):\n            await create_proposal(\n                db_session, active_project,\n                status=ProposalStatus.ACCEPTED,\n                amount=Decimal(\"500.00\"),\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        # Score should be high (100 base + 10 from 2 accepted proposals = 100 clamped)\n        assert health[\"health_score\"] >= 90\n        assert health[\"out_of_scope_requests\"] == 0\n        assert health[\"scope_creep_ratio\"] == 0.0\n    \n    @pytest.mark.asyncio\n    async def test_project_health_score_poor(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Project with many OUT_OF_SCOPE requests, no proposals should have low score.\"\"\"\n        # Create out-of-scope requests (unaddressed = -10 each)\n        for _ in range(8):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n            )\n        \n        # Create old pending requests (-5 each)\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.NEW,\n                created_at=datetime.now(timezone.utc) - timedelta(days=2),\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        # Score should be low: 100 - (8 * 10) - (3 * 5) = 100 - 80 - 15 = 5, clamped to 0\n        assert health[\"health_score\"] <= 20\n        assert health[\"out_of_scope_requests\"] == 8\n    \n    @pytest.mark.asyncio\n    async def test_revenue_protected_calculation(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Multiple accepted proposals should sum correctly.\"\"\"\n        # Create multiple accepted proposals\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"750.00\"),\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"1000.00\"),\n        )\n        # This one shouldn't count (not accepted)\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.SENT,\n            amount=Decimal(\"300.00\"),\n        )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        assert Decimal(health[\"revenue_protected\"]) == Decimal(\"2250.00\")\n        assert health[\"proposals_accepted\"] == 3\n        assert health[\"proposals_sent\"] == 1\n    \n    @pytest.mark.asyncio\n    async def test_scope_creep_ratio(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"10 requests, 3 out of scope should give ratio of 0.3.\"\"\"\n        # Create 7 in-scope requests\n        for _ in range(7):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.IN_SCOPE,\n            )\n        \n        # Create 3 out-of-scope requests\n        for _ in range(3):\n            await create_client_request(\n                db_session, active_project,\n                status=RequestStatus.ANALYZED,\n                classification=ScopeClassification.OUT_OF_SCOPE,\n            )\n        \n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{active_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        health = response.json()\n        \n        assert health[\"total_requests\"] == 10\n        assert health[\"in_scope_requests\"] == 7\n        assert health[\"out_of_scope_requests\"] == 3\n        assert health[\"scope_creep_ratio\"] == 0.3"
    },
    {
      "name": "TestProjectHealthNotFound",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 554,
      "docstring": "Test project health for non-existent project.",
      "bases": [],
      "methods": [
        "test_project_not_found"
      ],
      "decorators": [],
      "source": "class TestProjectHealthNotFound:\n    \"\"\"Test project health for non-existent project.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_project_not_found(\n        self, client: AsyncClient, auth_headers: dict[str, str]\n    ):\n        \"\"\"Requesting health for non-existent project should return 404.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{fake_id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "TestFullDashboard",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 571,
      "docstring": "Test the full dashboard endpoint.",
      "bases": [],
      "methods": [
        "test_full_dashboard"
      ],
      "decorators": [],
      "source": "class TestFullDashboard:\n    \"\"\"Test the full dashboard endpoint.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_full_dashboard(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        db_session: AsyncSession,\n        active_project: Project,\n    ):\n        \"\"\"Full dashboard should return all components.\"\"\"\n        await create_client_request(\n            db_session, active_project,\n            status=RequestStatus.NEW,\n        )\n        await create_proposal(\n            db_session, active_project,\n            status=ProposalStatus.ACCEPTED,\n            amount=Decimal(\"500.00\"),\n        )\n        \n        response = await client.get(\"/api/v1/dashboard\", headers=auth_headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert \"summary\" in data\n        assert \"alerts\" in data\n        assert \"recent_activity\" in data\n        assert \"project_health\" in data\n        \n        # Verify summary has correct structure\n        assert \"total_projects\" in data[\"summary\"]\n        assert \"total_revenue_protected\" in data[\"summary\"]\n        \n        # Verify project_health is a list\n        assert isinstance(data[\"project_health\"], list)"
    },
    {
      "name": "TestDashboardAuthorization",
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 611,
      "docstring": "Test dashboard authorization - users can only see their own data.",
      "bases": [],
      "methods": [
        "test_cannot_access_other_user_project_health"
      ],
      "decorators": [],
      "source": "class TestDashboardAuthorization:\n    \"\"\"Test dashboard authorization - users can only see their own data.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_cannot_access_other_user_project_health(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"User cannot access health of another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/dashboard/projects/{other_user_project.id}/health\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 404"
    },
    {
      "name": "TestHealthCheck",
      "file_path": "tests/unit/test_health.py",
      "line_number": 9,
      "docstring": "Tests for GET /api/v1/health",
      "bases": [],
      "methods": [
        "test_health_check"
      ],
      "decorators": [],
      "source": "class TestHealthCheck:\n    \"\"\"Tests for GET /api/v1/health\"\"\"\n    \n    async def test_health_check(self, client: AsyncClient):\n        \"\"\"Test health check returns healthy status.\"\"\"\n        response = await client.get(\"/api/v1/health\")\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"healthy\"\n        assert \"app\" in data\n        assert \"version\" in data"
    },
    {
      "name": "ProjectStatus",
      "file_path": "app/models/enums.py",
      "line_number": 8,
      "docstring": "Status of a project.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectStatus(str, Enum):\n    \"\"\"Status of a project.\"\"\"\n    ACTIVE = \"active\"\n    COMPLETED = \"completed\"\n    ON_HOLD = \"on_hold\"\n    CANCELLED = \"cancelled\""
    },
    {
      "name": "RequestSource",
      "file_path": "app/models/enums.py",
      "line_number": 16,
      "docstring": "Source of a client request.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class RequestSource(str, Enum):\n    \"\"\"Source of a client request.\"\"\"\n    EMAIL = \"email\"\n    CHAT = \"chat\"\n    CALL = \"call\"\n    MEETING = \"meeting\"\n    OTHER = \"other\""
    },
    {
      "name": "ScopeClassification",
      "file_path": "app/models/enums.py",
      "line_number": 25,
      "docstring": "Classification of a client request relative to project scope.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ScopeClassification(str, Enum):\n    \"\"\"Classification of a client request relative to project scope.\"\"\"\n    IN_SCOPE = \"in_scope\"\n    OUT_OF_SCOPE = \"out_of_scope\"\n    CLARIFICATION_NEEDED = \"clarification_needed\"\n    REVISION = \"revision\"\n    PENDING = \"pending\"  # Not yet analyzed"
    },
    {
      "name": "RequestStatus",
      "file_path": "app/models/enums.py",
      "line_number": 34,
      "docstring": "Status of a client request.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class RequestStatus(str, Enum):\n    \"\"\"Status of a client request.\"\"\"\n    NEW = \"new\"\n    ANALYZED = \"analyzed\"\n    ADDRESSED = \"addressed\"\n    PROPOSAL_SENT = \"proposal_sent\"\n    DECLINED = \"declined\""
    },
    {
      "name": "ProposalStatus",
      "file_path": "app/models/enums.py",
      "line_number": 43,
      "docstring": "Status of a proposal for out-of-scope work.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProposalStatus(str, Enum):\n    \"\"\"Status of a proposal for out-of-scope work.\"\"\"\n    DRAFT = \"draft\"\n    SENT = \"sent\"\n    ACCEPTED = \"accepted\"\n    DECLINED = \"declined\"\n    EXPIRED = \"expired\""
    },
    {
      "name": "Client",
      "file_path": "app/models/client.py",
      "line_number": 16,
      "docstring": "A client that the freelancer works with.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class Client(BaseModel):\n    \"\"\"A client that the freelancer works with.\"\"\"\n    \n    __tablename__ = \"clients\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4,\n    )\n    \n    user_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"users.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    name: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    email: Mapped[str | None] = mapped_column(\n        String(255),\n        nullable=True,\n    )\n    company: Mapped[str | None] = mapped_column(\n        String(255),\n        nullable=True,\n    )\n    notes: Mapped[str | None] = mapped_column(\n        Text,\n        nullable=True,\n    )\n    \n    # Relationships\n    user: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"clients\",\n    )\n    projects: Mapped[list[\"Project\"]] = relationship(\n        \"Project\",\n        back_populates=\"client\",\n        cascade=\"all, delete-orphan\",\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<Client {self.name}>\""
    },
    {
      "name": "PlanType",
      "file_path": "app/schemas/billing.py",
      "line_number": 8,
      "docstring": "Available plan types.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class PlanType(str, Enum):\n    \"\"\"Available plan types.\"\"\"\n    FREE = \"free\"\n    PRO = \"pro\""
    },
    {
      "name": "SubscriptionStatus",
      "file_path": "app/schemas/billing.py",
      "line_number": 14,
      "docstring": "Subscription status.",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": [],
      "decorators": [],
      "source": "class SubscriptionStatus(str, Enum):\n    \"\"\"Subscription status.\"\"\"\n    ACTIVE = \"active\"\n    CANCELED = \"canceled\"\n    PAST_DUE = \"past_due\"\n    INCOMPLETE = \"incomplete\"\n    TRIALING = \"trialing\"\n    UNPAID = \"unpaid\""
    },
    {
      "name": "SubscriptionResponse",
      "file_path": "app/schemas/billing.py",
      "line_number": 24,
      "docstring": "Current subscription details.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class SubscriptionResponse(BaseModel):\n    \"\"\"Current subscription details.\"\"\"\n    plan: PlanType\n    status: SubscriptionStatus\n    is_pro: bool\n    current_period_end: Optional[datetime] = None\n    cancel_at_period_end: bool = False\n    \n    # Plan limits\n    max_projects: int\n    max_clients: int\n    \n    # Current usage (filled by endpoint)\n    current_projects: int = 0\n    current_clients: int = 0\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "CreateCheckoutRequest",
      "file_path": "app/schemas/billing.py",
      "line_number": 44,
      "docstring": "Request to create checkout session.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class CreateCheckoutRequest(BaseModel):\n    \"\"\"Request to create checkout session.\"\"\"\n    success_url: str\n    cancel_url: str"
    },
    {
      "name": "CreateCheckoutResponse",
      "file_path": "app/schemas/billing.py",
      "line_number": 50,
      "docstring": "Response with checkout URL.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class CreateCheckoutResponse(BaseModel):\n    \"\"\"Response with checkout URL.\"\"\"\n    checkout_url: str"
    },
    {
      "name": "CreatePortalRequest",
      "file_path": "app/schemas/billing.py",
      "line_number": 55,
      "docstring": "Request to create customer portal session.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class CreatePortalRequest(BaseModel):\n    \"\"\"Request to create customer portal session.\"\"\"\n    return_url: str"
    },
    {
      "name": "CreatePortalResponse",
      "file_path": "app/schemas/billing.py",
      "line_number": 60,
      "docstring": "Response with portal URL.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class CreatePortalResponse(BaseModel):\n    \"\"\"Response with portal URL.\"\"\"\n    portal_url: str"
    },
    {
      "name": "PlanLimits",
      "file_path": "app/schemas/billing.py",
      "line_number": 65,
      "docstring": "Plan limits response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class PlanLimits(BaseModel):\n    \"\"\"Plan limits response.\"\"\"\n    plan: PlanType\n    max_projects: int\n    max_clients: int\n    current_projects: int\n    current_clients: int\n    can_create_project: bool\n    can_create_client: bool"
    },
    {
      "name": "UpgradePrompt",
      "file_path": "app/schemas/billing.py",
      "line_number": 76,
      "docstring": "Upgrade prompt when limit is reached.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UpgradePrompt(BaseModel):\n    \"\"\"Upgrade prompt when limit is reached.\"\"\"\n    limit_type: str  # \"projects\" or \"clients\"\n    current_count: int\n    max_count: int\n    message: str"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/billing.py",
      "line_number": 40,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "TestCreateScopeItem",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 12,
      "docstring": "Tests for creating scope items.",
      "bases": [],
      "methods": [
        "test_create_scope_item_success",
        "test_create_scope_item_auto_order",
        "test_create_scope_item_minimal_data"
      ],
      "decorators": [],
      "source": "class TestCreateScopeItem:\n    \"\"\"Tests for creating scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_success(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test creating a scope item successfully.\"\"\"\n        scope_data = {\n            \"title\": \"Design homepage\",\n            \"description\": \"Create the homepage design mockup\",\n            \"estimated_hours\": \"5.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json=scope_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == scope_data[\"title\"]\n        assert data[\"description\"] == scope_data[\"description\"]\n        assert data[\"order\"] == 0  # First item should have order 0\n        assert data[\"is_completed\"] is False\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_auto_order(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that scope items auto-assign incrementing orders.\"\"\"\n        titles = [\"First task\", \"Second task\", \"Third task\"]\n        \n        for i, title in enumerate(titles):\n            response = await client.post(\n                f\"/api/v1/projects/{test_project.id}/scope\",\n                json={\"title\": title},\n                headers=auth_headers,\n            )\n            \n            assert response.status_code == status.HTTP_201_CREATED\n            data = response.json()\n            assert data[\"order\"] == i  # Orders should be 0, 1, 2\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_minimal_data(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test creating a scope item with only required fields.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"Minimal task\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == \"Minimal task\"\n        assert data[\"description\"] is None\n        assert data[\"estimated_hours\"] is None"
    },
    {
      "name": "TestListScopeItems",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 84,
      "docstring": "Tests for listing scope items.",
      "bases": [],
      "methods": [
        "test_list_scope_items_ordered",
        "test_list_scope_items_empty"
      ],
      "decorators": [],
      "source": "class TestListScopeItems:\n    \"\"\"Tests for listing scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_list_scope_items_ordered(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_ordered: list[ScopeItem],\n    ):\n        \"\"\"Test that scope items are returned in order.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Verify items are in correct order\n        assert len(data) == 3\n        for i, item in enumerate(data):\n            assert item[\"order\"] == i\n\n    @pytest.mark.asyncio\n    async def test_list_scope_items_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test listing scope items for a project with no items.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data == []"
    },
    {
      "name": "TestUpdateScopeItem",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 127,
      "docstring": "Tests for updating scope items.",
      "bases": [],
      "methods": [
        "test_update_scope_item_completed",
        "test_update_scope_item_title",
        "test_update_scope_item_not_found"
      ],
      "decorators": [],
      "source": "class TestUpdateScopeItem:\n    \"\"\"Tests for updating scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_update_scope_item_completed(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test marking a scope item as completed.\"\"\"\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            json={\"is_completed\": True},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"is_completed\"] is True\n\n    @pytest.mark.asyncio\n    async def test_update_scope_item_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test updating a scope item's title.\"\"\"\n        new_title = \"Updated task title\"\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            json={\"title\": new_title},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"title\"] == new_title\n\n    @pytest.mark.asyncio\n    async def test_update_scope_item_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test updating a non-existent scope item.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/scope/{fake_id}\",\n            json={\"is_completed\": True},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "TestGetProgress",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 187,
      "docstring": "Tests for getting scope progress.",
      "bases": [],
      "methods": [
        "test_get_progress_empty",
        "test_get_progress_partial",
        "test_get_progress_with_hours",
        "test_get_progress_all_completed"
      ],
      "decorators": [],
      "source": "class TestGetProgress:\n    \"\"\"Tests for getting scope progress.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_get_progress_empty(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test getting progress for a project with no scope items.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_items\"] == 0\n        assert data[\"completed_items\"] == 0\n        assert data[\"completion_percentage\"] == 0.0\n\n    @pytest.mark.asyncio\n    async def test_get_progress_partial(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_with_progress: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress with partial completion (1 of 3 = 33.33%).\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_items\"] == 3\n        assert data[\"completed_items\"] == 1\n        assert data[\"completion_percentage\"] == 33.33\n\n    @pytest.mark.asyncio\n    async def test_get_progress_with_hours(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_with_hours: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress with estimated hours calculations.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Total hours: 5 + 10 + 3 = 18\n        # Completed hours: 5 + 3 = 8 (tasks 1 and 3 are completed)\n        assert data[\"total_estimated_hours\"] is not None\n        assert data[\"completed_estimated_hours\"] is not None\n        assert Decimal(str(data[\"total_estimated_hours\"])) == Decimal(\"18.0\")\n        assert Decimal(str(data[\"completed_estimated_hours\"])) == Decimal(\"8.0\")\n\n    @pytest.mark.asyncio\n    async def test_get_progress_all_completed(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_all_completed: list[ScopeItem],\n    ):\n        \"\"\"Test getting progress when all items are completed.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope/progress\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"completion_percentage\"] == 100.0\n        assert data[\"total_items\"] == data[\"completed_items\"]"
    },
    {
      "name": "TestReorderScopeItems",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 273,
      "docstring": "Tests for reordering scope items.",
      "bases": [],
      "methods": [
        "test_reorder_scope_items",
        "test_reorder_invalid_ids",
        "test_reorder_missing_items"
      ],
      "decorators": [],
      "source": "class TestReorderScopeItems:\n    \"\"\"Tests for reordering scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_reorder_scope_items(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reordering scope items from A,B,C to C,A,B.\"\"\"\n        item_a, item_b, item_c = scope_items_abc\n        new_order = [str(item_c.id), str(item_a.id), str(item_b.id)]\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": new_order},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Verify new orders: C=0, A=1, B=2\n        assert data[0][\"id\"] == str(item_c.id)\n        assert data[0][\"order\"] == 0\n        assert data[1][\"id\"] == str(item_a.id)\n        assert data[1][\"order\"] == 1\n        assert data[2][\"id\"] == str(item_b.id)\n        assert data[2][\"order\"] == 2\n\n    @pytest.mark.asyncio\n    async def test_reorder_invalid_ids(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reorder with non-existent item_id returns 400.\"\"\"\n        fake_id = str(uuid4())\n        item_a, item_b, _ = scope_items_abc\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": [fake_id, str(item_a.id), str(item_b.id)]},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n\n    @pytest.mark.asyncio\n    async def test_reorder_missing_items(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test reorder with missing items in the list returns 400.\"\"\"\n        item_a, item_b, _ = scope_items_abc\n        # Only providing 2 items when 3 exist\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope/reorder\",\n            json={\"item_ids\": [str(item_a.id), str(item_b.id)]},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST"
    },
    {
      "name": "TestDeleteScopeItem",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 346,
      "docstring": "Tests for deleting scope items.",
      "bases": [],
      "methods": [
        "test_delete_scope_item",
        "test_delete_scope_item_not_found",
        "test_delete_middle_item_preserves_others"
      ],
      "decorators": [],
      "source": "class TestDeleteScopeItem:\n    \"\"\"Tests for deleting scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_delete_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Test deleting a scope item.\"\"\"\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{test_scope_item.id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n    @pytest.mark.asyncio\n    async def test_delete_scope_item_not_found(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test deleting a non-existent scope item.\"\"\"\n        fake_id = str(uuid4())\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{fake_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_delete_middle_item_preserves_others(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n        scope_items_abc: tuple[ScopeItem, ScopeItem, ScopeItem],\n    ):\n        \"\"\"Test that deleting a middle item doesn't affect others.\"\"\"\n        item_a, item_b, item_c = scope_items_abc\n        \n        # Delete middle item (B)\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/scope/{item_b.id}\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify remaining items still exist\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        \n        # Should have 2 items left\n        assert len(data) == 2\n        item_ids = [item[\"id\"] for item in data]\n        assert str(item_a.id) in item_ids\n        assert str(item_b.id) not in item_ids\n        assert str(item_c.id) in item_ids"
    },
    {
      "name": "TestScopeItemAuthorization",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 415,
      "docstring": "Tests for scope item authorization.",
      "bases": [],
      "methods": [
        "test_scope_item_other_users_project",
        "test_list_scope_other_users_project",
        "test_unauthorized_access"
      ],
      "decorators": [],
      "source": "class TestScopeItemAuthorization:\n    \"\"\"Tests for scope item authorization.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_scope_item_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"Test that a user cannot add scope to another user's project.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{other_user_project.id}/scope\",\n            json={\"title\": \"Unauthorized task\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_list_scope_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        other_user_project: Project,\n    ):\n        \"\"\"Test that a user cannot list scope from another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_unauthorized_access(\n        self,\n        client: AsyncClient,\n        test_project: Project,\n    ):\n        \"\"\"Test that unauthenticated requests are rejected.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n        )\n        \n        # Accept either 401 (Unauthorized) or 403 (Forbidden) - both indicate auth required\n        assert response.status_code in (status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN)"
    },
    {
      "name": "TestScopeItemValidation",
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 464,
      "docstring": "Tests for scope item input validation.",
      "bases": [],
      "methods": [
        "test_create_scope_item_empty_title",
        "test_create_scope_item_title_too_long",
        "test_create_scope_item_negative_hours",
        "test_invalid_project_id_format"
      ],
      "decorators": [],
      "source": "class TestScopeItemValidation:\n    \"\"\"Tests for scope item input validation.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_empty_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that empty title is rejected.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_title_too_long(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that overly long title is rejected.\"\"\"\n        long_title = \"x\" * 256\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": long_title},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_create_scope_item_negative_hours(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n        test_project: Project,\n    ):\n        \"\"\"Test that negative estimated hours is rejected.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/scope\",\n            json={\"title\": \"Task\", \"estimated_hours\": \"-5.0\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.asyncio\n    async def test_invalid_project_id_format(\n        self,\n        client: AsyncClient,\n        auth_headers: dict[str, str],\n    ):\n        \"\"\"Test that invalid UUID format returns 404.\"\"\"\n        response = await client.get(\n            \"/api/v1/projects/not-a-uuid/scope\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "MockAnalysisResult",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 22,
      "docstring": null,
      "bases": [],
      "methods": [
        "__init__"
      ],
      "decorators": [],
      "source": "class MockAnalysisResult:\n    def __init__(\n        self,\n        classification: str = \"in_scope\",\n        confidence: float = 0.85,\n        reasoning: str = \"Test reasoning\",\n        matched_scope_item_id: UUID | None = None,\n        suggested_action: str = \"Proceed with task\",\n        scope_creep_indicators: list[str] | None = None,\n    ):\n        self.classification = classification\n        self.confidence = confidence\n        self.reasoning = reasoning\n        self.matched_scope_item_id = matched_scope_item_id\n        self.suggested_action = suggested_action\n        self.scope_creep_indicators = scope_creep_indicators or []"
    },
    {
      "name": "TestCreateRequestNoAnalysis",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 118,
      "docstring": "Test creating a request without auto-analysis.",
      "bases": [],
      "methods": [
        "test_create_request_no_analysis"
      ],
      "decorators": [],
      "source": "class TestCreateRequestNoAnalysis:\n    \"\"\"Test creating a request without auto-analysis.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_no_analysis(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Create request with auto_analyze=False, verify PENDING classification.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Test Request\",\n                \"content\": \"This is a test client request\",\n                \"source\": \"email\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"title\"] == \"Test Request\"\n        assert data[\"content\"] == \"This is a test client request\"\n        assert data[\"source\"] == \"email\"\n        assert data[\"status\"] == \"new\"\n        assert data[\"classification\"] == \"pending\"\n        assert data[\"analysis_reasoning\"] is None\n        assert data[\"confidence\"] is None\n        assert data[\"linked_scope_item_id\"] is None"
    },
    {
      "name": "TestCreateRequestWithAnalysis",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 158,
      "docstring": "Test creating a request with auto-analysis.",
      "bases": [],
      "methods": [
        "test_create_request_with_analysis"
      ],
      "decorators": [],
      "source": "class TestCreateRequestWithAnalysis:\n    \"\"\"Test creating a request with auto-analysis.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_with_analysis(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_client_request,\n    ):\n        \"\"\"Create request with auto_analyze=True, verify analysis is performed.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Authentication Feature\",\n                \"content\": \"Working on the login form\",\n                \"source\": \"chat\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"classification\"] != \"pending\"\n        assert data[\"analysis_reasoning\"] is not None\n        assert data[\"suggested_action\"] is not None\n\n        # Verify analyzer was called\n        mock_analyze_client_request.assert_called_once()"
    },
    {
      "name": "TestCreateRequestOutOfScope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 199,
      "docstring": "Test detection of out-of-scope requests.",
      "bases": [],
      "methods": [
        "test_create_request_out_of_scope_detected"
      ],
      "decorators": [],
      "source": "class TestCreateRequestOutOfScope:\n    \"\"\"Test detection of out-of-scope requests.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_out_of_scope_detected(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_out_of_scope,\n    ):\n        \"\"\"\n        Scope: [\"Build homepage\"]\n        Request: \"Can you also build a mobile app?\"\n        Verify classification=out_of_scope, indicators detected.\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Mobile App Request\",\n                \"content\": \"Can you also build a mobile app?\",\n                \"source\": \"email\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"classification\"] == \"out_of_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"analysis_reasoning\"] is not None\n        assert \"scope\" in data[\"analysis_reasoning\"].lower()"
    },
    {
      "name": "TestCreateRequestInScope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 241,
      "docstring": "Test detection of in-scope requests.",
      "bases": [],
      "methods": [
        "test_create_request_in_scope_detected"
      ],
      "decorators": [],
      "source": "class TestCreateRequestInScope:\n    \"\"\"Test detection of in-scope requests.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_in_scope_detected(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_in_scope,\n    ):\n        \"\"\"\n        Scope: [\"Build user authentication\"]\n        Request: \"Working on the login form\"\n        Verify classification=in_scope, linked_scope_item set.\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Login Form Update\",\n                \"content\": \"Working on the login form\",\n                \"source\": \"meeting\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert data[\"classification\"] == \"in_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert data[\"linked_scope_item_id\"] is not None"
    },
    {
      "name": "TestListRequestsFilterClassification",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 282,
      "docstring": "Test filtering requests by classification.",
      "bases": [],
      "methods": [
        "test_list_requests_filter_classification"
      ],
      "decorators": [],
      "source": "class TestListRequestsFilterClassification:\n    \"\"\"Test filtering requests by classification.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_list_requests_filter_classification(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"\n        Create IN_SCOPE and OUT_OF_SCOPE requests.\n        Filter by classification=out_of_scope.\n        Verify only out_of_scope returned.\n        \"\"\"\n        # Create requests with different classifications directly in DB\n        in_scope_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"In Scope Request\",\n            content=\"This is in scope\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        out_scope_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"Out of Scope Request\",\n            content=\"This is out of scope\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.OUT_OF_SCOPE,\n        )\n        db_session.add_all([in_scope_request, out_scope_request])\n        await db_session.commit()\n\n        # Filter by out_of_scope (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"classification\": \"out_of_scope\"},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert \"items\" in data\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"classification\"] == \"out_of_scope\""
    },
    {
      "name": "TestListRequestsFilterStatus",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 338,
      "docstring": "Test filtering requests by status.",
      "bases": [],
      "methods": [
        "test_list_requests_filter_status"
      ],
      "decorators": [],
      "source": "class TestListRequestsFilterStatus:\n    \"\"\"Test filtering requests by status.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_list_requests_filter_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"\n        Create NEW and ANALYZED requests.\n        Filter appropriately.\n        \"\"\"\n        # Create requests with different statuses\n        new_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"New Request\",\n            content=\"This is new\",\n            source=RequestSource.EMAIL,\n            status=RequestStatus.NEW,\n            classification=ScopeClassification.PENDING,\n        )\n        analyzed_request = ClientRequest(\n            project_id=test_project.id,\n            title=\"Analyzed Request\",\n            content=\"This is analyzed\",\n            source=RequestSource.CHAT,\n            status=RequestStatus.ANALYZED,\n            classification=ScopeClassification.IN_SCOPE,\n        )\n        db_session.add_all([new_request, analyzed_request])\n        await db_session.commit()\n\n        # Filter by new status (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"status\": \"new\"},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"status\"] == \"new\"\n\n        # Filter by analyzed status (lowercase)\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"status\": \"analyzed\"},\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert len(data[\"items\"]) == 1\n        assert data[\"items\"][0][\"status\"] == \"analyzed\""
    },
    {
      "name": "TestManualAnalyzeEndpoint",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 405,
      "docstring": "Test manual analysis trigger endpoint.",
      "bases": [],
      "methods": [
        "test_manual_analyze_endpoint"
      ],
      "decorators": [],
      "source": "class TestManualAnalyzeEndpoint:\n    \"\"\"Test manual analysis trigger endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_manual_analyze_endpoint(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n        mock_analyze_client_request,\n    ):\n        \"\"\"\n        Create request with auto_analyze=False.\n        Call /analyze endpoint.\n        Verify analysis results returned and saved.\n        \"\"\"\n        # Create request without analysis\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Pending Request\",\n                \"content\": \"This needs manual analysis\",\n                \"source\": \"call\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n        assert create_response.json()[\"classification\"] == \"pending\"\n\n        # Trigger manual analysis\n        analyze_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}/analyze\",\n            headers=auth_headers,\n        )\n\n        assert analyze_response.status_code == 200\n        analysis_data = analyze_response.json()\n\n        assert \"classification\" in analysis_data\n        assert \"confidence\" in analysis_data\n        assert \"reasoning\" in analysis_data\n        assert \"suggested_action\" in analysis_data\n        assert \"scope_creep_indicators\" in analysis_data\n\n        # Verify request was updated\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n        )\n\n        assert get_response.status_code == 200\n        updated_data = get_response.json()\n        assert updated_data[\"status\"] == \"analyzed\"\n        assert updated_data[\"classification\"] != \"pending\""
    },
    {
      "name": "TestUpdateRequestStatus",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 470,
      "docstring": "Test updating request status.",
      "bases": [],
      "methods": [
        "test_update_request_status"
      ],
      "decorators": [],
      "source": "class TestUpdateRequestStatus:\n    \"\"\"Test updating request status.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_update_request_status(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Update status to addressed, verify change persisted.\"\"\"\n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Status Test\",\n                \"content\": \"Testing status update\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Update status (lowercase)\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"status\": \"addressed\"},\n        )\n\n        assert update_response.status_code == 200, f\"Response: {update_response.json()}\"\n        assert update_response.json()[\"status\"] == \"addressed\"\n\n        # Verify persistence\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n        )\n\n        assert get_response.json()[\"status\"] == \"addressed\""
    },
    {
      "name": "TestUpdateRequestLinkScopeItem",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 519,
      "docstring": "Test manually linking request to scope item.",
      "bases": [],
      "methods": [
        "test_update_request_link_scope_item"
      ],
      "decorators": [],
      "source": "class TestUpdateRequestLinkScopeItem:\n    \"\"\"Test manually linking request to scope item.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_update_request_link_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        test_scope_item: ScopeItem,\n    ):\n        \"\"\"Manually link request to scope item, verify linked_scope_item_id set.\"\"\"\n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Link Test\",\n                \"content\": \"Testing scope item linking\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Link to scope item\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"linked_scope_item_id\": str(test_scope_item.id)},\n        )\n\n        assert update_response.status_code == 200\n        assert update_response.json()[\"linked_scope_item_id\"] == str(test_scope_item.id)"
    },
    {
      "name": "TestCreateRequestEmptyScope",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 561,
      "docstring": "Test handling requests when project has no scope items.",
      "bases": [],
      "methods": [
        "test_create_request_empty_scope"
      ],
      "decorators": [],
      "source": "class TestCreateRequestEmptyScope:\n    \"\"\"Test handling requests when project has no scope items.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_empty_scope(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,  # Project without scope items\n    ):\n        \"\"\"\n        Project with no scope items.\n        auto_analyze=True.\n        Verify handles gracefully (likely out_of_scope).\n        \"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Empty Scope Test\",\n                \"content\": \"What happens with no scope items?\",\n                \"source\": \"other\",\n                \"auto_analyze\": True,\n            },\n        )\n\n        assert response.status_code == 201, f\"Response: {response.json()}\"\n        data = response.json()\n\n        # Should handle gracefully - either out_of_scope or specific handling\n        assert data[\"classification\"] == \"out_of_scope\"\n        assert data[\"status\"] == \"analyzed\"\n        assert \"no scope items\" in data[\"analysis_reasoning\"].lower()"
    },
    {
      "name": "TestRequestValidation",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 601,
      "docstring": "Test request validation.",
      "bases": [],
      "methods": [
        "test_create_request_missing_title",
        "test_create_request_empty_content"
      ],
      "decorators": [],
      "source": "class TestRequestValidation:\n    \"\"\"Test request validation.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_create_request_missing_title(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify validation error for missing title.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"content\": \"Content without title\",\n            },\n        )\n\n        assert response.status_code == 422\n\n    @pytest.mark.asyncio\n    async def test_create_request_empty_content(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify validation error for empty content.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Test\",\n                \"content\": \"\",\n            },\n        )\n\n        assert response.status_code == 422"
    },
    {
      "name": "TestRequestNotFound",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 647,
      "docstring": "Test 404 handling.",
      "bases": [],
      "methods": [
        "test_get_nonexistent_request",
        "test_get_request_wrong_project"
      ],
      "decorators": [],
      "source": "class TestRequestNotFound:\n    \"\"\"Test 404 handling.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_get_nonexistent_request(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify 404 for non-existent request.\"\"\"\n        import uuid\n        fake_uuid = uuid.uuid4()\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests/{fake_uuid}\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == 404\n\n    @pytest.mark.asyncio\n    async def test_get_request_wrong_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        other_user_project: Project,\n        other_auth_headers: dict,\n    ):\n        \"\"\"Verify 404 when accessing request from wrong project.\"\"\"\n        # Create request in test_project\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Cross Project Test\",\n                \"content\": \"Test content\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Try to access from other_user_project (different owner)\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/requests/{request_id}\",\n            headers=other_auth_headers,\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "TestInvalidScopeItemLink",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 705,
      "docstring": "Test invalid scope item linking.",
      "bases": [],
      "methods": [
        "test_link_invalid_scope_item"
      ],
      "decorators": [],
      "source": "class TestInvalidScopeItemLink:\n    \"\"\"Test invalid scope item linking.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_link_invalid_scope_item(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n    ):\n        \"\"\"Verify error when linking to non-existent scope item.\"\"\"\n        import uuid\n        \n        # Create a request\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Invalid Link Test\",\n                \"content\": \"Test content\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert create_response.status_code == 201, f\"Response: {create_response.json()}\"\n        request_id = create_response.json()[\"id\"]\n\n        # Try to link to non-existent scope item (use valid UUID format)\n        fake_scope_id = str(uuid.uuid4())\n        update_response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/requests/{request_id}\",\n            headers=auth_headers,\n            json={\"linked_scope_item_id\": fake_scope_id},\n        )\n\n        assert update_response.status_code == 400\n        assert \"scope item not found\" in update_response.json()[\"detail\"].lower()"
    },
    {
      "name": "TestRequestAuthorization",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 749,
      "docstring": "Test authorization for client requests.",
      "bases": [],
      "methods": [
        "test_cannot_access_other_users_project_requests",
        "test_cannot_create_request_in_other_users_project"
      ],
      "decorators": [],
      "source": "class TestRequestAuthorization:\n    \"\"\"Test authorization for client requests.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_cannot_access_other_users_project_requests(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_project: Project,\n    ):\n        \"\"\"Verify user cannot access requests from another user's project.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/requests\",\n            headers=auth_headers,\n        )\n\n        assert response.status_code == 404\n\n    @pytest.mark.asyncio\n    async def test_cannot_create_request_in_other_users_project(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        other_user_project: Project,\n    ):\n        \"\"\"Verify user cannot create request in another user's project.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{other_user_project.id}/requests\",\n            headers=auth_headers,\n            json={\n                \"title\": \"Unauthorized Request\",\n                \"content\": \"Should not be allowed\",\n                \"auto_analyze\": False,\n            },\n        )\n\n        assert response.status_code == 404"
    },
    {
      "name": "TestListRequestsPagination",
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 793,
      "docstring": "Test pagination for listing requests.",
      "bases": [],
      "methods": [
        "test_list_requests_pagination"
      ],
      "decorators": [],
      "source": "class TestListRequestsPagination:\n    \"\"\"Test pagination for listing requests.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_list_requests_pagination(\n        self,\n        client: AsyncClient,\n        auth_headers: dict,\n        test_project: Project,\n        db_session: AsyncSession,\n    ):\n        \"\"\"Test skip and limit parameters.\"\"\"\n        # Create multiple requests\n        for i in range(5):\n            request = ClientRequest(\n                project_id=test_project.id,\n                title=f\"Request {i}\",\n                content=f\"Content {i}\",\n                source=RequestSource.EMAIL,\n                status=RequestStatus.NEW,\n                classification=ScopeClassification.PENDING,\n            )\n            db_session.add(request)\n        await db_session.commit()\n\n        # Get first 2\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"skip\": 0, \"limit\": 2},\n        )\n\n        assert response.status_code == 200, f\"Response: {response.json()}\"\n        data = response.json()\n        assert len(data[\"items\"]) == 2\n        assert data[\"total\"] == 5\n        assert data[\"skip\"] == 0\n        assert data[\"limit\"] == 2\n\n        # Get next 2\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/requests\",\n            headers=auth_headers,\n            params={\"skip\": 2, \"limit\": 2},\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data[\"items\"]) == 2\n        assert data[\"skip\"] == 2"
    },
    {
      "name": "AnalyzeRequestCreate",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 16,
      "docstring": "Schema for creating and analyzing a new client request.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class AnalyzeRequestCreate(BaseModel):\n    \"\"\"Schema for creating and analyzing a new client request.\"\"\"\n\n    project_id: uuid.UUID\n    title: str = Field(..., min_length=1, max_length=255)\n    content: str = Field(..., min_length=1)\n    source: RequestSource = RequestSource.EMAIL"
    },
    {
      "name": "AnalyzeExisting",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 25,
      "docstring": "Schema for analyzing an existing client request.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class AnalyzeExisting(BaseModel):\n    \"\"\"Schema for analyzing an existing client request.\"\"\"\n\n    request_id: uuid.UUID"
    },
    {
      "name": "BulkAnalyzeRequest",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 31,
      "docstring": "Schema for bulk analyzing all requests in a project.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class BulkAnalyzeRequest(BaseModel):\n    \"\"\"Schema for bulk analyzing all requests in a project.\"\"\"\n\n    project_id: uuid.UUID\n    only_pending: bool = True"
    },
    {
      "name": "ScopeItemResponse",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 43,
      "docstring": "Schema for scope item in responses.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ScopeItemResponse(BaseModel):\n    \"\"\"Schema for scope item in responses.\"\"\"\n\n    id: uuid.UUID\n    title: str\n    description: str | None = None\n    order: int\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "AnalysisResultResponse",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 55,
      "docstring": "Schema for analysis result response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class AnalysisResultResponse(BaseModel):\n    \"\"\"Schema for analysis result response.\"\"\"\n\n    classification: ScopeClassification\n    confidence: Decimal = Field(..., ge=0, le=1)\n    reasoning: str\n    suggested_action: str\n    scope_creep_indicators: list[str]\n    matched_scope_item: ScopeItemResponse | None = None"
    },
    {
      "name": "ClientRequestResponse",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 66,
      "docstring": "Schema for client request response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientRequestResponse(BaseModel):\n    \"\"\"Schema for client request response.\"\"\"\n\n    id: uuid.UUID\n    project_id: uuid.UUID\n    title: str\n    content: str\n    source: RequestSource\n    status: RequestStatus\n    classification: ScopeClassification\n    confidence: Decimal | None = None\n    analysis_reasoning: str | None = None\n    suggested_action: str | None = None\n    linked_scope_item: ScopeItemResponse | None = None\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "AnalyzeResponse",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 85,
      "docstring": "Response schema for analyze endpoint.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class AnalyzeResponse(BaseModel):\n    \"\"\"Response schema for analyze endpoint.\"\"\"\n\n    client_request: ClientRequestResponse\n    analysis: AnalysisResultResponse"
    },
    {
      "name": "BulkAnalyzeResponse",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 92,
      "docstring": "Response schema for bulk analyze endpoint.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class BulkAnalyzeResponse(BaseModel):\n    \"\"\"Response schema for bulk analyze endpoint.\"\"\"\n\n    analyzed_count: int\n    results: list[AnalyzeResponse]"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 51,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 81,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "UserUpdate",
      "file_path": "app/schemas/user.py",
      "line_number": 8,
      "docstring": "Schema for updating user profile.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UserUpdate(BaseModel):\n    \"\"\"Schema for updating user profile.\"\"\"\n\n    full_name: str | None = Field(default=None, min_length=1, max_length=255)\n    business_name: str | None = Field(default=None, max_length=255)"
    },
    {
      "name": "UserProfile",
      "file_path": "app/schemas/user.py",
      "line_number": 15,
      "docstring": "Full user profile response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class UserProfile(BaseModel):\n    \"\"\"Full user profile response.\"\"\"\n\n    id: str\n    email: str\n    full_name: str\n    business_name: str | None\n    is_active: bool\n    created_at: datetime\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/user.py",
      "line_number": 25,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "TestAuthRegister",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 9,
      "docstring": "Tests for POST /api/v1/auth/register",
      "bases": [],
      "methods": [
        "test_register_success",
        "test_register_duplicate_email",
        "test_register_invalid_email",
        "test_register_short_password"
      ],
      "decorators": [],
      "source": "class TestAuthRegister:\n    \"\"\"Tests for POST /api/v1/auth/register\"\"\"\n    \n    async def test_register_success(self, client: AsyncClient):\n        \"\"\"Test successful user registration.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"newuser@example.com\",\n                \"password\": \"securepassword123\",\n                \"full_name\": \"New User\",\n                \"business_name\": \"New Business\",\n            },\n        )\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"email\"] == \"newuser@example.com\"\n        assert data[\"full_name\"] == \"New User\"\n        assert data[\"business_name\"] == \"New Business\"\n        assert data[\"is_active\"] is True\n        assert \"id\" in data\n        assert \"password\" not in data\n        assert \"hashed_password\" not in data\n    \n    async def test_register_duplicate_email(self, client: AsyncClient, test_user):\n        \"\"\"Test registration with existing email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"test@example.com\",  # Same as test_user\n                \"password\": \"anotherpassword123\",\n                \"full_name\": \"Another User\",\n            },\n        )\n        \n        assert response.status_code == 400\n        assert \"already registered\" in response.json()[\"detail\"].lower()\n    \n    async def test_register_invalid_email(self, client: AsyncClient):\n        \"\"\"Test registration with invalid email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"not-an-email\",\n                \"password\": \"securepassword123\",\n                \"full_name\": \"New User\",\n            },\n        )\n        \n        assert response.status_code == 422\n    \n    async def test_register_short_password(self, client: AsyncClient):\n        \"\"\"Test registration with short password fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"newuser@example.com\",\n                \"password\": \"short\",\n                \"full_name\": \"New User\",\n            },\n        )\n        \n        assert response.status_code == 422"
    },
    {
      "name": "TestAuthLogin",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 75,
      "docstring": "Tests for POST /api/v1/auth/login",
      "bases": [],
      "methods": [
        "test_login_success",
        "test_login_wrong_password",
        "test_login_nonexistent_user"
      ],
      "decorators": [],
      "source": "class TestAuthLogin:\n    \"\"\"Tests for POST /api/v1/auth/login\"\"\"\n    \n    async def test_login_success(self, client: AsyncClient, test_user):\n        \"\"\"Test successful login.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"test@example.com\",\n                \"password\": \"testpassword123\",\n            },\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert \"access_token\" in data\n        assert data[\"token_type\"] == \"bearer\"\n    \n    async def test_login_wrong_password(self, client: AsyncClient, test_user):\n        \"\"\"Test login with wrong password fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"test@example.com\",\n                \"password\": \"wrongpassword\",\n            },\n        )\n        \n        assert response.status_code == 401\n        assert \"incorrect\" in response.json()[\"detail\"].lower()\n    \n    async def test_login_nonexistent_user(self, client: AsyncClient):\n        \"\"\"Test login with nonexistent email fails.\"\"\"\n        response = await client.post(\n            \"/api/v1/auth/login\",\n            json={\n                \"email\": \"nonexistent@example.com\",\n                \"password\": \"anypassword123\",\n            },\n        )\n        \n        assert response.status_code == 401"
    },
    {
      "name": "TestAuthMe",
      "file_path": "tests/unit/test_auth.py",
      "line_number": 119,
      "docstring": "Tests for GET /api/v1/auth/me",
      "bases": [],
      "methods": [
        "test_get_current_user",
        "test_get_current_user_no_token",
        "test_get_current_user_invalid_token"
      ],
      "decorators": [],
      "source": "class TestAuthMe:\n    \"\"\"Tests for GET /api/v1/auth/me\"\"\"\n    \n    async def test_get_current_user(self, client: AsyncClient, auth_headers, test_user):\n        \"\"\"Test getting current user info.\"\"\"\n        response = await client.get(\n            \"/api/v1/auth/me\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"email\"] == \"test@example.com\"\n        assert data[\"full_name\"] == \"Test User\"\n    \n    async def test_get_current_user_no_token(self, client: AsyncClient):\n        \"\"\"Test getting current user without token fails.\"\"\"\n        response = await client.get(\"/api/v1/auth/me\")\n        \n        assert response.status_code == 403\n    \n    async def test_get_current_user_invalid_token(self, client: AsyncClient):\n        \"\"\"Test getting current user with invalid token fails.\"\"\"\n        response = await client.get(\n            \"/api/v1/auth/me\",\n            headers={\"Authorization\": \"Bearer invalidtoken\"},\n        )\n        \n        assert response.status_code == 401"
    },
    {
      "name": "Settings",
      "file_path": "app/core/config.py",
      "line_number": 12,
      "docstring": "Application settings loaded from environment variables.",
      "bases": [
        "BaseSettings"
      ],
      "methods": [],
      "decorators": [],
      "source": "class Settings(BaseSettings):\n    \"\"\"Application settings loaded from environment variables.\"\"\"\n    \n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n    \n    # Application\n    app_name: str = \"Freelancer Project Shield\"\n    app_version: str = \"0.1.0\"\n    debug: bool = False\n    environment: Literal[\"development\", \"testing\", \"production\"] = \"development\"\n    \n    # API\n    api_v1_prefix: str = \"/api/v1\"\n    \n    # Database\n    database_url: str = \"postgresql+asyncpg://postgres:postgres@localhost:5432/freelancer_shield\"\n    database_echo: bool = False  # Set True to log SQL queries\n    \n    # Authentication\n    secret_key: str = \"CHANGE-THIS-IN-PRODUCTION-use-openssl-rand-hex-32\"\n    algorithm: str = \"HS256\"\n    access_token_expire_days: int = 7\n    bcrypt_rounds: int = 12\n    \n    # AI / Scope Analyzer\n    openai_api_key: str = \"\"\n    use_ai_analyzer: bool = False  # Set True when OpenAI key is configured\n    openai_model: str = \"gpt-4\"\n    \n    # CORS\n    cors_origins: list[str] = [\"http://localhost:3000\", \"http://localhost:5173\"]"
    },
    {
      "name": "ClientRequestCreate",
      "file_path": "app/schemas/client_request.py",
      "line_number": 14,
      "docstring": "Schema for creating a new client request.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientRequestCreate(BaseModel):\n    \"\"\"Schema for creating a new client request.\"\"\"\n    title: str = Field(min_length=1, max_length=255)\n    content: str = Field(min_length=1)\n    source: RequestSource = RequestSource.EMAIL\n    auto_analyze: bool = Field(\n        default=True,\n        description=\"Automatically run scope analysis on creation\"\n    )"
    },
    {
      "name": "ClientRequestUpdate",
      "file_path": "app/schemas/client_request.py",
      "line_number": 25,
      "docstring": "Schema for updating an existing client request.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientRequestUpdate(BaseModel):\n    \"\"\"Schema for updating an existing client request.\"\"\"\n    title: Optional[str] = Field(default=None, min_length=1, max_length=255)\n    content: Optional[str] = Field(default=None, min_length=1)\n    source: Optional[RequestSource] = None\n    status: Optional[RequestStatus] = None\n    classification: Optional[ScopeClassification] = Field(\n        default=None,\n        description=\"Manually override the AI classification\"\n    )\n    linked_scope_item_id: Optional[UUID] = Field(\n        default=None,\n        description=\"Manually link to a scope item\"\n    )"
    },
    {
      "name": "ClientRequestResponse",
      "file_path": "app/schemas/client_request.py",
      "line_number": 41,
      "docstring": "Schema for client request response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientRequestResponse(BaseModel):\n    \"\"\"Schema for client request response.\"\"\"\n    id: UUID\n    project_id: UUID\n    linked_scope_item_id: Optional[UUID] = None\n    title: str\n    content: str\n    source: RequestSource\n    status: RequestStatus\n    classification: ScopeClassification\n    confidence: Optional[Decimal] = None\n    analysis_reasoning: Optional[str] = None\n    suggested_action: Optional[str] = None\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "AnalyzeRequestResponse",
      "file_path": "app/schemas/client_request.py",
      "line_number": 61,
      "docstring": "Response from manual analysis trigger.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class AnalyzeRequestResponse(BaseModel):\n    \"\"\"Response from manual analysis trigger.\"\"\"\n    classification: ScopeClassification\n    confidence: float\n    reasoning: str\n    matched_scope_item_id: Optional[UUID] = None\n    suggested_action: str\n    scope_creep_indicators: list[str] = Field(default_factory=list)"
    },
    {
      "name": "ClientRequestListResponse",
      "file_path": "app/schemas/client_request.py",
      "line_number": 71,
      "docstring": "Response for listing client requests with pagination info.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ClientRequestListResponse(BaseModel):\n    \"\"\"Response for listing client requests with pagination info.\"\"\"\n    items: list[ClientRequestResponse]\n    total: int\n    skip: int\n    limit: int"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/client_request.py",
      "line_number": 57,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "TestRulesAnalyzer",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 98,
      "docstring": "Test cases for the rules-based analyzer.",
      "bases": [],
      "methods": [
        "test_in_scope_exact_match",
        "test_in_scope_fuzzy_match",
        "test_out_of_scope_no_match",
        "test_out_of_scope_with_indicators",
        "test_clarification_needed",
        "test_revision_request",
        "test_empty_scope",
        "test_long_request_multiple_items",
        "test_suggested_action_for_out_of_scope",
        "test_confidence_ranges"
      ],
      "decorators": [],
      "source": "class TestRulesAnalyzer:\n    \"\"\"Test cases for the rules-based analyzer.\"\"\"\n\n    def test_in_scope_exact_match(self, basic_scope_items):\n        \"\"\"Test 1: Exact match returns IN_SCOPE with high confidence.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Working on the login page design\",\n            scope_items=basic_scope_items,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"in_scope\"\n        assert result.confidence >= 0.6\n        assert result.matched_scope_item_index == 0\n        assert result.matched_scope_item_id == basic_scope_items[0].id\n\n    def test_in_scope_fuzzy_match(self, single_scope_item):\n        \"\"\"Test 2: Fuzzy match returns IN_SCOPE.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Working on implementing the user authentication system now\",\n            scope_items=single_scope_item,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"in_scope\"\n        assert result.confidence >= 0.5\n\n    def test_out_of_scope_no_match(self):\n        \"\"\"Test 3: No match with scope creep indicator.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you also build a mobile app?\",\n            scope_items=[\n                ScopeItemDTO(title=\"Build homepage\"),\n                ScopeItemDTO(title=\"Create contact form\"),\n            ],\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert result.confidence >= 0.7\n        assert \"also\" in result.scope_creep_indicators\n\n    def test_out_of_scope_with_indicators(self, design_scope):\n        \"\"\"Test 4: Multiple scope creep indicators detected.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Quick addition - can you also create business cards? Shouldn't take long\",\n            scope_items=design_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"quick addition\" in result.scope_creep_indicators\n        assert \"also\" in result.scope_creep_indicators\n        assert \"shouldn't take long\" in result.scope_creep_indicators\n\n    def test_clarification_needed(self, ecommerce_scope):\n        \"\"\"Test 5: Clarification question returns CLARIFICATION_NEEDED.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you explain what payment gateways you'll support?\",\n            scope_items=ecommerce_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"clarification_needed\"\n\n    def test_revision_request(self, header_scope):\n        \"\"\"Test 6: Revision request returns REVISION.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Actually, can we change the blue header design to use red instead?\",\n            scope_items=header_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"revision\"\n        assert result.matched_scope_item_index == 0\n\n    def test_empty_scope(self):\n        \"\"\"Test 7: Empty scope returns OUT_OF_SCOPE.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Build the homepage\",\n            scope_items=[],\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"no scope\" in result.reasoning.lower()\n\n    def test_long_request_multiple_items(self, api_scope):\n        \"\"\"Test 8: Long request with scope creep indicators.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"I need the API done by Friday. Also, can you add a mobile app?\",\n            scope_items=api_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"also\" in result.scope_creep_indicators\n\n    def test_suggested_action_for_out_of_scope(self, design_scope):\n        \"\"\"Test 9: OUT_OF_SCOPE suggests proposal/quote.\"\"\"\n        request = AnalysisRequest(\n            request_content=\"Can you also build me a website?\",\n            scope_items=design_scope,\n        )\n\n        result = analyze_with_rules(request)\n\n        assert result.classification == \"out_of_scope\"\n        assert \"proposal\" in result.suggested_action.lower() or \"quote\" in result.suggested_action.lower()\n\n    def test_confidence_ranges(self, basic_scope_items):\n        \"\"\"Test 10: Confidence is always between 0.0 and 1.0.\"\"\"\n        test_requests = [\n            \"Working on the login page\",\n            \"Can you also build something else?\",\n            \"What do you mean by authentication?\",\n            \"Change it to red instead\",\n            \"Random unrelated text here\",\n        ]\n\n        for content in test_requests:\n            request = AnalysisRequest(\n                request_content=content,\n                scope_items=basic_scope_items,\n            )\n            result = analyze_with_rules(request)\n            assert 0.0 <= result.confidence <= 1.0"
    },
    {
      "name": "TestAIAnalyzer",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 240,
      "docstring": "Test cases for the AI-powered analyzer.",
      "bases": [],
      "methods": [
        "test_ai_analyzer_success",
        "test_ai_analyzer_fallback_on_error",
        "test_ai_analyzer_invalid_response"
      ],
      "decorators": [],
      "source": "class TestAIAnalyzer:\n    \"\"\"Test cases for the AI-powered analyzer.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_ai_analyzer_success(self, basic_scope_items):\n        \"\"\"Test 11: Successful AI analysis.\"\"\"\n        mock_response = {\n            \"choices\": [\n                {\n                    \"message\": {\n                        \"content\": json.dumps(\n                            {\n                                \"classification\": \"in_scope\",\n                                \"confidence\": 0.9,\n                                \"reasoning\": \"Matches login page scope.\",\n                                \"matched_scope_item_index\": 0,\n                                \"suggested_action\": \"Proceed.\",\n                                \"scope_creep_indicators\": [],\n                            }\n                        )\n                    }\n                }\n            ]\n        }\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_http_response = MagicMock()\n            mock_http_response.json.return_value = mock_response\n            mock_http_response.raise_for_status = MagicMock()\n            mock_client.post.return_value = mock_http_response\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert result.classification == \"in_scope\"\n            assert result.confidence == 0.9\n\n    @pytest.mark.asyncio\n    async def test_ai_analyzer_fallback_on_error(self, basic_scope_items):\n        \"\"\"Test 12: AI analyzer falls back to rules on error.\"\"\"\n        import httpx\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_response = MagicMock()\n            mock_response.status_code = 500\n            mock_client.post.return_value = mock_response\n            mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(\n                \"Error\", request=MagicMock(), response=mock_response\n            )\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert isinstance(result, AnalysisResult)\n\n    @pytest.mark.asyncio\n    async def test_ai_analyzer_invalid_response(self, basic_scope_items):\n        \"\"\"Test 13: AI analyzer handles malformed JSON.\"\"\"\n        mock_response = {\n            \"choices\": [{\"message\": {\"content\": \"This is not valid JSON!\"}}]\n        }\n\n        with patch(\"httpx.AsyncClient\") as mock_client_class:\n            mock_client = AsyncMock()\n            mock_client_class.return_value.__aenter__.return_value = mock_client\n\n            mock_http_response = MagicMock()\n            mock_http_response.json.return_value = mock_response\n            mock_http_response.raise_for_status = MagicMock()\n            mock_client.post.return_value = mock_http_response\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_with_ai(request, api_key=\"test-key\")\n\n            assert isinstance(result, AnalysisResult)"
    },
    {
      "name": "TestAnalyzerFactory",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 340,
      "docstring": "Test cases for the analyzer factory pattern.",
      "bases": [],
      "methods": [
        "test_uses_rules_when_no_api_key",
        "test_uses_ai_when_configured"
      ],
      "decorators": [],
      "source": "class TestAnalyzerFactory:\n    \"\"\"Test cases for the analyzer factory pattern.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_uses_rules_when_no_api_key(self, basic_scope_items):\n        \"\"\"Test 14: Uses rules when no API key configured.\"\"\"\n        with patch(\"app.services.scope_analyzer.analyzer.settings\") as mock_settings:\n            mock_settings.OPENAI_API_KEY = \"\"\n            mock_settings.USE_AI_ANALYZER = False\n\n            request = AnalysisRequest(\n                request_content=\"Working on the login page\",\n                scope_items=basic_scope_items,\n            )\n\n            result = await analyze_scope(request)\n\n            assert isinstance(result, AnalysisResult)\n\n    @pytest.mark.asyncio\n    async def test_uses_ai_when_configured(self, basic_scope_items):\n        \"\"\"Test 15: Uses AI when configured.\"\"\"\n        mock_ai_result = AnalysisResult(\n            classification=\"in_scope\",\n            confidence=0.95,\n            reasoning=\"AI determined in scope.\",\n            matched_scope_item_index=0,\n            matched_scope_item_id=None,\n            suggested_action=\"Proceed.\",\n            scope_creep_indicators=[],\n        )\n\n        with patch(\"app.services.scope_analyzer.analyzer.settings\") as mock_settings:\n            mock_settings.OPENAI_API_KEY = \"test-key\"\n            mock_settings.USE_AI_ANALYZER = True\n            mock_settings.OPENAI_MODEL = \"gpt-4\"\n\n            with patch(\n                \"app.services.scope_analyzer.analyzer.analyze_with_ai\",\n                return_value=mock_ai_result,\n            ) as mock_ai:\n                request = AnalysisRequest(\n                    request_content=\"Working on the login page\",\n                    scope_items=basic_scope_items,\n                )\n\n                result = await analyze_scope(request)\n\n                mock_ai.assert_called_once()\n                assert result.classification == \"in_scope\""
    },
    {
      "name": "TestClassificationMap",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 397,
      "docstring": "Test the classification mapping.",
      "bases": [],
      "methods": [
        "test_classification_map_completeness"
      ],
      "decorators": [],
      "source": "class TestClassificationMap:\n    \"\"\"Test the classification mapping.\"\"\"\n\n    def test_classification_map_completeness(self):\n        \"\"\"Ensure all classifications are mapped.\"\"\"\n        from app.models.enums import ScopeClassification\n\n        expected = {\"in_scope\", \"out_of_scope\", \"clarification_needed\", \"revision\"}\n        assert set(CLASSIFICATION_MAP.keys()) == expected\n\n        # Each maps to a valid enum\n        for key, value in CLASSIFICATION_MAP.items():\n            assert isinstance(value, ScopeClassification)"
    },
    {
      "name": "TestResultConversion",
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 412,
      "docstring": "Test result conversion methods.",
      "bases": [],
      "methods": [
        "test_to_client_request_update"
      ],
      "decorators": [],
      "source": "class TestResultConversion:\n    \"\"\"Test result conversion methods.\"\"\"\n\n    def test_to_client_request_update(self):\n        \"\"\"Test converting result to DB update fields.\"\"\"\n        scope_id = uuid.uuid4()\n        result = AnalysisResult(\n            classification=\"out_of_scope\",\n            confidence=0.85,\n            reasoning=\"Test reasoning\",\n            matched_scope_item_index=None,\n            matched_scope_item_id=scope_id,\n            suggested_action=\"Send proposal\",\n            scope_creep_indicators=[\"also\"],\n        )\n\n        fields = result.to_client_request_update()\n\n        assert fields[\"classification\"] == \"out_of_scope\"\n        assert fields[\"confidence\"] == Decimal(\"0.85\")\n        assert fields[\"analysis_reasoning\"] == \"Test reasoning\"\n        assert fields[\"suggested_action\"] == \"Send proposal\"\n        assert fields[\"linked_scope_item_id\"] == scope_id"
    },
    {
      "name": "Project",
      "file_path": "app/models/project.py",
      "line_number": 16,
      "docstring": "A freelance project with scope tracking.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class Project(BaseModel):\n    \"\"\"A freelance project with scope tracking.\"\"\"\n    \n    __tablename__ = \"projects\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4,\n    )\n    \n    user_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"users.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    client_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"clients.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    name: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    description: Mapped[str | None] = mapped_column(\n        Text,\n        nullable=True,\n    )\n    status: Mapped[ProjectStatus] = mapped_column(\n        default=ProjectStatus.ACTIVE,\n        nullable=False,\n    )\n    budget: Mapped[Decimal | None] = mapped_column(\n        Numeric(10, 2),\n        nullable=True,\n    )\n    hourly_rate: Mapped[Decimal | None] = mapped_column(\n        Numeric(10, 2),\n        nullable=True,\n    )\n    estimated_hours: Mapped[Decimal | None] = mapped_column(\n        Numeric(5, 1),\n        nullable=True,\n    )\n    \n    # Relationships\n    user: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"projects\",\n    )\n    client: Mapped[\"Client\"] = relationship(\n        \"Client\",\n        back_populates=\"projects\",\n    )\n    scope_items: Mapped[list[\"ScopeItem\"]] = relationship(\n        \"ScopeItem\",\n        back_populates=\"project\",\n        cascade=\"all, delete-orphan\",\n        order_by=\"ScopeItem.order\",\n    )\n    client_requests: Mapped[list[\"ClientRequest\"]] = relationship(\n        \"ClientRequest\",\n        back_populates=\"project\",\n        cascade=\"all, delete-orphan\",\n        order_by=\"ClientRequest.created_at.desc()\",\n    )\n    proposals: Mapped[list[\"Proposal\"]] = relationship(\n        \"Proposal\",\n        back_populates=\"project\",\n        cascade=\"all, delete-orphan\",\n        order_by=\"Proposal.created_at.desc()\",\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<Project {self.name}>\""
    },
    {
      "name": "TimestampMixin",
      "file_path": "app/models/base.py",
      "line_number": 18,
      "docstring": "Mixin that adds created_at and updated_at timestamps.",
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "class TimestampMixin:\n    \"\"\"Mixin that adds created_at and updated_at timestamps.\"\"\"\n    \n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        server_default=func.now(),\n        nullable=False,\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        server_default=func.now(),\n        onupdate=func.now(),\n        nullable=False,\n    )"
    },
    {
      "name": "UUIDMixin",
      "file_path": "app/models/base.py",
      "line_number": 34,
      "docstring": "Mixin that adds a UUID primary key.",
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "class UUIDMixin:\n    \"\"\"Mixin that adds a UUID primary key.\"\"\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        UUID(as_uuid=True),\n        primary_key=True,\n        default=uuid.uuid4,\n    )"
    },
    {
      "name": "BaseModel",
      "file_path": "app/models/base.py",
      "line_number": 44,
      "docstring": "Base model with UUID primary key and timestamps.",
      "bases": [
        "Base",
        "UUIDMixin",
        "TimestampMixin"
      ],
      "methods": [],
      "decorators": [],
      "source": "class BaseModel(Base, UUIDMixin, TimestampMixin):\n    \"\"\"Base model with UUID primary key and timestamps.\"\"\"\n    \n    __abstract__ = True"
    },
    {
      "name": "GUID",
      "file_path": "app/models/base.py",
      "line_number": 51,
      "docstring": "Platform-independent GUID type.\nStores UUIDs as native UUID on PostgreSQL, and as CHAR(32) on SQLite.",
      "bases": [
        "TypeDecorator"
      ],
      "methods": [
        "load_dialect_impl",
        "process_bind_param",
        "process_result_value"
      ],
      "decorators": [],
      "source": "class GUID(TypeDecorator):\n    \"\"\"\n    Platform-independent GUID type.\n    Stores UUIDs as native UUID on PostgreSQL, and as CHAR(32) on SQLite.\n    \"\"\"\n    impl = CHAR\n    cache_ok = True\n\n    def load_dialect_impl(self, dialect):\n        # Use native UUID type for PostgreSQL\n        if dialect.name == 'postgresql':\n            return dialect.type_descriptor(postgresql.UUID())\n        # Use CHAR(32) (TEXT) for SQLite and others\n        return dialect.type_descriptor(CHAR(32))\n\n    def process_bind_param(self, value, dialect):\n        if value is None:\n            return value\n        # Ensure the value is converted to a string format SQLite can store\n        if isinstance(value, uuid.UUID):\n            if dialect.name != 'postgresql':\n                return value.hex\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        # Convert stored string back to Python UUID object\n        if dialect.name != 'postgresql':\n            return uuid.UUID(value)\n        return value"
    },
    {
      "name": "ProjectCreate",
      "file_path": "app/schemas/project.py",
      "line_number": 12,
      "docstring": "Schema for creating a new project.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectCreate(BaseModel):\n    \"\"\"Schema for creating a new project.\"\"\"\n    \n    client_id: str = Field(..., description=\"UUID of the client as string\")\n    name: str = Field(..., min_length=1, max_length=255)\n    description: str | None = None\n    status: ProjectStatus = ProjectStatus.ACTIVE\n    budget: Decimal | None = Field(default=None, ge=0)\n    hourly_rate: Decimal | None = Field(default=None, ge=0)\n    estimated_hours: Decimal | None = Field(default=None, ge=0)"
    },
    {
      "name": "ProjectUpdate",
      "file_path": "app/schemas/project.py",
      "line_number": 24,
      "docstring": "Schema for updating an existing project.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectUpdate(BaseModel):\n    \"\"\"Schema for updating an existing project.\"\"\"\n    \n    name: str | None = Field(default=None, min_length=1, max_length=255)\n    description: str | None = None\n    status: ProjectStatus | None = None\n    budget: Decimal | None = Field(default=None, ge=0)\n    hourly_rate: Decimal | None = Field(default=None, ge=0)\n    estimated_hours: Decimal | None = Field(default=None, ge=0)"
    },
    {
      "name": "ProjectResponse",
      "file_path": "app/schemas/project.py",
      "line_number": 35,
      "docstring": "Schema for project response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectResponse(BaseModel):\n    \"\"\"Schema for project response.\"\"\"\n    \n    id: str\n    client_id: str\n    client_name: str  # Joined from client\n    name: str\n    description: str | None\n    status: ProjectStatus\n    budget: Decimal | None\n    hourly_rate: Decimal | None\n    estimated_hours: Decimal | None\n    created_at: datetime\n    updated_at: datetime\n    # Computed stats\n    scope_item_count: int = 0\n    completed_scope_count: int = 0\n    out_of_scope_request_count: int = 0\n\n    class Config:\n        from_attributes = True"
    },
    {
      "name": "ProjectDetail",
      "file_path": "app/schemas/project.py",
      "line_number": 58,
      "docstring": "Extended project with related data.",
      "bases": [
        "ProjectResponse"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectDetail(ProjectResponse):\n    \"\"\"Extended project with related data.\"\"\"\n    \n    scope_items: list[dict[str, Any]] = []  # Will be ScopeItemResponse later\n    recent_requests: list[dict[str, Any]] = []  # Will be ClientRequestResponse later"
    },
    {
      "name": "ProjectList",
      "file_path": "app/schemas/project.py",
      "line_number": 65,
      "docstring": "Schema for paginated project list response.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectList(BaseModel):\n    \"\"\"Schema for paginated project list response.\"\"\"\n    \n    projects: list[ProjectResponse]\n    total: int"
    },
    {
      "name": "Config",
      "file_path": "app/schemas/project.py",
      "line_number": 54,
      "docstring": null,
      "bases": [],
      "methods": [],
      "decorators": [],
      "source": "    class Config:\n        from_attributes = True"
    },
    {
      "name": "ScopeItem",
      "file_path": "app/models/scope_item.py",
      "line_number": 16,
      "docstring": "An individual item in a project's scope of work.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class ScopeItem(BaseModel):\n    \"\"\"An individual item in a project's scope of work.\"\"\"\n    \n    __tablename__ = \"scope_items\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4,\n    )\n    \n    project_id: Mapped[uuid.UUID] = mapped_column(\n        GUID(),\n        ForeignKey(\"projects.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n    title: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    description: Mapped[str | None] = mapped_column(\n        Text,\n        nullable=True,\n    )\n    order: Mapped[int] = mapped_column(\n        Integer,\n        default=0,\n        nullable=False,\n    )\n    is_completed: Mapped[bool] = mapped_column(\n        default=False,\n        nullable=False,\n    )\n    estimated_hours: Mapped[Decimal | None] = mapped_column(\n        Numeric(5, 1),\n        nullable=True,\n    )\n    \n    # Relationships\n    project: Mapped[\"Project\"] = relationship(\n        \"Project\",\n        back_populates=\"scope_items\",\n    )\n    linked_requests: Mapped[list[\"ClientRequest\"]] = relationship(\n        \"ClientRequest\",\n        back_populates=\"linked_scope_item\",\n        foreign_keys=\"ClientRequest.linked_scope_item_id\",\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<ScopeItem {self.title}>\""
    },
    {
      "name": "TestGetProfile",
      "file_path": "tests/unit/test_users.py",
      "line_number": 40,
      "docstring": "Tests for GET /api/v1/users/profile endpoint.",
      "bases": [],
      "methods": [
        "test_get_profile_success",
        "test_get_profile_unauthorized"
      ],
      "decorators": [],
      "source": "class TestGetProfile:\n    \"\"\"Tests for GET /api/v1/users/profile endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_get_profile_success(self, mock_user, auth_headers):\n        \"\"\"\n        Test that an authenticated user can successfully retrieve their profile.\n        Verifies all fields are returned including created_at.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.get(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"id\"] == \"test-user-id-123\"\n            assert data[\"email\"] == \"test@example.com\"\n            assert data[\"full_name\"] == \"Test User\"\n            assert data[\"business_name\"] == \"Test Business\"\n            assert data[\"is_active\"] is True\n            assert \"created_at\" in data\n        finally:\n            app.dependency_overrides.clear()\n\n    @pytest.mark.asyncio\n    async def test_get_profile_unauthorized(self):\n        \"\"\"\n        Test that unauthenticated requests are rejected.\n        Expected: 403 Forbidden.\n        \"\"\"\n        app.dependency_overrides.clear()\n\n        async with AsyncClient(\n            transport=ASGITransport(app=app),\n            base_url=\"http://test\",\n        ) as client:\n            response = await client.get(\"/api/v1/users/profile\")\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "TestUpdateProfile",
      "file_path": "tests/unit/test_users.py",
      "line_number": 90,
      "docstring": "Tests for PATCH /api/v1/users/profile endpoint.",
      "bases": [],
      "methods": [
        "test_update_profile_full_name",
        "test_update_profile_business_name",
        "test_update_profile_both_fields",
        "test_update_profile_unauthorized",
        "test_update_profile_empty_body",
        "test_update_profile_full_name_validation"
      ],
      "decorators": [],
      "source": "class TestUpdateProfile:\n    \"\"\"Tests for PATCH /api/v1/users/profile endpoint.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_update_profile_full_name(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating only the full_name field.\n        Verifies full_name changes while other fields remain unchanged.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.full_name = \"Updated Name\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"full_name\": \"Updated Name\"},\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"full_name\"] == \"Updated Name\"\n            assert data[\"email\"] == \"test@example.com\"\n            assert data[\"business_name\"] == \"Test Business\"\n        finally:\n            app.dependency_overrides.clear()\n\n    @pytest.mark.asyncio\n    async def test_update_profile_business_name(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating only the business_name field.\n        Verifies business_name changes while other fields remain unchanged.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.business_name = \"New Business LLC\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"business_name\": \"New Business LLC\"},\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"business_name\"] == \"New Business LLC\"\n            assert data[\"full_name\"] == \"Test User\"\n            assert data[\"email\"] == \"test@example.com\"\n        finally:\n            app.dependency_overrides.clear()\n\n    @pytest.mark.asyncio\n    async def test_update_profile_both_fields(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test updating both full_name and business_name simultaneously.\n        Verifies both fields are updated correctly.\n        \"\"\"\n\n        async def mock_refresh(obj):\n            obj.full_name = \"New Full Name\"\n            obj.business_name = \"New Business Name\"\n\n        mock_db.refresh = mock_refresh\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\n                        \"full_name\": \"New Full Name\",\n                        \"business_name\": \"New Business Name\",\n                    },\n                )\n\n            assert response.status_code == status.HTTP_200_OK\n            data = response.json()\n\n            assert data[\"full_name\"] == \"New Full Name\"\n            assert data[\"business_name\"] == \"New Business Name\"\n        finally:\n            app.dependency_overrides.clear()\n\n    @pytest.mark.asyncio\n    async def test_update_profile_unauthorized(self):\n        \"\"\"\n        Test that unauthenticated update requests are rejected.\n        Expected: 403 Forbidden.\n        \"\"\"\n        app.dependency_overrides.clear()\n\n        async with AsyncClient(\n            transport=ASGITransport(app=app),\n            base_url=\"http://test\",\n        ) as client:\n            response = await client.patch(\n                \"/api/v1/users/profile\",\n                json={\"full_name\": \"Hacker\"},\n            )\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    @pytest.mark.asyncio\n    async def test_update_profile_empty_body(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test that empty update requests are rejected.\n        Expected: 400 Bad Request.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={},\n                )\n\n            assert response.status_code == status.HTTP_400_BAD_REQUEST\n            assert \"No fields to update\" in response.json()[\"detail\"]\n        finally:\n            app.dependency_overrides.clear()\n\n    @pytest.mark.asyncio\n    async def test_update_profile_full_name_validation(self, mock_user, mock_db, auth_headers):\n        \"\"\"\n        Test that full_name validation is enforced (min_length=1).\n        Expected: 422 Unprocessable Entity for empty string.\n        \"\"\"\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n        app.dependency_overrides[get_db] = lambda: mock_db\n\n        try:\n            async with AsyncClient(\n                transport=ASGITransport(app=app),\n                base_url=\"http://test\",\n            ) as client:\n                response = await client.patch(\n                    \"/api/v1/users/profile\",\n                    headers=auth_headers,\n                    json={\"full_name\": \"\"},\n                )\n\n            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        finally:\n            app.dependency_overrides.clear()"
    },
    {
      "name": "ScopeItemDTO",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 28,
      "docstring": "A single item from the project scope (DTO for analysis).",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "from_db_model"
      ],
      "decorators": [],
      "source": "class ScopeItemDTO(BaseModel):\n    \"\"\"A single item from the project scope (DTO for analysis).\"\"\"\n\n    id: uuid.UUID | None = None\n    title: str\n    description: str | None = None\n    order: int = 0\n\n    @classmethod\n    def from_db_model(cls, db_scope_item: \"DBScopeItem\") -> \"ScopeItemDTO\":\n        \"\"\"Create DTO from SQLAlchemy ScopeItem model.\"\"\"\n        return cls(\n            id=db_scope_item.id,\n            title=db_scope_item.title,\n            description=db_scope_item.description,\n            order=db_scope_item.order,\n        )"
    },
    {
      "name": "AnalysisRequest",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 47,
      "docstring": "Input for scope analysis.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "from_client_request"
      ],
      "decorators": [],
      "source": "class AnalysisRequest(BaseModel):\n    \"\"\"Input for scope analysis.\"\"\"\n\n    request_content: str\n    scope_items: list[ScopeItemDTO]\n    project_context: str | None = None\n\n    @classmethod\n    def from_client_request(\n        cls,\n        client_request: \"ClientRequest\",\n        project: \"Project | None\" = None,\n    ) -> \"AnalysisRequest\":\n        \"\"\"\n        Create an AnalysisRequest from a ClientRequest and its Project.\n\n        Args:\n            client_request: SQLAlchemy ClientRequest model instance\n            project: Optional Project model (uses client_request.project if not provided)\n\n        Returns:\n            AnalysisRequest ready for analysis\n        \"\"\"\n        proj = project or client_request.project\n        scope_items = [\n            ScopeItemDTO.from_db_model(item)\n            for item in proj.scope_items\n        ]\n        return cls(\n            request_content=client_request.content,\n            scope_items=scope_items,\n            project_context=proj.description,\n        )"
    },
    {
      "name": "AnalysisResult",
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 82,
      "docstring": "Output from scope analysis.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "to_client_request_update"
      ],
      "decorators": [],
      "source": "class AnalysisResult(BaseModel):\n    \"\"\"Output from scope analysis.\"\"\"\n\n    classification: ScopeClassificationType\n    confidence: float = Field(ge=0.0, le=1.0)\n    reasoning: str\n    matched_scope_item_index: int | None = None\n    matched_scope_item_id: uuid.UUID | None = None\n    suggested_action: str\n    scope_creep_indicators: list[str] = Field(default_factory=list)\n\n    def to_client_request_update(self) -> dict:\n        \"\"\"\n        Convert result to fields for updating a ClientRequest model.\n\n        Returns:\n            Dict with fields compatible with ClientRequest model\n        \"\"\"\n        return {\n            \"classification\": self.classification,\n            \"confidence\": Decimal(str(round(self.confidence, 2))),\n            \"analysis_reasoning\": self.reasoning,\n            \"suggested_action\": self.suggested_action,\n            \"linked_scope_item_id\": self.matched_scope_item_id,\n        }"
    },
    {
      "name": "TestCreateProposalSuccess",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 13,
      "docstring": "Test creating a proposal successfully.",
      "bases": [],
      "methods": [
        "test_create_proposal_success"
      ],
      "decorators": [],
      "source": "class TestCreateProposalSuccess:\n    \"\"\"Test creating a proposal successfully.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_create_proposal_success(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create proposal manually and verify all fields.\"\"\"\n        proposal_data = {\n            \"title\": \"New Feature Proposal\",\n            \"description\": \"This proposal outlines the new feature development\",\n            \"amount\": \"1500.00\",\n            \"estimated_hours\": \"20.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == proposal_data[\"title\"]\n        assert data[\"description\"] == proposal_data[\"description\"]\n        assert Decimal(data[\"amount\"]) == Decimal(proposal_data[\"amount\"])\n        assert Decimal(data[\"estimated_hours\"]) == Decimal(proposal_data[\"estimated_hours\"])\n        assert data[\"status\"] == ProposalStatus.DRAFT.value\n        assert data[\"source_request_id\"] is None\n        assert data[\"sent_at\"] is None\n        assert data[\"responded_at\"] is None"
    },
    {
      "name": "TestCreateProposalFromRequest",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 46,
      "docstring": "Test creating a proposal from a client request.",
      "bases": [],
      "methods": [
        "test_create_proposal_from_request",
        "test_create_proposal_from_in_scope_request"
      ],
      "decorators": [],
      "source": "class TestCreateProposalFromRequest:\n    \"\"\"Test creating a proposal from a client request.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_create_proposal_from_request(\n        self, client: AsyncClient, auth_headers: dict, test_project, test_client_request\n    ):\n        \"\"\"Create from OUT_OF_SCOPE request, verify title auto-generated and request linked.\"\"\"\n        proposal_data = {\n            \"source_request_id\": str(test_client_request.id),\n            \"amount\": \"2000.00\",\n            \"estimated_hours\": \"25.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{test_client_request.id}/create-proposal\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == f\"Proposal: {test_client_request.title}\"\n        assert data[\"source_request_id\"] == str(test_client_request.id)\n        assert test_client_request.content in data[\"description\"]\n        assert Decimal(data[\"amount\"]) == Decimal(proposal_data[\"amount\"])\n        \n    @pytest.mark.asyncio\n    async def test_create_proposal_from_in_scope_request(\n        self, client: AsyncClient, auth_headers: dict, test_project, test_client_request_in_scope\n    ):\n        \"\"\"Create from IN_SCOPE request - should still work (user's choice).\"\"\"\n        proposal_data = {\n            \"source_request_id\": str(test_client_request_in_scope.id),\n            \"amount\": \"500.00\",\n            \"estimated_hours\": \"5.0\",\n        }\n        \n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/requests/{test_client_request_in_scope.id}/create-proposal\",\n            json=proposal_data,\n            headers=auth_headers,\n        )\n        \n        # Should succeed - it's the user's choice to create proposals for any request\n        assert response.status_code == status.HTTP_201_CREATED"
    },
    {
      "name": "TestListProposals",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 94,
      "docstring": "Test listing proposals.",
      "bases": [],
      "methods": [
        "test_list_proposals",
        "test_list_proposals_with_status_filter"
      ],
      "decorators": [],
      "source": "class TestListProposals:\n    \"\"\"Test listing proposals.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_list_proposals(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create multiple proposals and verify list returns all.\"\"\"\n        # Create multiple proposals first\n        proposals_to_create = [\n            {\"title\": \"Proposal 1\", \"description\": \"Desc 1\", \"amount\": \"1000.00\"},\n            {\"title\": \"Proposal 2\", \"description\": \"Desc 2\", \"amount\": \"2000.00\"},\n            {\"title\": \"Proposal 3\", \"description\": \"Desc 3\", \"amount\": \"3000.00\"},\n        ]\n        \n        for proposal_data in proposals_to_create:\n            await client.post(\n                f\"/api/v1/projects/{test_project.id}/proposals\",\n                json=proposal_data,\n                headers=auth_headers,\n            )\n        \n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data) >= len(proposals_to_create)\n    \n    @pytest.mark.asyncio\n    async def test_list_proposals_with_status_filter(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Filter proposals by status.\"\"\"\n        # Create a draft proposal\n        await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Draft\", \"description\": \"Draft desc\", \"amount\": \"100.00\"},\n            headers=auth_headers,\n        )\n        \n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals?status=draft\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        for proposal in data:\n            assert proposal[\"status\"] == \"draft\""
    },
    {
      "name": "TestUpdateProposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 148,
      "docstring": "Test updating proposals.",
      "bases": [],
      "methods": [
        "test_update_proposal_amount",
        "test_update_status_to_accepted"
      ],
      "decorators": [],
      "source": "class TestUpdateProposal:\n    \"\"\"Test updating proposals.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_update_proposal_amount(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Update amount and verify change.\"\"\"\n        # First create a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Original Title\",\n                \"description\": \"Original description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Update the amount\n        update_data = {\"amount\": \"1500.00\"}\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            json=update_data,\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert Decimal(data[\"amount\"]) == Decimal(\"1500.00\")\n        \n    @pytest.mark.asyncio\n    async def test_update_status_to_accepted(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Update status to ACCEPTED, verify responded_at is set automatically.\"\"\"\n        # Create and send a proposal first\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        send_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_response.status_code == status.HTTP_200_OK\n        \n        # Update status to accepted\n        response = await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            json={\"status\": \"accepted\"},\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"status\"] == ProposalStatus.ACCEPTED.value\n        assert data[\"responded_at\"] is not None"
    },
    {
      "name": "TestSendProposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 219,
      "docstring": "Test sending proposals.",
      "bases": [],
      "methods": [
        "test_send_proposal",
        "test_send_already_sent"
      ],
      "decorators": [],
      "source": "class TestSendProposal:\n    \"\"\"Test sending proposals.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_send_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Call /send endpoint, verify status=SENT and sent_at set.\"\"\"\n        # Create a proposal first\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"status\"] == ProposalStatus.SENT.value\n        assert data[\"sent_at\"] is not None\n        \n    @pytest.mark.asyncio\n    async def test_send_already_sent(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Try to send already-sent proposal - expect 400.\"\"\"\n        # Create and send a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test Proposal\",\n                \"description\": \"Test description\",\n                \"amount\": \"1000.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it first time\n        first_send = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert first_send.status_code == status.HTTP_200_OK\n        \n        # Try to send again\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"already\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "TestGetStats",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 286,
      "docstring": "Test proposal statistics.",
      "bases": [],
      "methods": [
        "test_get_stats"
      ],
      "decorators": [],
      "source": "class TestGetStats:\n    \"\"\"Test proposal statistics.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_get_stats(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Create proposals with various statuses and verify stats calculations.\"\"\"\n        # Create proposals with different statuses\n        # Draft\n        draft_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Draft 1\", \"description\": \"Desc\", \"amount\": \"100.00\"},\n            headers=auth_headers,\n        )\n        assert draft_resp.status_code == status.HTTP_201_CREATED\n        \n        # Sent\n        sent_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Sent 1\", \"description\": \"Desc\", \"amount\": \"200.00\"},\n            headers=auth_headers,\n        )\n        assert sent_response.status_code == status.HTTP_201_CREATED\n        sent_id = sent_response.json()[\"id\"]\n        send_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{sent_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_resp.status_code == status.HTTP_200_OK\n        \n        # Accepted (must be sent first)\n        accepted_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Accepted 1\", \"description\": \"Desc\", \"amount\": \"500.00\"},\n            headers=auth_headers,\n        )\n        assert accepted_response.status_code == status.HTTP_201_CREATED\n        accepted_id = accepted_response.json()[\"id\"]\n        await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{accepted_id}/send\",\n            headers=auth_headers,\n        )\n        await client.patch(\n            f\"/api/v1/projects/{test_project.id}/proposals/{accepted_id}\",\n            json={\"status\": \"accepted\"},\n            headers=auth_headers,\n        )\n        \n        # Get stats\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/stats\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"total_proposals\"] >= 3\n        assert data[\"draft_count\"] >= 1\n        assert data[\"sent_count\"] >= 1\n        assert data[\"accepted_count\"] >= 1\n        assert Decimal(data[\"total_amount_accepted\"]) >= Decimal(\"500.00\")"
    },
    {
      "name": "TestDeleteProposal",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 350,
      "docstring": "Test deleting proposals.",
      "bases": [],
      "methods": [
        "test_delete_proposal",
        "test_delete_sent_proposal"
      ],
      "decorators": [],
      "source": "class TestDeleteProposal:\n    \"\"\"Test deleting proposals.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_delete_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Delete draft proposal and verify it's deleted.\"\"\"\n        # Create a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"To Delete\",\n                \"description\": \"This will be deleted\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Delete it\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify it's gone\n        get_response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND\n        \n    @pytest.mark.asyncio\n    async def test_delete_sent_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Try to delete sent proposal - expect 400.\"\"\"\n        # Create and send a proposal\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Sent Proposal\",\n                \"description\": \"This was sent\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Send it\n        send_resp = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}/send\",\n            headers=auth_headers,\n        )\n        assert send_resp.status_code == status.HTTP_200_OK\n        \n        # Try to delete\n        response = await client.delete(\n            f\"/api/v1/projects/{test_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"sent\" in response.json()[\"detail\"].lower()"
    },
    {
      "name": "TestProposalNotFound",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 421,
      "docstring": "Test 404 scenarios.",
      "bases": [],
      "methods": [
        "test_get_nonexistent_proposal",
        "test_proposal_in_wrong_project"
      ],
      "decorators": [],
      "source": "class TestProposalNotFound:\n    \"\"\"Test 404 scenarios.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_get_nonexistent_proposal(\n        self, client: AsyncClient, auth_headers: dict, test_project\n    ):\n        \"\"\"Get a proposal that doesn't exist.\"\"\"\n        fake_id = str(uuid.uuid4())\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals/{fake_id}\",\n            headers=auth_headers,\n        )\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        \n    @pytest.mark.asyncio\n    async def test_proposal_in_wrong_project(\n        self, client: AsyncClient, auth_headers: dict, test_project, other_user_project\n    ):\n        \"\"\"Try to access proposal from a different user's project.\"\"\"\n        # Create a proposal in the test user's project\n        create_response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\n                \"title\": \"Test\",\n                \"description\": \"Test\",\n                \"amount\": \"100.00\",\n            },\n            headers=auth_headers,\n        )\n        assert create_response.status_code == status.HTTP_201_CREATED\n        proposal_id = create_response.json()[\"id\"]\n        \n        # Try to access from a different user's project (should fail - not found because user doesn't own it)\n        response = await client.get(\n            f\"/api/v1/projects/{other_user_project.id}/proposals/{proposal_id}\",\n            headers=auth_headers,\n        )\n        # Should return 404 (project not found for this user)\n        assert response.status_code == status.HTTP_404_NOT_FOUND"
    },
    {
      "name": "TestProposalUnauthorized",
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 463,
      "docstring": "Test unauthorized access.",
      "bases": [],
      "methods": [
        "test_list_proposals_unauthorized",
        "test_create_proposal_unauthorized"
      ],
      "decorators": [],
      "source": "class TestProposalUnauthorized:\n    \"\"\"Test unauthorized access.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_list_proposals_unauthorized(\n        self, client: AsyncClient, test_project\n    ):\n        \"\"\"Try to list proposals without auth - expect 403.\"\"\"\n        response = await client.get(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n        )\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n    \n    @pytest.mark.asyncio\n    async def test_create_proposal_unauthorized(\n        self, client: AsyncClient, test_project\n    ):\n        \"\"\"Try to create proposal without auth - expect 403.\"\"\"\n        response = await client.post(\n            f\"/api/v1/projects/{test_project.id}/proposals\",\n            json={\"title\": \"Test\", \"description\": \"Test\", \"amount\": \"100.00\"},\n        )\n        assert response.status_code == status.HTTP_403_FORBIDDEN"
    },
    {
      "name": "User",
      "file_path": "app/models/user.py",
      "line_number": 10,
      "docstring": "User account for freelancers.",
      "bases": [
        "BaseModel"
      ],
      "methods": [
        "__repr__"
      ],
      "decorators": [],
      "source": "class User(BaseModel):\n    \"\"\"User account for freelancers.\"\"\"\n    \n    __tablename__ = \"users\"\n    \n    id: Mapped[uuid.UUID] = mapped_column(\n        GUID(), \n        primary_key=True, \n        default=uuid.uuid4, \n        # init is now implicitly True for SQLAlchemy's purposes unless defined otherwise in BaseModel\n    )\n    \n    email: Mapped[str] = mapped_column(\n        String(255),\n        unique=True,\n        index=True,\n        nullable=False,\n    )\n    hashed_password: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    full_name: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n    )\n    business_name: Mapped[str | None] = mapped_column(\n        String(255),\n        nullable=True,\n    )\n    is_active: Mapped[bool] = mapped_column(\n        default=True,\n        nullable=False,\n    )\n    \n    # Relationships\n    clients: Mapped[list[\"Client\"]] = relationship(\n        \"Client\",\n        back_populates=\"user\",\n        cascade=\"all, delete-orphan\",\n    )\n    projects: Mapped[list[\"Project\"]] = relationship(\n        \"Project\",\n        back_populates=\"user\",\n        cascade=\"all, delete-orphan\",\n    )\n    subscription: Mapped[\"Subscription | None\"] = relationship(\n        \"Subscription\",\n        back_populates=\"user\",\n        uselist=False,\n    )\n    \n    def __repr__(self) -> str:\n        return f\"<User {self.email}>\""
    },
    {
      "name": "DashboardSummary",
      "file_path": "app/schemas/dashboard.py",
      "line_number": 11,
      "docstring": "High-level stats for the user.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class DashboardSummary(BaseModel):\n    \"\"\"High-level stats for the user.\"\"\"\n    \n    total_projects: int = Field(default=0, description=\"Total number of projects\")\n    active_projects: int = Field(default=0, description=\"Number of active projects\")\n    total_clients: int = Field(default=0, description=\"Total number of clients\")\n    \n    # Request stats\n    total_requests: int = Field(default=0, description=\"Total client requests\")\n    out_of_scope_requests: int = Field(default=0, description=\"Requests flagged as out of scope\")\n    pending_requests: int = Field(default=0, description=\"Requests awaiting analysis\")\n    \n    # Proposal stats\n    total_proposals: int = Field(default=0, description=\"Total proposals created\")\n    pending_proposals: int = Field(default=0, description=\"Proposals in DRAFT or SENT status\")\n    accepted_proposals: int = Field(default=0, description=\"Proposals accepted by clients\")\n    total_revenue_protected: Decimal = Field(\n        default=Decimal(\"0.00\"),\n        description=\"Sum of accepted proposal amounts\"\n    )\n\n    model_config = {\"from_attributes\": True}"
    },
    {
      "name": "Alert",
      "file_path": "app/schemas/dashboard.py",
      "line_number": 35,
      "docstring": "An alert for the user's attention.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class Alert(BaseModel):\n    \"\"\"An alert for the user's attention.\"\"\"\n    \n    type: Literal[\"scope_creep\", \"pending_request\", \"proposal_expiring\", \"milestone_overdue\"]\n    severity: Literal[\"low\", \"medium\", \"high\"]\n    message: str\n    project_id: UUID\n    project_name: str\n    related_id: UUID | None = Field(default=None, description=\"Related request_id or proposal_id\")\n    created_at: datetime\n\n    model_config = {\"from_attributes\": True}"
    },
    {
      "name": "RecentActivity",
      "file_path": "app/schemas/dashboard.py",
      "line_number": 49,
      "docstring": "Recent activity item.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class RecentActivity(BaseModel):\n    \"\"\"Recent activity item.\"\"\"\n    \n    type: Literal[\n        \"request_created\",\n        \"request_analyzed\",\n        \"proposal_sent\",\n        \"proposal_accepted\",\n        \"scope_completed\"\n    ]\n    message: str\n    project_id: UUID\n    project_name: str\n    timestamp: datetime\n\n    model_config = {\"from_attributes\": True}"
    },
    {
      "name": "ProjectHealth",
      "file_path": "app/schemas/dashboard.py",
      "line_number": 67,
      "docstring": "Health metrics for a single project.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class ProjectHealth(BaseModel):\n    \"\"\"Health metrics for a single project.\"\"\"\n    \n    project_id: UUID\n    project_name: str\n    status: str\n    \n    # Scope health\n    scope_completion_percentage: float = Field(\n        default=0.0,\n        ge=0.0,\n        le=100.0,\n        description=\"Percentage of scope items completed\"\n    )\n    scope_items_total: int = Field(default=0)\n    scope_items_completed: int = Field(default=0)\n    \n    # Request health\n    total_requests: int = Field(default=0)\n    in_scope_requests: int = Field(default=0)\n    out_of_scope_requests: int = Field(default=0)\n    pending_analysis: int = Field(default=0)\n    scope_creep_ratio: float = Field(\n        default=0.0,\n        ge=0.0,\n        le=1.0,\n        description=\"Ratio of out_of_scope to total requests\"\n    )\n    \n    # Financial health\n    budget: Decimal | None = Field(default=None)\n    proposals_sent: int = Field(default=0)\n    proposals_accepted: int = Field(default=0)\n    revenue_protected: Decimal = Field(default=Decimal(\"0.00\"))\n    \n    # Overall health score (0-100)\n    health_score: int = Field(\n        default=100,\n        ge=0,\n        le=100,\n        description=\"Overall project health score\"\n    )\n\n    model_config = {\"from_attributes\": True}"
    },
    {
      "name": "DashboardResponse",
      "file_path": "app/schemas/dashboard.py",
      "line_number": 113,
      "docstring": "Full dashboard data.",
      "bases": [
        "BaseModel"
      ],
      "methods": [],
      "decorators": [],
      "source": "class DashboardResponse(BaseModel):\n    \"\"\"Full dashboard data.\"\"\"\n    \n    summary: DashboardSummary\n    alerts: list[Alert]\n    recent_activity: list[RecentActivity]\n    project_health: list[ProjectHealth] = Field(\n        default_factory=list,\n        description=\"Health metrics for top 5 active projects\"\n    )\n\n    model_config = {\"from_attributes\": True}"
    }
  ],
  "endpoints": [
    {
      "method": "GET",
      "path": "",
      "function_name": "get_dashboard",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 516,
      "source": "async def get_dashboard(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> DashboardResponse:\n    \"\"\"Get full dashboard data including summary, alerts, activity, and project health.\"\"\"\n    \n    # Get summary stats\n    summary = await get_dashboard_summary(db, current_user.id)\n    \n    # Get alerts\n    alerts = await get_alerts(db, current_user.id)\n    \n    # Get recent activity\n    recent_activity = await get_recent_activity(db, current_user.id, limit=20)\n    \n    # Get health for top 5 active projects\n    projects_query = (\n        select(Project)\n        .where(\n            and_(\n                Project.user_id == current_user.id,\n                Project.status == ProjectStatus.ACTIVE,\n            )\n        )\n        .order_by(Project.updated_at.desc())\n        .limit(5)\n    )\n    \n    projects_result = await db.execute(projects_query)\n    projects = projects_result.scalars().all()\n    \n    project_health = []\n    for project in projects:\n        health = await calculate_project_health(db, project)\n        project_health.append(health)\n    \n    return DashboardResponse(\n        summary=summary,\n        alerts=alerts,\n        recent_activity=recent_activity,\n        project_health=project_health,\n    )"
    },
    {
      "method": "GET",
      "path": "/summary",
      "function_name": "get_summary",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 561,
      "source": "async def get_summary(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> DashboardSummary:\n    \"\"\"Get just the summary stats.\"\"\"\n    return await get_dashboard_summary(db, current_user.id)"
    },
    {
      "method": "GET",
      "path": "/alerts",
      "function_name": "get_alerts_endpoint",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 570,
      "source": "async def get_alerts_endpoint(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[Alert]:\n    \"\"\"Get alerts only.\"\"\"\n    return await get_alerts(db, current_user.id)"
    },
    {
      "method": "GET",
      "path": "/activity",
      "function_name": "get_activity",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 579,
      "source": "async def get_activity(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    limit: int = Query(default=20, le=50, ge=1),\n) -> list[RecentActivity]:\n    \"\"\"Get recent activity (last 20 items by default).\"\"\"\n    return await get_recent_activity(db, current_user.id, limit=limit)"
    },
    {
      "method": "GET",
      "path": "/projects/{project_id}/health",
      "function_name": "get_project_health",
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 589,
      "source": "async def get_project_health(\n    project_id: UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectHealth:\n    \"\"\"Get health metrics for a specific project.\"\"\"\n    \n    # Verify project exists and belongs to user\n    project_query = select(Project).where(\n        and_(\n            Project.id == project_id,\n            Project.user_id == current_user.id,\n        )\n    )\n    \n    result = await db.execute(project_query)\n    project = result.scalar_one_or_none()\n    \n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n    \n    return await calculate_project_health(db, project)"
    },
    {
      "method": "GET",
      "path": "",
      "function_name": "list_clients",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 38,
      "source": "async def list_clients(\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n    skip: int = Query(default=0, ge=0),\n    limit: int = Query(default=100, ge=1, le=100),\n) -> ClientList:\n    \"\"\"\n    List all clients for the current user with project counts.\n    \n    Supports pagination with skip and limit parameters.\n    \"\"\"\n    # Get clients with project counts using a subquery\n    project_count_subquery = (\n        select(Project.client_id, func.count(Project.id).label(\"project_count\"))\n        .where(Project.user_id == current_user.id)\n        .group_by(Project.client_id)\n        .subquery()\n    )\n    \n    # Query clients with left join to get project counts\n    query = (\n        select(Client, func.coalesce(project_count_subquery.c.project_count, 0).label(\"project_count\"))\n        .outerjoin(project_count_subquery, Client.id == project_count_subquery.c.client_id)\n        .where(Client.user_id == current_user.id)\n        .offset(skip)\n        .limit(limit)\n        .order_by(Client.created_at.desc())\n    )\n    \n    result = await db.execute(query)\n    rows = result.all()\n    \n    # Get total count\n    count_query = select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    clients = [\n        _client_to_response(row.Client, row.project_count)\n        for row in rows\n    ]\n    \n    return ClientList(clients=clients, total=total)"
    },
    {
      "method": "POST",
      "path": "",
      "function_name": "create_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 84,
      "source": "async def create_client(\n    client_in: ClientCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"Create a new client for the current user.\"\"\"\n    client = Client(\n        user_id=current_user.id,\n        name=client_in.name,\n        email=client_in.email,\n        company=client_in.company,\n        notes=client_in.notes,\n    )\n    db.add(client)\n    await db.commit()\n    await db.refresh(client)\n    \n    return _client_to_response(client, project_count=0)"
    },
    {
      "method": "GET",
      "path": "/{client_id}",
      "function_name": "get_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 105,
      "source": "async def get_client(\n    client_id: str,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"\n    Get a single client by ID.\n    \n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Get client with project count\n    project_count_subquery = (\n        select(func.count(Project.id))\n        .where(Project.client_id == client_uuid)\n        .where(Project.user_id == current_user.id)\n        .scalar_subquery()\n    )\n    \n    query = (\n        select(Client, project_count_subquery.label(\"project_count\"))\n        .where(Client.id == client_uuid)\n        .where(Client.user_id == current_user.id)\n    )\n    \n    result = await db.execute(query)\n    row = result.first()\n    \n    if not row:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    return _client_to_response(row.Client, row.project_count or 0)"
    },
    {
      "method": "PATCH",
      "path": "/{client_id}",
      "function_name": "update_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 150,
      "source": "async def update_client(\n    client_id: str,\n    client_in: ClientUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientResponse:\n    \"\"\"\n    Update a client by ID.\n    \n    Only updates fields that are explicitly provided.\n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Find the client\n    query = select(Client).where(\n        Client.id == client_uuid,\n        Client.user_id == current_user.id,\n    )\n    result = await db.execute(query)\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Update only provided fields\n    update_data = client_in.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(client, field, value)\n    \n    await db.commit()\n    await db.refresh(client)\n    \n    # Get project count\n    project_count_query = (\n        select(func.count(Project.id))\n        .where(Project.client_id == client_uuid)\n        .where(Project.user_id == current_user.id)\n    )\n    project_count_result = await db.execute(project_count_query)\n    project_count = project_count_result.scalar() or 0\n    \n    return _client_to_response(client, project_count)"
    },
    {
      "method": "DELETE",
      "path": "/{client_id}",
      "function_name": "delete_client",
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 205,
      "source": "async def delete_client(\n    client_id: str,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> None:\n    \"\"\"\n    Delete a client by ID.\n    \n    Returns 404 if client doesn't exist or belongs to another user.\n    \"\"\"\n    try:\n        client_uuid = uuid.UUID(client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    query = select(Client).where(\n        Client.id == client_uuid,\n        Client.user_id == current_user.id,\n    )\n    result = await db.execute(query)\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    await db.delete(client)\n    await db.commit()"
    },
    {
      "method": "GET",
      "path": "/profile",
      "function_name": "get_profile",
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 13,
      "source": "async def get_profile(\n    current_user: CurrentUser,\n) -> UserProfile:\n    \"\"\"\n    Get the current user's full profile.\n\n    Returns all profile fields including created_at timestamp.\n    Requires authentication.\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id),\n        email=current_user.email,\n        full_name=current_user.full_name,\n        business_name=current_user.business_name,\n        is_active=current_user.is_active,\n        created_at=current_user.created_at,\n    )"
    },
    {
      "method": "PATCH",
      "path": "/profile",
      "function_name": "update_profile",
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 33,
      "source": "async def update_profile(\n    user_update: UserUpdate,\n    current_user: CurrentUser,\n    db: AsyncSession = Depends(get_db),\n) -> UserProfile:\n    \"\"\"\n    Update the current user's profile.\n\n    Only updates fields that are provided (not None).\n    Requires authentication.\n    \"\"\"\n    update_data = user_update.model_dump(exclude_unset=True)\n\n    if not update_data:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"No fields to update\",\n        )\n\n    for field, value in update_data.items():\n        setattr(current_user, field, value)\n\n    db.add(current_user)\n    await db.commit()\n    await db.refresh(current_user)\n\n    return UserProfile(\n        id=str(current_user.id),\n        email=current_user.email,\n        full_name=current_user.full_name,\n        business_name=current_user.business_name,\n        is_active=current_user.is_active,\n        created_at=current_user.created_at,\n    )"
    },
    {
      "method": "GET",
      "path": "/{project_id}/proposals",
      "function_name": "list_proposals",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 90,
      "source": "async def list_proposals(\n    project_id: uuid.UUID,\n    status_filter: Optional[ProposalStatus] = Query(default=None, alias=\"status\"),\n    skip: int = Query(default=0, ge=0),\n    limit: int = Query(default=50, ge=1, le=100),\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> List[ProposalResponse]:\n    \"\"\"List all proposals for a project.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    query = select(Proposal).where(Proposal.project_id == project_id)\n    \n    if status_filter:\n        query = query.where(Proposal.status == status_filter)\n    \n    query = query.order_by(Proposal.created_at.desc()).offset(skip).limit(limit)\n    result = await db.execute(query)\n    proposals = result.scalars().all()\n    \n    # Fetch source request titles for linked proposals\n    responses = []\n    for proposal in proposals:\n        source_title = None\n        if proposal.source_request_id:\n            req_result = await db.execute(\n                select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n            )\n            source_title = req_result.scalar_one_or_none()\n        responses.append(proposal_to_response(proposal, source_title))\n    \n    return responses"
    },
    {
      "method": "POST",
      "path": "/{project_id}/proposals",
      "function_name": "create_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 125,
      "source": "async def create_proposal(\n    project_id: uuid.UUID,\n    proposal_in: ProposalCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Create a new proposal manually.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    proposal = Proposal(\n        project_id=project_id,\n        source_request_id=None,\n        title=proposal_in.title,\n        description=proposal_in.description,\n        status=ProposalStatus.DRAFT,\n        amount=proposal_in.amount,\n        estimated_hours=proposal_in.estimated_hours,\n    )\n    \n    db.add(proposal)\n    await db.commit()\n    await db.refresh(proposal)\n    \n    return proposal_to_response(proposal)"
    },
    {
      "method": "POST",
      "path": "/{project_id}/requests/{request_id}/create-proposal",
      "function_name": "create_proposal_from_request",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 156,
      "source": "async def create_proposal_from_request(\n    project_id: uuid.UUID,\n    request_id: uuid.UUID,\n    proposal_in: ProposalFromRequest,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Create a proposal from an existing client request.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Verify request_id matches the one in body\n    if proposal_in.source_request_id != request_id:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Request ID in URL does not match source_request_id in body\",\n        )\n    \n    # Fetch the source request\n    result = await db.execute(\n        select(ClientRequest).where(\n            ClientRequest.id == request_id,\n            ClientRequest.project_id == project_id,\n        )\n    )\n    source_request = result.scalar_one_or_none()\n    if not source_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n    \n    # Auto-generate title and description\n    title = f\"Proposal: {source_request.title}\"\n    description = f\"This proposal addresses the following request:\\n\\n{source_request.content}\"\n    \n    # Add analysis info if available\n    if source_request.analysis_reasoning:\n        description += f\"\\n\\nAnalysis:\\n{source_request.analysis_reasoning}\"\n    \n    proposal = Proposal(\n        project_id=project_id,\n        source_request_id=request_id,\n        title=title,\n        description=description,\n        status=ProposalStatus.DRAFT,\n        amount=proposal_in.amount,\n        estimated_hours=proposal_in.estimated_hours,\n    )\n    \n    db.add(proposal)\n    \n    # Update the client request status to PROPOSAL_SENT\n    source_request.status = RequestStatus.PROPOSAL_SENT\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    return proposal_to_response(proposal, source_request.title)"
    },
    {
      "method": "GET",
      "path": "/{project_id}/proposals/stats",
      "function_name": "get_proposal_stats",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 217,
      "source": "async def get_proposal_stats(\n    project_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalStats:\n    \"\"\"Get proposal statistics for a project.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get counts by status\n    result = await db.execute(\n        select(\n            Proposal.status,\n            func.count(Proposal.id).label(\"count\"),\n        )\n        .where(Proposal.project_id == project_id)\n        .group_by(Proposal.status)\n    )\n    status_counts = {row.status: row.count for row in result}\n    \n    # Get total accepted amount\n    result = await db.execute(\n        select(func.coalesce(func.sum(Proposal.amount), Decimal(\"0\")))\n        .where(\n            Proposal.project_id == project_id,\n            Proposal.status == ProposalStatus.ACCEPTED,\n        )\n    )\n    total_accepted = result.scalar_one()\n    \n    return ProposalStats(\n        total_proposals=sum(status_counts.values()),\n        draft_count=status_counts.get(ProposalStatus.DRAFT, 0),\n        sent_count=status_counts.get(ProposalStatus.SENT, 0),\n        accepted_count=status_counts.get(ProposalStatus.ACCEPTED, 0),\n        declined_count=status_counts.get(ProposalStatus.DECLINED, 0),\n        expired_count=status_counts.get(ProposalStatus.EXPIRED, 0),\n        total_amount_accepted=total_accepted,\n    )"
    },
    {
      "method": "GET",
      "path": "/{project_id}/proposals/{proposal_id}",
      "function_name": "get_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 258,
      "source": "async def get_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Get a specific proposal.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "method": "PATCH",
      "path": "/{project_id}/proposals/{proposal_id}",
      "function_name": "update_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 279,
      "source": "async def update_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    proposal_in: ProposalUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Update a proposal.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    update_data = proposal_in.model_dump(exclude_unset=True)\n    \n    # Track if status is being changed to ACCEPTED or DECLINED\n    new_status = update_data.get(\"status\")\n    if new_status in (ProposalStatus.ACCEPTED, ProposalStatus.DECLINED):\n        if proposal.responded_at is None:\n            proposal.responded_at = datetime.now(timezone.utc)\n    \n    for field, value in update_data.items():\n        setattr(proposal, field, value)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "method": "POST",
      "path": "/{project_id}/proposals/{proposal_id}/send",
      "function_name": "send_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 315,
      "source": "async def send_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as sent.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if already sent\n    if proposal.status != ProposalStatus.DRAFT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Proposal is already {proposal.status.value}, cannot send\",\n        )\n    \n    proposal.status = ProposalStatus.SENT\n    proposal.sent_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "method": "POST",
      "path": "/{project_id}/proposals/{proposal_id}/accept",
      "function_name": "accept_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 349,
      "source": "async def accept_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as accepted by the client.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if proposal has been sent\n    if proposal.status != ProposalStatus.SENT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Cannot accept a proposal with status '{proposal.status.value}'. Proposal must be sent first.\",\n        )\n    \n    proposal.status = ProposalStatus.ACCEPTED\n    proposal.responded_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "method": "POST",
      "path": "/{project_id}/proposals/{proposal_id}/decline",
      "function_name": "decline_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 383,
      "source": "async def decline_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ProposalResponse:\n    \"\"\"Mark a proposal as declined by the client.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Check if proposal has been sent\n    if proposal.status != ProposalStatus.SENT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Cannot decline a proposal with status '{proposal.status.value}'. Proposal must be sent first.\",\n        )\n    \n    proposal.status = ProposalStatus.DECLINED\n    proposal.responded_at = datetime.now(timezone.utc)\n    \n    await db.commit()\n    await db.refresh(proposal)\n    \n    source_title = None\n    if proposal.source_request_id:\n        result = await db.execute(\n            select(ClientRequest.title).where(ClientRequest.id == proposal.source_request_id)\n        )\n        source_title = result.scalar_one_or_none()\n    \n    return proposal_to_response(proposal, source_title)"
    },
    {
      "method": "DELETE",
      "path": "/{project_id}/proposals/{proposal_id}",
      "function_name": "delete_proposal",
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 417,
      "source": "async def delete_proposal(\n    project_id: uuid.UUID,\n    proposal_id: uuid.UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> None:\n    \"\"\"Delete a proposal. Only draft proposals can be deleted.\"\"\"\n    await get_project_or_404(project_id, db, current_user)\n    proposal = await get_proposal_or_404(proposal_id, project_id, db)\n    \n    # Only allow deletion of draft proposals\n    if proposal.status != ProposalStatus.DRAFT:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Cannot delete a proposal that has been sent\",\n        )\n    \n    await db.delete(proposal)\n    await db.commit()"
    },
    {
      "method": "GET",
      "path": "",
      "function_name": "list_projects",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 120,
      "source": "async def list_projects(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    status_filter: Annotated[ProjectStatus | None, Query(alias=\"status\")] = None,\n    client_id: Annotated[str | None, Query()] = None,\n    skip: Annotated[int, Query(ge=0)] = 0,\n    limit: Annotated[int, Query(ge=1, le=100)] = 20,\n) -> ProjectList:\n    \"\"\"\n    List all projects for the current user.\n    \n    Supports filtering by status and client_id.\n    \"\"\"\n    # Build base query\n    query = (\n        select(Project)\n        .options(selectinload(Project.client))\n        .where(Project.user_id == current_user.id)\n    )\n    \n    # Apply filters\n    if status_filter:\n        query = query.where(Project.status == status_filter)\n    \n    if client_id:\n        try:\n            client_uuid = UUID(client_id)\n            query = query.where(Project.client_id == client_uuid)\n        except ValueError:\n            # Invalid UUID, return empty results\n            return ProjectList(projects=[], total=0)\n    \n    # Get total count\n    count_query = select(func.count()).select_from(query.subquery())\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    # Apply pagination and ordering\n    query = query.order_by(Project.created_at.desc()).offset(skip).limit(limit)\n    \n    result = await db.execute(query)\n    projects = result.scalars().all()\n    \n    # Get stats for each project\n    projects_with_stats = []\n    for project in projects:\n        stats = await get_project_stats(project.id, db)\n        projects_with_stats.append(project_to_response(project, stats))\n    \n    return ProjectList(\n        projects=projects_with_stats,\n        total=total,\n    )"
    },
    {
      "method": "POST",
      "path": "",
      "function_name": "create_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 176,
      "source": "async def create_project(\n    project_in: ProjectCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"\n    Create a new project.\n    \n    The client_id must belong to the current user.\n    \"\"\"\n    # Verify client exists and belongs to user\n    try:\n        client_uuid = UUID(project_in.client_id)\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    result = await db.execute(\n        select(Client).where(\n            Client.id == client_uuid,\n            Client.user_id == current_user.id,\n        )\n    )\n    client = result.scalar_one_or_none()\n    \n    if not client:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client not found\",\n        )\n    \n    # Create project\n    project = Project(\n        user_id=current_user.id,\n        client_id=client_uuid,\n        name=project_in.name,\n        description=project_in.description,\n        status=project_in.status,\n        budget=project_in.budget,\n        hourly_rate=project_in.hourly_rate,\n        estimated_hours=project_in.estimated_hours,\n    )\n    \n    db.add(project)\n    await db.commit()\n    await db.refresh(project)\n    \n    # Load client relationship for response\n    project.client = client\n    \n    return project_to_response(project)"
    },
    {
      "method": "GET",
      "path": "/{project_id}",
      "function_name": "get_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 232,
      "source": "async def get_project(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"Get a specific project with stats.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Calculate actual stats from database\n    stats = await get_project_stats(project.id, db)\n    \n    return project_to_response(project, stats)"
    },
    {
      "method": "GET",
      "path": "/{project_id}/detail",
      "function_name": "get_project_detail",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 247,
      "source": "async def get_project_detail(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectDetail:\n    \"\"\"Get a project with scope items and recent requests.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Calculate actual stats from database\n    stats = await get_project_stats(project.id, db)\n    \n    response = project_to_response(project, stats)\n    \n    return ProjectDetail(\n        **response.model_dump(),\n        scope_items=[],\n        recent_requests=[],\n    )"
    },
    {
      "method": "PATCH",
      "path": "/{project_id}",
      "function_name": "update_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 268,
      "source": "async def update_project(\n    project_id: str,\n    project_in: ProjectUpdate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ProjectResponse:\n    \"\"\"Update a project.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    # Update only provided fields\n    update_data = project_in.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(project, field, value)\n    \n    await db.commit()\n    await db.refresh(project)\n    \n    # Get updated stats\n    stats = await get_project_stats(project.id, db)\n    \n    return project_to_response(project, stats)"
    },
    {
      "method": "DELETE",
      "path": "/{project_id}",
      "function_name": "delete_project",
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 292,
      "source": "async def delete_project(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Delete a project.\"\"\"\n    project = await get_project_or_404(project_id, current_user, db)\n    \n    await db.delete(project)\n    await db.commit()"
    },
    {
      "method": "GET",
      "path": "",
      "function_name": "health_check",
      "file_path": "app/api/v1/endpoints/health.py",
      "line_number": 13,
      "source": "async def health_check() -> dict:\n    \"\"\"Basic health check endpoint.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"app\": settings.app_name,\n        \"version\": settings.app_version,\n    }"
    },
    {
      "method": "POST",
      "path": "/register",
      "function_name": "register",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 21,
      "source": "async def register(\n    user_data: UserRegister,\n    db: Annotated[AsyncSession, Depends(get_db)],\n) -> User:\n    \"\"\"Register a new user.\"\"\"\n    \n    # Check if email already exists\n    result = await db.execute(\n        select(User).where(User.email == user_data.email)\n    )\n    existing_user = result.scalar_one_or_none()\n    \n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already registered\",\n        )\n    \n    # Create new user\n    user = User(\n        email=user_data.email,\n        hashed_password=hash_password(user_data.password),\n        full_name=user_data.full_name,\n        business_name=user_data.business_name,\n    )\n    \n    db.add(user)\n    await db.flush()\n    await db.refresh(user)\n    \n    return user"
    },
    {
      "method": "POST",
      "path": "/login",
      "function_name": "login",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 55,
      "source": "async def login(\n    credentials: UserLogin,\n    db: Annotated[AsyncSession, Depends(get_db)],\n) -> dict:\n    \"\"\"Login and get an access token.\"\"\"\n    \n    # Find user by email\n    result = await db.execute(\n        select(User).where(User.email == credentials.email)\n    )\n    user = result.scalar_one_or_none()\n    \n    if not user or not verify_password(credentials.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User account is deactivated\",\n        )\n    \n    # Create access token\n    access_token = create_access_token(data={\"sub\": str(user.id)})\n    \n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}"
    },
    {
      "method": "GET",
      "path": "/me",
      "function_name": "get_current_user_info",
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 87,
      "source": "async def get_current_user_info(current_user: CurrentUser) -> User:\n    \"\"\"Get the current authenticated user's info.\"\"\"\n    return current_user"
    },
    {
      "method": "POST",
      "path": "/analyze",
      "function_name": "create_and_analyze_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 66,
      "source": "async def create_and_analyze_request(\n    data: AnalyzeRequestCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> AnalyzeResponse:\n    \"\"\"Create a new client request and analyze it.\"\"\"\n    # Verify project exists and belongs to user\n    project = await db.scalar(\n        select(Project)\n        .options(selectinload(Project.scope_items))\n        .where(Project.id == data.project_id, Project.user_id == current_user.id)\n    )\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n\n    # Create the client request\n    client_request = ClientRequest(\n        project_id=data.project_id,\n        title=data.title,\n        content=data.content,\n        source=data.source,\n        status=RequestStatus.NEW,\n        classification=ScopeClassification.PENDING,\n    )\n    db.add(client_request)\n    await db.flush()\n\n    # Manually set the project for analysis (avoid another query)\n    client_request.project = project\n\n    # Analyze the request\n    result = await analyze_client_request(client_request, db, commit=True)\n\n    # Reload with relationships\n    await db.refresh(client_request, [\"linked_scope_item\"])\n\n    return _build_analysis_response(client_request, result)"
    },
    {
      "method": "POST",
      "path": "/analyze/{request_id}",
      "function_name": "analyze_existing_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 114,
      "source": "async def analyze_existing_request(\n    request_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> AnalyzeResponse:\n    \"\"\"Analyze an existing client request.\"\"\"\n    # Get the request with project and scope items\n    client_request = await db.scalar(\n        select(ClientRequest)\n        .options(\n            selectinload(ClientRequest.project).selectinload(Project.scope_items),\n            selectinload(ClientRequest.linked_scope_item),\n        )\n        .join(Project)\n        .where(\n            ClientRequest.id == request_id,\n            Project.user_id == current_user.id,\n        )\n    )\n\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n\n    # Analyze the request\n    result = await analyze_client_request(client_request, db, commit=True)\n\n    # Reload relationships\n    await db.refresh(client_request, [\"linked_scope_item\"])\n\n    return _build_analysis_response(client_request, result)"
    },
    {
      "method": "POST",
      "path": "/analyze-project/{project_id}",
      "function_name": "analyze_project_requests",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 155,
      "source": "async def analyze_project_requests(\n    project_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n    only_pending: bool = True,\n) -> BulkAnalyzeResponse:\n    \"\"\"Analyze all client requests in a project.\"\"\"\n    # Get the project with all relationships\n    project = await db.scalar(\n        select(Project)\n        .options(\n            selectinload(Project.scope_items),\n            selectinload(Project.client_requests).selectinload(\n                ClientRequest.linked_scope_item\n            ),\n        )\n        .where(Project.id == project_id, Project.user_id == current_user.id)\n    )\n\n    if not project:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Project not found\",\n        )\n\n    # Bulk analyze\n    analyzed = await bulk_analyze_project_requests(\n        project, db, commit=True, only_pending=only_pending\n    )\n\n    # Build responses\n    results = [\n        _build_analysis_response(client_request, result)\n        for client_request, result in analyzed\n    ]\n\n    return BulkAnalyzeResponse(\n        analyzed_count=len(results),\n        results=results,\n    )"
    },
    {
      "method": "GET",
      "path": "/requests/{request_id}",
      "function_name": "get_client_request",
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 203,
      "source": "async def get_client_request(\n    request_id: uuid.UUID,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ClientRequestResponse:\n    \"\"\"Get a client request with its analysis results.\"\"\"\n    client_request = await db.scalar(\n        select(ClientRequest)\n        .options(selectinload(ClientRequest.linked_scope_item))\n        .join(Project)\n        .where(\n            ClientRequest.id == request_id,\n            Project.user_id == current_user.id,\n        )\n    )\n\n    if not client_request:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Client request not found\",\n        )\n\n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "method": "GET",
      "path": "/subscription",
      "function_name": "get_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 32,
      "source": "async def get_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Get current user's subscription details.\"\"\"\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    # If no subscription exists, create a free one\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    # Get current usage\n    projects_result = await db.execute(\n        select(func.count(Project.id)).where(Project.user_id == current_user.id)\n    )\n    current_projects = projects_result.scalar() or 0\n    \n    clients_result = await db.execute(\n        select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    )\n    current_clients = clients_result.scalar() or 0\n\n    return SubscriptionResponse(\n        plan=subscription.plan,\n        status=subscription.status,\n        is_pro=subscription.is_pro,\n        current_period_end=subscription.current_period_end,\n        cancel_at_period_end=subscription.cancel_at_period_end or False,\n        max_projects=subscription.max_projects,\n        max_clients=subscription.max_clients,\n        current_projects=current_projects,\n        current_clients=current_clients,\n    )"
    },
    {
      "method": "GET",
      "path": "/limits",
      "function_name": "get_plan_limits",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 78,
      "source": "async def get_plan_limits(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Get current plan limits and usage.\"\"\"\n    result = await db.execute(\n        select(Subscription).where(Subscription.user_id == current_user.id)\n    )\n    subscription = result.scalar_one_or_none()\n\n    if not subscription:\n        subscription = Subscription(\n            user_id=current_user.id,\n            plan=PlanType.FREE,\n            status=SubscriptionStatus.ACTIVE,\n        )\n        db.add(subscription)\n        await db.commit()\n        await db.refresh(subscription)\n\n    projects_result = await db.execute(\n        select(func.count(Project.id)).where(Project.user_id == current_user.id)\n    )\n    current_projects = projects_result.scalar() or 0\n    \n    clients_result = await db.execute(\n        select(func.count(Client.id)).where(Client.user_id == current_user.id)\n    )\n    current_clients = clients_result.scalar() or 0\n\n    return PlanLimits(\n        plan=subscription.plan,\n        max_projects=subscription.max_projects,\n        max_clients=subscription.max_clients,\n        current_projects=current_projects,\n        current_clients=current_clients,\n        can_create_project=current_projects < subscription.max_projects,\n        can_create_client=current_clients < subscription.max_clients,\n    )"
    },
    {
      "method": "POST",
      "path": "/create-checkout-session",
      "function_name": "create_checkout_session",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 120,
      "source": "async def create_checkout_session(\n    request: CreateCheckoutRequest,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Create a Stripe Checkout session for Pro subscription.\"\"\"\n    try:\n        checkout_url = await StripeService.create_checkout_session(\n            db=db,\n            user=current_user,\n            success_url=request.success_url,\n            cancel_url=request.cancel_url,\n        )\n        return CreateCheckoutResponse(checkout_url=checkout_url)\n    except stripe.error.StripeError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create checkout session: {str(e)}\")"
    },
    {
      "method": "POST",
      "path": "/create-portal-session",
      "function_name": "create_portal_session",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 141,
      "source": "async def create_portal_session(\n    request: CreatePortalRequest,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Create a Stripe Customer Portal session for managing subscription.\"\"\"\n    try:\n        portal_url = await StripeService.create_portal_session(\n            db=db,\n            user=current_user,\n            return_url=request.return_url,\n        )\n        return CreatePortalResponse(portal_url=portal_url)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except stripe.error.StripeError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create portal session: {str(e)}\")"
    },
    {
      "method": "POST",
      "path": "/cancel",
      "function_name": "cancel_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 163,
      "source": "async def cancel_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Cancel subscription at end of billing period.\"\"\"\n    success = await StripeService.cancel_subscription(db, current_user)\n    if not success:\n        raise HTTPException(status_code=400, detail=\"No active subscription to cancel\")\n    return {\"message\": \"Subscription will be canceled at end of billing period\"}"
    },
    {
      "method": "POST",
      "path": "/reactivate",
      "function_name": "reactivate_subscription",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 175,
      "source": "async def reactivate_subscription(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    \"\"\"Reactivate a canceled subscription before it expires.\"\"\"\n    success = await StripeService.reactivate_subscription(db, current_user)\n    if not success:\n        raise HTTPException(status_code=400, detail=\"No subscription to reactivate\")\n    return {\"message\": \"Subscription reactivated\"}"
    },
    {
      "method": "POST",
      "path": "/webhook",
      "function_name": "stripe_webhook",
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 187,
      "source": "async def stripe_webhook(\n    request: Request,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    stripe_signature: str = Header(None, alias=\"Stripe-Signature\"),\n):\n    \"\"\"Handle Stripe webhook events.\"\"\"\n    payload = await request.body()\n    webhook_secret = os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")\n    \n    try:\n        event = stripe.Webhook.construct_event(\n            payload,\n            stripe_signature,\n            webhook_secret,\n        )\n    except ValueError:\n        raise HTTPException(status_code=400, detail=\"Invalid payload\")\n    except stripe.error.SignatureVerificationError:\n        raise HTTPException(status_code=400, detail=\"Invalid signature\")\n\n    # Handle the event\n    event_type = event[\"type\"]\n    event_data = event[\"data\"][\"object\"]\n\n    if event_type == \"checkout.session.completed\":\n        await StripeService.handle_checkout_completed(db, event_data)\n    \n    elif event_type == \"customer.subscription.updated\":\n        await StripeService.handle_subscription_updated(db, event_data)\n    \n    elif event_type == \"customer.subscription.deleted\":\n        await StripeService.handle_subscription_deleted(db, event_data)\n    \n    elif event_type == \"invoice.payment_failed\":\n        await StripeService.handle_invoice_payment_failed(db, event_data)\n\n    return {\"status\": \"success\"}"
    },
    {
      "method": "GET",
      "path": "/{project_id}/requests",
      "function_name": "list_client_requests",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 141,
      "source": "async def list_client_requests(\n    project_id: UUID,\n    status: Optional[RequestStatus] = None,\n    classification: Optional[ScopeClassification] = None,\n    skip: int = 0,\n    limit: int = 20,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestListResponse:\n    \"\"\"\n    List client requests for a project.\n    \n    Supports filtering by status and classification.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Build query\n    query = select(ClientRequest).where(ClientRequest.project_id == project_id)\n    count_query = select(func.count(ClientRequest.id)).where(\n        ClientRequest.project_id == project_id\n    )\n    \n    # Apply filters\n    if status is not None:\n        query = query.where(ClientRequest.status == status)\n        count_query = count_query.where(ClientRequest.status == status)\n    \n    if classification is not None:\n        query = query.where(ClientRequest.classification == classification)\n        count_query = count_query.where(ClientRequest.classification == classification)\n    \n    # Get total count\n    total_result = await db.execute(count_query)\n    total = total_result.scalar() or 0\n    \n    # Apply pagination and ordering\n    query = query.order_by(ClientRequest.created_at.desc()).offset(skip).limit(limit)\n    \n    # Execute query\n    result = await db.execute(query)\n    requests = list(result.scalars().all())\n    \n    return ClientRequestListResponse(\n        items=[ClientRequestResponse.model_validate(r) for r in requests],\n        total=total,\n        skip=skip,\n        limit=limit,\n    )"
    },
    {
      "method": "POST",
      "path": "/{project_id}/requests",
      "function_name": "create_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 199,
      "source": "async def create_client_request_endpoint(\n    project_id: UUID,\n    request_data: ClientRequestCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"\n    Create a new client request.\n    \n    If auto_analyze is True (default), the request will be automatically\n    analyzed against the project's scope items.\n    \"\"\"\n    # Verify project ownership\n    project = await get_project_or_404(project_id, db, current_user)\n    \n    # Create the client request\n    client_request = ClientRequest(\n        project_id=project_id,\n        title=request_data.title,\n        content=request_data.content,\n        source=request_data.source,\n        status=RequestStatus.NEW,\n        classification=ScopeClassification.PENDING,\n    )\n    \n    db.add(client_request)\n    await db.commit()\n    await db.refresh(client_request)\n    \n    # Run auto-analysis if requested\n    if request_data.auto_analyze:\n        scope_items = await get_project_scope_items(project_id, db)\n        \n        if scope_items:\n            # Load the request with project relationship for analysis\n            client_request = await load_request_with_project(\n                client_request.id, project_id, db\n            )\n            await run_scope_analysis(client_request, db)\n        else:\n            # No scope items - mark as out of scope with note\n            client_request.classification = ScopeClassification.OUT_OF_SCOPE\n            client_request.analysis_reasoning = (\n                \"No scope items defined for this project. \"\n                \"Unable to determine if request is in scope.\"\n            )\n            client_request.suggested_action = (\n                \"Define project scope items before analyzing requests.\"\n            )\n            client_request.status = RequestStatus.ANALYZED\n            await db.commit()\n            await db.refresh(client_request)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "method": "GET",
      "path": "/{project_id}/requests/{request_id}",
      "function_name": "get_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 261,
      "source": "async def get_client_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"Get a single client request.\"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get the request\n    client_request = await get_request_or_404(request_id, project_id, db)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "method": "PATCH",
      "path": "/{project_id}/requests/{request_id}",
      "function_name": "update_client_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 283,
      "source": "async def update_client_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    request_data: ClientRequestUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> ClientRequestResponse:\n    \"\"\"\n    Update a client request.\n    \n    Allows updating title, content, source, status, and linked scope item.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get the request\n    client_request = await get_request_or_404(request_id, project_id, db)\n    \n    # Update fields that were provided\n    update_data = request_data.model_dump(exclude_unset=True)\n    \n    # Validate linked_scope_item_id if provided\n    if \"linked_scope_item_id\" in update_data and update_data[\"linked_scope_item_id\"]:\n        scope_item_result = await db.execute(\n            select(ScopeItem).where(\n                ScopeItem.id == update_data[\"linked_scope_item_id\"],\n                ScopeItem.project_id == project_id,\n            )\n        )\n        if not scope_item_result.scalar_one_or_none():\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Scope item not found in this project\",\n            )\n    \n    for field, value in update_data.items():\n        setattr(client_request, field, value)\n    \n    await db.commit()\n    await db.refresh(client_request)\n    \n    return ClientRequestResponse.model_validate(client_request)"
    },
    {
      "method": "POST",
      "path": "/{project_id}/requests/{request_id}/analyze",
      "function_name": "analyze_request_endpoint",
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 333,
      "source": "async def analyze_request_endpoint(\n    project_id: UUID,\n    request_id: UUID,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> AnalyzeRequestResponse:\n    \"\"\"\n    Manually trigger scope analysis for a client request.\n    \n    This is useful for requests created with auto_analyze=False\n    or to re-analyze after scope items have been updated.\n    \"\"\"\n    # Verify project ownership\n    await get_project_or_404(project_id, db, current_user)\n    \n    # Get project scope items\n    scope_items = await get_project_scope_items(project_id, db)\n    \n    if not scope_items:\n        # Handle case with no scope items\n        client_request = await get_request_or_404(request_id, project_id, db)\n        client_request.classification = ScopeClassification.OUT_OF_SCOPE\n        client_request.analysis_reasoning = (\n            \"No scope items defined for this project. \"\n            \"Unable to determine if request is in scope.\"\n        )\n        client_request.suggested_action = (\n            \"Define project scope items before analyzing requests.\"\n        )\n        client_request.status = RequestStatus.ANALYZED\n        client_request.confidence = 0.0\n        await db.commit()\n        await db.refresh(client_request)\n        \n        return AnalyzeRequestResponse(\n            classification=ScopeClassification.OUT_OF_SCOPE,\n            confidence=0.0,\n            reasoning=client_request.analysis_reasoning,\n            matched_scope_item_id=None,\n            suggested_action=client_request.suggested_action,\n            scope_creep_indicators=[],\n        )\n    \n    # Load request with project relationship and run analysis\n    client_request = await load_request_with_project(request_id, project_id, db)\n    return await run_scope_analysis(client_request, db)"
    },
    {
      "method": "GET",
      "path": "/",
      "function_name": "root",
      "file_path": "app/main.py",
      "line_number": 60,
      "source": "async def root() -> dict:\n    \"\"\"Root endpoint with API info.\"\"\"\n    return {\n        \"app\": settings.app_name,\n        \"version\": settings.app_version,\n        \"docs\": f\"{settings.api_v1_prefix}/docs\" if settings.debug else \"Disabled in production\",\n    }"
    },
    {
      "method": "GET",
      "path": "/{project_id}/scope",
      "function_name": "list_scope_items",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 120,
      "source": "async def list_scope_items(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[ScopeItemResponse]:\n    \"\"\"List all scope items for a project, ordered by order field.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    result = await db.execute(\n        select(ScopeItem)\n        .where(ScopeItem.project_id == UUID(project_id))\n        .order_by(ScopeItem.order)\n    )\n    scope_items = result.scalars().all()\n    \n    return [\n        ScopeItemResponse(\n            id=str(item.id),\n            project_id=str(item.project_id),\n            title=item.title,\n            description=item.description,\n            order=item.order,\n            is_completed=item.is_completed,\n            estimated_hours=item.estimated_hours,\n            created_at=item.created_at,\n            updated_at=item.updated_at,\n        )\n        for item in scope_items\n    ]"
    },
    {
      "method": "POST",
      "path": "/{project_id}/scope",
      "function_name": "create_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 158,
      "source": "async def create_scope_item(\n    project_id: str,\n    scope_item_in: ScopeItemCreate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeItemResponse:\n    \"\"\"Create a new scope item for a project.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get the max order for existing items\n    result = await db.execute(\n        select(func.coalesce(func.max(ScopeItem.order), -1)).where(\n            ScopeItem.project_id == UUID(project_id)\n        )\n    )\n    max_order = result.scalar()\n    new_order = max_order + 1\n    \n    # Create the new scope item\n    scope_item = ScopeItem(\n        project_id=UUID(project_id),\n        title=scope_item_in.title,\n        description=scope_item_in.description,\n        estimated_hours=scope_item_in.estimated_hours,\n        order=new_order,\n        is_completed=False,\n    )\n    \n    db.add(scope_item)\n    await db.commit()\n    await db.refresh(scope_item)\n    \n    return ScopeItemResponse(\n        id=str(scope_item.id),\n        project_id=str(scope_item.project_id),\n        title=scope_item.title,\n        description=scope_item.description,\n        order=scope_item.order,\n        is_completed=scope_item.is_completed,\n        estimated_hours=scope_item.estimated_hours,\n        created_at=scope_item.created_at,\n        updated_at=scope_item.updated_at,\n    )"
    },
    {
      "method": "GET",
      "path": "/{project_id}/scope/progress",
      "function_name": "get_scope_progress",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 209,
      "source": "async def get_scope_progress(\n    project_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeProgress:\n    \"\"\"Get completion statistics for project scope items.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get all scope items for the project\n    result = await db.execute(\n        select(ScopeItem).where(ScopeItem.project_id == UUID(project_id))\n    )\n    scope_items = result.scalars().all()\n    \n    total_items = len(scope_items)\n    completed_items = sum(1 for item in scope_items if item.is_completed)\n    \n    # Calculate completion percentage\n    completion_percentage = 0.0\n    if total_items > 0:\n        completion_percentage = round((completed_items / total_items) * 100, 2)\n    \n    # Calculate hours\n    total_estimated_hours = None\n    completed_estimated_hours = None\n    \n    items_with_hours = [item for item in scope_items if item.estimated_hours is not None]\n    completed_with_hours = [\n        item for item in scope_items \n        if item.is_completed and item.estimated_hours is not None\n    ]\n    \n    if items_with_hours:\n        total_estimated_hours = sum(\n            item.estimated_hours for item in items_with_hours\n        )\n    \n    if completed_with_hours:\n        completed_estimated_hours = sum(\n            item.estimated_hours for item in completed_with_hours\n        )\n    elif items_with_hours:\n        # If there are items with hours but none completed, set to 0\n        completed_estimated_hours = Decimal(\"0\")\n    \n    return ScopeProgress(\n        total_items=total_items,\n        completed_items=completed_items,\n        completion_percentage=completion_percentage,\n        total_estimated_hours=total_estimated_hours,\n        completed_estimated_hours=completed_estimated_hours,\n    )"
    },
    {
      "method": "PATCH",
      "path": "/{project_id}/scope/{item_id}",
      "function_name": "update_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 269,
      "source": "async def update_scope_item(\n    project_id: str,\n    item_id: str,\n    scope_item_update: ScopeItemUpdate,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> ScopeItemResponse:\n    \"\"\"Update a scope item.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    scope_item = await get_scope_item_or_404(item_id, project_id, db)\n    \n    # Update fields if provided\n    update_data = scope_item_update.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(scope_item, field, value)\n    \n    await db.commit()\n    await db.refresh(scope_item)\n    \n    return ScopeItemResponse(\n        id=str(scope_item.id),\n        project_id=str(scope_item.project_id),\n        title=scope_item.title,\n        description=scope_item.description,\n        order=scope_item.order,\n        is_completed=scope_item.is_completed,\n        estimated_hours=scope_item.estimated_hours,\n        created_at=scope_item.created_at,\n        updated_at=scope_item.updated_at,\n    )"
    },
    {
      "method": "DELETE",
      "path": "/{project_id}/scope/{item_id}",
      "function_name": "delete_scope_item",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 307,
      "source": "async def delete_scope_item(\n    project_id: str,\n    item_id: str,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> None:\n    \"\"\"Delete a scope item.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    scope_item = await get_scope_item_or_404(item_id, project_id, db)\n    \n    await db.delete(scope_item)\n    await db.commit()"
    },
    {
      "method": "POST",
      "path": "/{project_id}/scope/reorder",
      "function_name": "reorder_scope_items",
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 327,
      "source": "async def reorder_scope_items(\n    project_id: str,\n    reorder_data: ScopeItemReorder,\n    db: Annotated[AsyncSession, Depends(get_db)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[ScopeItemResponse]:\n    \"\"\"Reorder scope items by providing a list of item IDs in the desired order.\"\"\"\n    await verify_project_access(project_id, db, current_user)\n    \n    # Get all existing scope items for this project\n    result = await db.execute(\n        select(ScopeItem).where(ScopeItem.project_id == UUID(project_id))\n    )\n    existing_items = {str(item.id): item for item in result.scalars().all()}\n    \n    # Validate all provided IDs exist and belong to this project\n    for item_id in reorder_data.item_ids:\n        if item_id not in existing_items:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Scope item {item_id} not found in this project\",\n            )\n    \n    # Validate all existing items are included\n    if set(reorder_data.item_ids) != set(existing_items.keys()):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Reorder must include all scope items for the project\",\n        )\n    \n    # Update orders in a single transaction\n    for new_order, item_id in enumerate(reorder_data.item_ids):\n        existing_items[item_id].order = new_order\n    \n    await db.commit()\n    \n    # Refresh and return updated items in new order\n    updated_items = []\n    for item_id in reorder_data.item_ids:\n        await db.refresh(existing_items[item_id])\n        item = existing_items[item_id]\n        updated_items.append(\n            ScopeItemResponse(\n                id=str(item.id),\n                project_id=str(item.project_id),\n                title=item.title,\n                description=item.description,\n                order=item.order,\n                is_completed=item.is_completed,\n                estimated_hours=item.estimated_hours,\n                created_at=item.created_at,\n                updated_at=item.updated_at,\n            )\n        )\n    \n    return updated_items"
    }
  ],
  "imports": [
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 3
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 4
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 5
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 7
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 8
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 9
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "tests/unit/test_projects.py",
      "line_number": 10
    },
    {
      "module": "analyzer",
      "names": [
        "analyze_scope",
        "analyze_scope_sync"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 22
    },
    {
      "module": "ai_analyzer",
      "names": [
        "analyze_with_ai"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 23
    },
    {
      "module": "indicators",
      "names": [
        "CLARIFICATION_PHRASES",
        "REVISION_PHRASES",
        "SCOPE_CREEP_PHRASES"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 24
    },
    {
      "module": "models",
      "names": [
        "AnalysisRequest",
        "AnalysisResult",
        "ScopeItemDTO"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 25
    },
    {
      "module": "rules_analyzer",
      "names": [
        "analyze_with_rules"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 26
    },
    {
      "module": "service",
      "names": [
        "CLASSIFICATION_MAP",
        "analyze_client_request",
        "analyze_client_request_sync",
        "bulk_analyze_project_requests"
      ],
      "file_path": "app/services/scope_analyzer/__init__.py",
      "line_number": 27
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 6
    },
    {
      "module": "fastapi",
      "names": [
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 8
    },
    {
      "module": "fastapi.security",
      "names": [
        "HTTPAuthorizationCredentials",
        "HTTPBearer"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select",
        "func"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 10
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 11
    },
    {
      "module": "app.core.security",
      "names": [
        "decode_access_token"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 13
    },
    {
      "module": "app.db.session",
      "names": [
        "get_db"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 14
    },
    {
      "module": "app.models",
      "names": [
        "User"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 15
    },
    {
      "module": "app.models.subscription",
      "names": [
        "Subscription",
        "PlanType",
        "SubscriptionStatus"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 16
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 17
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/api/deps.py",
      "line_number": 18
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/scope_item.py",
      "line_number": 2
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/scope_item.py",
      "line_number": 3
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/schemas/scope_item.py",
      "line_number": 4
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field",
        "field_validator"
      ],
      "file_path": "app/schemas/scope_item.py",
      "line_number": 6
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 2
    },
    {
      "module": "stripe",
      "names": [
        "stripe"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 3
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 7
    },
    {
      "module": "dotenv",
      "names": [
        "load_dotenv"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 8
    },
    {
      "module": "app.models.subscription",
      "names": [
        "Subscription",
        "PlanType",
        "SubscriptionStatus"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 10
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/services/stripe_service.py",
      "line_number": 11
    },
    {
      "module": "app.schemas.auth",
      "names": [
        "Token",
        "UserLogin",
        "UserRegister",
        "UserResponse"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 5
    },
    {
      "module": "app.schemas.client",
      "names": [
        "ClientCreate",
        "ClientUpdate",
        "ClientResponse",
        "ClientList"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 6
    },
    {
      "module": "app.schemas.project",
      "names": [
        "ProjectCreate",
        "ProjectUpdate",
        "ProjectResponse",
        "ProjectDetail",
        "ProjectList"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 7
    },
    {
      "module": "app.schemas.scope_item",
      "names": [
        "ScopeItemCreate",
        "ScopeItemUpdate",
        "ScopeItemResponse",
        "ScopeItemReorder",
        "ScopeProgress"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 14
    },
    {
      "module": "app.schemas.proposal",
      "names": [
        "ProposalCreate",
        "ProposalFromRequest",
        "ProposalUpdate",
        "ProposalResponse",
        "ProposalStats"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 21
    },
    {
      "module": "app.schemas.dashboard",
      "names": [
        "Alert",
        "DashboardResponse",
        "DashboardSummary",
        "ProjectHealth",
        "RecentActivity"
      ],
      "file_path": "app/schemas/__init__.py",
      "line_number": 28
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta",
        "timezone"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 6
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "Query",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy",
      "names": [
        "func",
        "select",
        "and_",
        "case"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 10
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 12
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 13
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 14
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus",
        "RequestStatus",
        "ScopeClassification",
        "ProposalStatus"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 15
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 21
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 22
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 23
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 24
    },
    {
      "module": "app.schemas.dashboard",
      "names": [
        "Alert",
        "DashboardResponse",
        "DashboardSummary",
        "ProjectHealth",
        "RecentActivity"
      ],
      "file_path": "app/api/v1/endpoints/dashboard.py",
      "line_number": 25
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 2
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 3
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 4
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 5
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field",
        "ConfigDict"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 7
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProposalStatus"
      ],
      "file_path": "app/schemas/proposal.py",
      "line_number": 9
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 3
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "Any"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 5
    },
    {
      "module": "httpx",
      "names": [
        "httpx"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 7
    },
    {
      "module": "models",
      "names": [
        "AnalysisRequest",
        "AnalysisResult"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 9
    },
    {
      "module": "rules_analyzer",
      "names": [
        "analyze_with_rules"
      ],
      "file_path": "app/services/scope_analyzer/ai_analyzer.py",
      "line_number": 10
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 3
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status",
        "Query"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select",
        "func"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 7
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 9
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 10
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 11
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 12
    },
    {
      "module": "app.schemas.client",
      "names": [
        "ClientCreate",
        "ClientUpdate",
        "ClientResponse",
        "ClientList"
      ],
      "file_path": "app/api/v1/endpoints/clients.py",
      "line_number": 13
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_clients.py",
      "line_number": 3
    },
    {
      "module": "uuid",
      "names": [
        "uuid4"
      ],
      "file_path": "tests/unit/test_clients.py",
      "line_number": 4
    },
    {
      "module": "fastapi",
      "names": [
        "status"
      ],
      "file_path": "tests/unit/test_clients.py",
      "line_number": 6
    },
    {
      "module": "collections.abc",
      "names": [
        "AsyncGenerator"
      ],
      "file_path": "app/db/session.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession",
        "async_sessionmaker",
        "create_async_engine"
      ],
      "file_path": "app/db/session.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "DeclarativeBase"
      ],
      "file_path": "app/db/session.py",
      "line_number": 13
    },
    {
      "module": "app.core.config",
      "names": [
        "settings"
      ],
      "file_path": "app/db/session.py",
      "line_number": 15
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/client.py",
      "line_number": 3
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field",
        "EmailStr",
        "ConfigDict"
      ],
      "file_path": "app/schemas/client.py",
      "line_number": 4
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "EmailStr",
        "Field"
      ],
      "file_path": "app/schemas/auth.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/schemas/auth.py",
      "line_number": 6
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 2
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 3
    },
    {
      "module": "sqlalchemy",
      "names": [
        "Column",
        "String",
        "DateTime",
        "ForeignKey",
        "Boolean"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 4
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID",
        "ENUM"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "relationship",
        "Mapped",
        "mapped_column"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 6
    },
    {
      "module": "enum",
      "names": [
        "enum"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 7
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 9
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/models/subscription.py",
      "line_number": 120
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta",
        "timezone"
      ],
      "file_path": "app/core/security.py",
      "line_number": 5
    },
    {
      "module": "typing",
      "names": [
        "Any"
      ],
      "file_path": "app/core/security.py",
      "line_number": 6
    },
    {
      "module": "jose",
      "names": [
        "JWTError",
        "jwt"
      ],
      "file_path": "app/core/security.py",
      "line_number": 8
    },
    {
      "module": "passlib.context",
      "names": [
        "CryptContext"
      ],
      "file_path": "app/core/security.py",
      "line_number": 9
    },
    {
      "module": "app.core.config",
      "names": [
        "settings"
      ],
      "file_path": "app/core/security.py",
      "line_number": 11
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 3
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 4
    },
    {
      "module": "app.api.deps",
      "names": [
        "CurrentUser",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 6
    },
    {
      "module": "app.schemas.user",
      "names": [
        "UserProfile",
        "UserUpdate"
      ],
      "file_path": "app/api/v1/endpoints/users.py",
      "line_number": 7
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 5
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 6
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy",
      "names": [
        "DateTime",
        "ForeignKey",
        "Numeric",
        "String",
        "Text"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 10
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 11
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProposalStatus"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 13
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 14
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 84
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/models/proposal.py",
      "line_number": 85
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 5
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy",
      "names": [
        "ForeignKey",
        "Numeric",
        "String",
        "Text"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 10
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 12
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestSource",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 13
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 94
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 95
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "app/models/client_request.py",
      "line_number": 96
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 2
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timezone"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Optional"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 5
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status",
        "Query"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select",
        "func"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 9
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 11
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 12
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestStatus",
        "ProposalStatus"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 13
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 14
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 15
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 16
    },
    {
      "module": "app.schemas.proposal",
      "names": [
        "ProposalCreate",
        "ProposalFromRequest",
        "ProposalResponse",
        "ProposalStats",
        "ProposalUpdate"
      ],
      "file_path": "app/api/v1/endpoints/proposals.py",
      "line_number": 17
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta",
        "timezone"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 4
    },
    {
      "module": "uuid",
      "names": [
        "uuid4"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 5
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 7
    },
    {
      "module": "pytest_asyncio",
      "names": [
        "pytest_asyncio"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 8
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 10
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 12
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus",
        "ProposalStatus",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 13
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 19
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 20
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 21
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 22
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "tests/unit/test_dashboard.py",
      "line_number": 23
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_health.py",
      "line_number": 5
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_health.py",
      "line_number": 6
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "file_path": "app/models/enums.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/client.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy",
      "names": [
        "ForeignKey",
        "String",
        "Text"
      ],
      "file_path": "app/models/client.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/client.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/client.py",
      "line_number": 9
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/client.py",
      "line_number": 11
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/client.py",
      "line_number": 13
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/models/client.py",
      "line_number": 66
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/client.py",
      "line_number": 67
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/billing.py",
      "line_number": 2
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/schemas/billing.py",
      "line_number": 3
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel"
      ],
      "file_path": "app/schemas/billing.py",
      "line_number": 4
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "file_path": "app/schemas/billing.py",
      "line_number": 5
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 3
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 4
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "Query",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy",
      "names": [
        "func",
        "select"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "selectinload"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 9
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 11
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 12
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus",
        "ScopeClassification"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 13
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 14
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 15
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 16
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 17
    },
    {
      "module": "app.schemas.project",
      "names": [
        "ProjectCreate",
        "ProjectDetail",
        "ProjectList",
        "ProjectResponse",
        "ProjectUpdate"
      ],
      "file_path": "app/api/v1/endpoints/projects.py",
      "line_number": 18
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 2
    },
    {
      "module": "uuid",
      "names": [
        "uuid4"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 3
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 5
    },
    {
      "module": "fastapi",
      "names": [
        "status"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 6
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 7
    },
    {
      "module": "app.models",
      "names": [
        "Project",
        "ScopeItem",
        "User"
      ],
      "file_path": "tests/unit/test_scope_items.py",
      "line_number": 9
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 4
    },
    {
      "module": "unittest.mock",
      "names": [
        "AsyncMock",
        "patch"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 6
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 8
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 10
    },
    {
      "module": "app.models",
      "names": [
        "Project",
        "ScopeItem"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 12
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 13
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestSource",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 14
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 658
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "tests/unit/test_client_requests.py",
      "line_number": 716
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 8
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 10
    },
    {
      "module": "typing",
      "names": [
        "TYPE_CHECKING"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 11
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 13
    },
    {
      "module": "analyzer",
      "names": [
        "analyze_scope",
        "analyze_scope_sync"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 15
    },
    {
      "module": "models",
      "names": [
        "AnalysisRequest",
        "AnalysisResult"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 16
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 19
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Session"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 20
    },
    {
      "module": "app.models",
      "names": [
        "ClientRequest",
        "Project"
      ],
      "file_path": "app/services/scope_analyzer/service.py",
      "line_number": 22
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 4
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 6
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestSource",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/schemas/scope_analyzer.py",
      "line_number": 8
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter"
      ],
      "file_path": "app/api/v1/endpoints/health.py",
      "line_number": 5
    },
    {
      "module": "app.core.config",
      "names": [
        "settings"
      ],
      "file_path": "app/api/v1/endpoints/health.py",
      "line_number": 7
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/user.py",
      "line_number": 3
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/schemas/user.py",
      "line_number": 5
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 5
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 9
    },
    {
      "module": "app.api.deps",
      "names": [
        "CurrentUser"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 11
    },
    {
      "module": "app.core.security",
      "names": [
        "create_access_token",
        "hash_password",
        "verify_password"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 12
    },
    {
      "module": "app.db.session",
      "names": [
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 13
    },
    {
      "module": "app.models",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 14
    },
    {
      "module": "app.schemas.auth",
      "names": [
        "Token",
        "UserLogin",
        "UserRegister",
        "UserResponse"
      ],
      "file_path": "app/api/v1/endpoints/auth.py",
      "line_number": 15
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 7
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 8
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 10
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 11
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 12
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "selectinload"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 13
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 15
    },
    {
      "module": "app.models",
      "names": [
        "ClientRequest",
        "Project",
        "User"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 16
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 17
    },
    {
      "module": "app.schemas.scope_analyzer",
      "names": [
        "AnalyzeExisting",
        "AnalyzeRequestCreate",
        "AnalyzeResponse",
        "AnalysisResultResponse",
        "BulkAnalyzeRequest",
        "BulkAnalyzeResponse",
        "ClientRequestResponse",
        "ScopeItemResponse"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 18
    },
    {
      "module": "app.services.scope_analyzer",
      "names": [
        "AnalysisResult",
        "analyze_client_request",
        "bulk_analyze_project_requests"
      ],
      "file_path": "app/api/v1/endpoints/scope_analyzer.py",
      "line_number": 28
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_auth.py",
      "line_number": 5
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_auth.py",
      "line_number": 6
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 3
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 4
    },
    {
      "module": "indicators",
      "names": [
        "CLARIFICATION_PHRASES",
        "REVISION_PHRASES",
        "SCOPE_CREEP_PHRASES"
      ],
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 6
    },
    {
      "module": "models",
      "names": [
        "AnalysisRequest",
        "AnalysisResult",
        "ScopeClassificationType"
      ],
      "file_path": "app/services/scope_analyzer/rules_analyzer.py",
      "line_number": 7
    },
    {
      "module": "functools",
      "names": [
        "lru_cache"
      ],
      "file_path": "app/core/config.py",
      "line_number": 6
    },
    {
      "module": "typing",
      "names": [
        "Literal"
      ],
      "file_path": "app/core/config.py",
      "line_number": 7
    },
    {
      "module": "pydantic_settings",
      "names": [
        "BaseSettings",
        "SettingsConfigDict"
      ],
      "file_path": "app/core/config.py",
      "line_number": 9
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 2
    },
    {
      "module": "stripe",
      "names": [
        "stripe"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 3
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 4
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "Request",
        "Header"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy",
      "names": [
        "select",
        "func"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 7
    },
    {
      "module": "dotenv",
      "names": [
        "load_dotenv"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 8
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 10
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 11
    },
    {
      "module": "app.models.subscription",
      "names": [
        "Subscription",
        "PlanType",
        "SubscriptionStatus"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 12
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 13
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 14
    },
    {
      "module": "app.schemas.billing",
      "names": [
        "SubscriptionResponse",
        "CreateCheckoutRequest",
        "CreateCheckoutResponse",
        "CreatePortalRequest",
        "CreatePortalResponse",
        "PlanLimits"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 15
    },
    {
      "module": "app.services.stripe_service",
      "names": [
        "StripeService"
      ],
      "file_path": "app/api/v1/endpoints/billing.py",
      "line_number": 23
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 4
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 5
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 6
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 7
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 9
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestSource",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/schemas/client_request.py",
      "line_number": 11
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 5
    },
    {
      "module": "collections.abc",
      "names": [
        "AsyncGenerator",
        "Generator"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 6
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 7
    },
    {
      "module": "typing",
      "names": [
        "Any"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 8
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 10
    },
    {
      "module": "pytest_asyncio",
      "names": [
        "pytest_asyncio"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 11
    },
    {
      "module": "httpx",
      "names": [
        "ASGITransport",
        "AsyncClient"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 12
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession",
        "create_async_engine",
        "async_sessionmaker"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 13
    },
    {
      "module": "sqlalchemy.pool",
      "names": [
        "StaticPool"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 14
    },
    {
      "module": "app.db.session",
      "names": [
        "Base",
        "get_db"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 16
    },
    {
      "module": "app.main",
      "names": [
        "app"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 17
    },
    {
      "module": "app.core.security",
      "names": [
        "hash_password"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 18
    },
    {
      "module": "app.models",
      "names": [
        "User",
        "Project",
        "ScopeItem",
        "Client"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 19
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 20
    },
    {
      "module": "app.models.enums",
      "names": [
        "ScopeClassification",
        "RequestStatus"
      ],
      "file_path": "tests/conftest.py",
      "line_number": 21
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 10
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 11
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 12
    },
    {
      "module": "unittest.mock",
      "names": [
        "AsyncMock",
        "MagicMock",
        "patch"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 13
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 15
    },
    {
      "module": "app.services.scope_analyzer",
      "names": [
        "AnalysisRequest",
        "AnalysisResult",
        "ScopeItemDTO",
        "analyze_scope",
        "analyze_with_rules",
        "analyze_with_ai",
        "CLASSIFICATION_MAP"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 17
    },
    {
      "module": "httpx",
      "names": [
        "httpx"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 287
    },
    {
      "module": "app.models.enums",
      "names": [
        "ScopeClassification"
      ],
      "file_path": "tests/unit/test_scope_analyzer.py",
      "line_number": 402
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/project.py",
      "line_number": 5
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/models/project.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy",
      "names": [
        "ForeignKey",
        "Numeric",
        "String",
        "Text"
      ],
      "file_path": "app/models/project.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/project.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/project.py",
      "line_number": 10
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus"
      ],
      "file_path": "app/models/project.py",
      "line_number": 12
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/project.py",
      "line_number": 13
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/models/project.py",
      "line_number": 97
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/models/project.py",
      "line_number": 98
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/models/project.py",
      "line_number": 99
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/models/project.py",
      "line_number": 100
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "app/models/project.py",
      "line_number": 101
    },
    {
      "module": "app.models.base",
      "names": [
        "Base",
        "BaseModel"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 5
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus",
        "ProposalStatus",
        "RequestSource",
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 6
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 13
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 14
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 15
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 16
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 17
    },
    {
      "module": "app.models.proposal",
      "names": [
        "Proposal"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 18
    },
    {
      "module": "app.models.subscription",
      "names": [
        "Subscription",
        "PlanType",
        "SubscriptionStatus"
      ],
      "file_path": "app/models/__init__.py",
      "line_number": 19
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/base.py",
      "line_number": 4
    },
    {
      "module": "sqlalchemy",
      "names": [
        "TypeDecorator",
        "CHAR",
        "String"
      ],
      "file_path": "app/models/base.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column"
      ],
      "file_path": "app/models/base.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy.dialects",
      "names": [
        "postgresql"
      ],
      "file_path": "app/models/base.py",
      "line_number": 7
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/base.py",
      "line_number": 8
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timezone"
      ],
      "file_path": "app/models/base.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy",
      "names": [
        "DateTime",
        "func"
      ],
      "file_path": "app/models/base.py",
      "line_number": 11
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/base.py",
      "line_number": 12
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column"
      ],
      "file_path": "app/models/base.py",
      "line_number": 13
    },
    {
      "module": "app.db.session",
      "names": [
        "Base"
      ],
      "file_path": "app/models/base.py",
      "line_number": 15
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 6
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 7
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy",
      "names": [
        "func",
        "select"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 10
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 11
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 13
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 14
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestStatus",
        "ScopeClassification"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 15
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 16
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 17
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 18
    },
    {
      "module": "app.schemas.client_request",
      "names": [
        "AnalyzeRequestResponse",
        "ClientRequestCreate",
        "ClientRequestListResponse",
        "ClientRequestResponse",
        "ClientRequestUpdate"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 19
    },
    {
      "module": "app.services.scope_analyzer.service",
      "names": [
        "analyze_client_request"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 26
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "selectinload"
      ],
      "file_path": "app/api/v1/endpoints/client_requests.py",
      "line_number": 90
    },
    {
      "module": "app.core.config",
      "names": [
        "settings"
      ],
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 3
    },
    {
      "module": "ai_analyzer",
      "names": [
        "analyze_with_ai"
      ],
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 5
    },
    {
      "module": "models",
      "names": [
        "AnalysisRequest",
        "AnalysisResult"
      ],
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 6
    },
    {
      "module": "rules_analyzer",
      "names": [
        "analyze_with_rules"
      ],
      "file_path": "app/services/scope_analyzer/analyzer.py",
      "line_number": 7
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/project.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/project.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "Any"
      ],
      "file_path": "app/schemas/project.py",
      "line_number": 5
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/schemas/project.py",
      "line_number": 7
    },
    {
      "module": "app.models.enums",
      "names": [
        "ProjectStatus"
      ],
      "file_path": "app/schemas/project.py",
      "line_number": 9
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 5
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy",
      "names": [
        "ForeignKey",
        "Integer",
        "Numeric",
        "String",
        "Text"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 8
    },
    {
      "module": "sqlalchemy.dialects.postgresql",
      "names": [
        "UUID"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 9
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 10
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 12
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 71
    },
    {
      "module": "app.models.client_request",
      "names": [
        "ClientRequest"
      ],
      "file_path": "app/models/scope_item.py",
      "line_number": 72
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 5
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "auth",
        "health"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 7
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "scope_analyzer"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 8
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "users"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 9
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "clients"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 10
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "projects"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 11
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "scope_items"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 12
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "client_requests"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 13
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "proposals"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 14
    },
    {
      "module": "app.api.v1.endpoints",
      "names": [
        "billing"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 15
    },
    {
      "module": "app.api.v1.endpoints.dashboard",
      "names": [
        "router"
      ],
      "file_path": "app/api/v1/router.py",
      "line_number": 16
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timezone"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 3
    },
    {
      "module": "unittest.mock",
      "names": [
        "AsyncMock",
        "MagicMock"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 4
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 6
    },
    {
      "module": "fastapi",
      "names": [
        "status"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 7
    },
    {
      "module": "httpx",
      "names": [
        "ASGITransport",
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 8
    },
    {
      "module": "app.main",
      "names": [
        "app"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 10
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "tests/unit/test_users.py",
      "line_number": 11
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 8
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 10
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 11
    },
    {
      "module": "typing",
      "names": [
        "TYPE_CHECKING",
        "Literal"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 12
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 14
    },
    {
      "module": "app.models",
      "names": [
        "ClientRequest",
        "Project",
        "ScopeItem"
      ],
      "file_path": "app/services/scope_analyzer/models.py",
      "line_number": 17
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 2
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timezone"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 4
    },
    {
      "module": "pytest",
      "names": [
        "pytest"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 6
    },
    {
      "module": "fastapi",
      "names": [
        "status"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 7
    },
    {
      "module": "httpx",
      "names": [
        "AsyncClient"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 8
    },
    {
      "module": "app.models.enums",
      "names": [
        "RequestStatus",
        "ProposalStatus",
        "ScopeClassification"
      ],
      "file_path": "tests/unit/test_proposals.py",
      "line_number": 10
    },
    {
      "module": "contextlib",
      "names": [
        "asynccontextmanager"
      ],
      "file_path": "app/main.py",
      "line_number": 7
    },
    {
      "module": "collections.abc",
      "names": [
        "AsyncIterator"
      ],
      "file_path": "app/main.py",
      "line_number": 8
    },
    {
      "module": "fastapi",
      "names": [
        "FastAPI"
      ],
      "file_path": "app/main.py",
      "line_number": 10
    },
    {
      "module": "fastapi.middleware.cors",
      "names": [
        "CORSMiddleware"
      ],
      "file_path": "app/main.py",
      "line_number": 11
    },
    {
      "module": "app.api.v1.router",
      "names": [
        "api_router"
      ],
      "file_path": "app/main.py",
      "line_number": 13
    },
    {
      "module": "app.core.config",
      "names": [
        "settings"
      ],
      "file_path": "app/main.py",
      "line_number": 14
    },
    {
      "module": "app.db.session",
      "names": [
        "close_db",
        "init_db"
      ],
      "file_path": "app/main.py",
      "line_number": 15
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "file_path": "app/models/user.py",
      "line_number": 4
    },
    {
      "module": "sqlalchemy",
      "names": [
        "String"
      ],
      "file_path": "app/models/user.py",
      "line_number": 5
    },
    {
      "module": "sqlalchemy.orm",
      "names": [
        "Mapped",
        "mapped_column",
        "relationship"
      ],
      "file_path": "app/models/user.py",
      "line_number": 6
    },
    {
      "module": "app.models.base",
      "names": [
        "BaseModel",
        "GUID"
      ],
      "file_path": "app/models/user.py",
      "line_number": 7
    },
    {
      "module": "app.models.client",
      "names": [
        "Client"
      ],
      "file_path": "app/models/user.py",
      "line_number": 67
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/models/user.py",
      "line_number": 68
    },
    {
      "module": "app.models.subscription",
      "names": [
        "Subscription"
      ],
      "file_path": "app/models/user.py",
      "line_number": 69
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "file_path": "app/schemas/dashboard.py",
      "line_number": 3
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/schemas/dashboard.py",
      "line_number": 4
    },
    {
      "module": "typing",
      "names": [
        "Literal"
      ],
      "file_path": "app/schemas/dashboard.py",
      "line_number": 5
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/schemas/dashboard.py",
      "line_number": 6
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel",
        "Field"
      ],
      "file_path": "app/schemas/dashboard.py",
      "line_number": 8
    },
    {
      "module": "decimal",
      "names": [
        "Decimal"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 2
    },
    {
      "module": "typing",
      "names": [
        "Annotated"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 3
    },
    {
      "module": "uuid",
      "names": [
        "UUID"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 4
    },
    {
      "module": "fastapi",
      "names": [
        "APIRouter",
        "Depends",
        "HTTPException",
        "status"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 6
    },
    {
      "module": "sqlalchemy",
      "names": [
        "func",
        "select"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 7
    },
    {
      "module": "sqlalchemy.ext.asyncio",
      "names": [
        "AsyncSession"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 8
    },
    {
      "module": "app.api.deps",
      "names": [
        "get_current_user",
        "get_db"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 10
    },
    {
      "module": "app.models.project",
      "names": [
        "Project"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 11
    },
    {
      "module": "app.models.scope_item",
      "names": [
        "ScopeItem"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 12
    },
    {
      "module": "app.models.user",
      "names": [
        "User"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 13
    },
    {
      "module": "app.schemas.scope_item",
      "names": [
        "ScopeItemCreate",
        "ScopeItemReorder",
        "ScopeItemResponse",
        "ScopeItemUpdate",
        "ScopeProgress"
      ],
      "file_path": "app/api/v1/endpoints/scope_items.py",
      "line_number": 14
    }
  ]
}